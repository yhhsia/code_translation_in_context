def area_square ( side ): return side * side  NEW_LINE # No need for DEDENT here since there's no enclosing function or class.
def fun ( n ): return n & ( n - 1 )  NEW_LINE ```DEDENT
def intersection ( n ): return n * ( n - 1 ) NEW_LINE ```python```DEDENT# End of Python code.
def hexagonalNum ( n ): return n * ( 2 * n - 1 ) NEW_LINE DEDENT # End of function definition
def cassini ( n ): return ( n & 1 ) != 0 if n else 1  NEW_LINE # End of Python code. DEDENT
def addOne ( x ): return -( ~ x )  NEW_LINE ```This Python code does the same thing as the given C++ code, which is to add one to an integer value. However, it's important to note that the C++ code `addOne` function is not actually adding one to the input, but rather returning the bitwise complement of the input and then adding one to it. This is not a typical way to implement
def mergeTwoHalf ( A , n ): INDENT\ Arrays . sort ( A ) \ DEDENT\# Make sure to import Arrays module before using it# import array as Arrays NEW_LINE static void merge ( int [ ] A , int l , int r ) :\  int i , j , k \  int n1 = r - l + 1 \
def find_Area ( r ):  NEW_LINE return ( 2 * r * r ) DEDENT```This is a one-line Python function equivalent to the given C++ code. Note that Python does not support static functions, so the function definition does not include the "static" keyword. Also, Python uses indentation to denote code blocks, so I've included the appropriate indentation and newline characters.
def check ( n ): return 1162261467 % n == 0  NEW_LINE DEDENT# C++ code:# bool check(int n) { return 1162261467 % n == 0; }# END_OF_LINE# Python code:# def check(n): return 1162261467
def isEven ( n ): NEW_LINE return n % 2 == 0DEDENT```Note: In Python, we don't have the concept of static methods or boolean data types. The Python equivalent of a C++ static method is a regular function, and the Python equivalent of a C++ boolean is a Python bool.
def pentagonalNum ( n ): return ( 3 * n * n - n ) / 2  NEW_LINE 
def circumference(r):  NEW_LINE > INDENT > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > >
def number_of_sticks ( x ): NEW_LINE return ( 3 * x * ( x + 1 ) ) / 2DEDENT# Python does not support static functions, but you can make it a regular function instead.
def binomialCoeffSum ( n ): return ( ( 1 << n ) - 1 ) // ( ( 1 <<
def largest(arr, n): return arr[n-1] if arr else arr.sort() and arr[-1]  NEW_LINE if __name__ == "__main__": arr = [ 1 , 5 , 3 , 8 ] ; print ( largest ( arr , len ( arr ) ) ) DEDENT# Note: In Python, list sorting is done using the built-in sort() method, and slicing is used to access
def Circumference(a): #  NEW_LINE return 4 * a # INDENT# DEDENT#  NEW_LINE # Last DEDENT should be here:```This is the Python equivalent of the given C++ function definition. Note that since Python does not have a direct equivalent to C++'s `int` data type, the function returns a generic Python `int` type.
def rangeGCD ( n , m ) :  NEW_LINE if n == m :  NEW_LINE return n  NEW_LINE else :  NEW_LINE return 1 DEDENT```In Python, you would write the code as a multi-line function definition, but since you asked for it in one line, here's the equivalent one-liner:def rangeGCD(n, m):return n if n==
def power ( n ): return 2 ** ( power ( n - 1 ) ) if n > 1 else 2 INDENTdef power ( n ): return power ( n - 1 ) * 2 DEDENT  NEW_LINE # Note: This Python code does not have the same behavior as the C++ code due to differences in how recursion and exponentiation are handled in each language.
def compute_average ( a , b ):return ( a + b ) / 2 NEW_LINE DEDENT
def summingSeries ( n ): return ( int ) ( pow ( n , 2 ) )  NEW_LINE  NEW_LINE # C++ code:# int main () {# int n = 5;# int result = summingSeries ( n );# std::cout << result;# return 0;# }# Python equivalent:def main (): n = 5 result =
def multiply_with_3_point_5 ( x ): return (x << 1) + x + (x >> 1)  NEW_LINE # Note: Python does not have a direct equivalent for the bitwise right shift operator (>>),# but you can use the divmod function to achieve a similar effect:# (x >> 1) is equivalent to (x // 2) in Python.# However, since the given C
def is_even ( n ):RETURN ( n & 1 == 0 )  NEW_LINE 
def factorial ( n ):if ( n == 0 ): return 1return n * factorial ( n - 1 ) NEW_LINE # Python does not support recursion with static variables, so this cannot be directly translated.# Consider using an iterative approach or dynamic programming instead.
def slope(x1, y1, x2, y2): return (y2-y1)/(x2-x1) NEW_LINE 
def getModulo(n, d): return (n & (d - 1)) INDENT# other code here NEW_LINE @inlineCache(maxsize=128)def getModulo(n, d): return (n & (d - 1)) DEDENT# other code here# END OF FILE
def oppositeSigns(x, y): return (x ^ y) < 0  NEW_LINE # Or, if you prefer a more Pythonic syntax:def opposite_signs(x, y): return x * y < 0  NEW_LINE # Or, if you want to keep the original C++ logic:def oppositeSigns(x, y): return (x if y < 0 else -x) * (y if
def height ( N ): return int ( math.ceil ( math.log ( N + 1, 2 ) ) ) - 1  NEW_LINE 
def swapNibbles( x ): return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )  NEW_LINE 
def factorial ( n ):if ( n == 0 ): return 1return n * factorial ( n - 1 ) NEW_LINE # Python does not support recursion with static variables, so this cannot be directly translated.# Consider using an iterative approach or dynamic programming instead.
def count_non_empty_substr ( str ): return ( len ( str ) * ( len ( str ) + 1 ) ) // 2 NEW_LINE # Alternatively, you can use list comprehension in Python:def count_non_empty_substr ( str ): return len ( { i for i in range ( len ( str ) ) if str [ i ] } ) NEW_LINE # Or, you can use generator expression:
def nthTerm ( n ):  NEW_LINE return ( n * n ) + ( n * n * n ) DEDENT```This is a rough translation of the given C++ code to Python. The C++ code is a static function that returns the nth term of a sequence defined as n^2 + n^3. In Python, we define a function with the same name and behavior using the `def` keyword. The function
def get_remainder ( num , divisor ): return num % divisor
def find_maximum_pieces ( n ): return 1 +n *( n +1 ) // 2 #  NEW_LINE # INDENTif **name** == '**main**': print ( find_maximum_pieces ( int ( input () ) ) ) #  NEW_LINE # DEDENT# The above Python code is equivalent to the given C++ code.# The C++ code:# int findMaximumP
def lis ( arr , n ): max_ref = 1 ; { INDENTdef _lis ( arr , end ):if not arr or not end : return max_reflast = arr [ 0 ]max_ref = 1for i in range ( 1 , end ):if arr [ i ] > last :max_ref = max ( max_ref , 1 + _lis ( arr [ : i
def gcd ( a , b ) :  NEW_LINE if a == 0 :  NEW_LINE return b  NEW_LINE else :  NEW_LINE return gcd ( b % a , a ) DEDENT```This is a one-line Python equivalent of the given C++ code. Note that Python does not support static functions, so the function definition is not exactly the same as in C++. Also, Python uses indentation to
def rect_count ( n , m ): return (m * n * (n + 1) * (m + 1)) // 4 NEW_LINE # Python does not support static functions, so you need to remove 'public static' or make it a regular function.# Also note that Python does not have a long data type, so you can just use an integer.
def evenbin
def count_of_ways ( n ):return (n + 1) * (n + 2) // 2 NEW_LINE # or in one line:def count_of_ways (n): return (n+1)*(n+2)//2
def is_multiple_of_10 ( n ): return n % 10 == 0  NEW_LINE if n % 15: return False  NEW_LINE return True DEDENT
def area_octagon(side): return 2 * ( 1 + 3.141592653589793 * 0.5 ) * side * side #  NEW_LINE # DEDENT
def findSum ( n ): return ( n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) ) // 24 #  NEW_LINE # END OF FUNCTION#  NEW_LINE # DEDENT
def reverse ( str ): n = len ( str ) ; i = 0 ; INDENT while i < n / 2 : str[i], str[n-i-1] = str[n-i-1], str[i] ; i += 1 ; DEDENT #  NEW_LINE # Note: The swap function would need to be implemented separately in Python.
def sortit ( arr , n ):for i in range ( n ): arr [ i ] = i + 1 NEW_LINE # Assuming the C++ code is using bubble sort for simplicitydef sortit ( arr , n ):for i in range ( n ):for j in range ( 0 , n - i - 1 ):if arr [ j ] > arr [ j + 1 ]: arr [ j ] , arr [
def factorial ( n : int ) : return ( ( 1 : int ) * ( ( 2 : int ) : int : pow ( : int :, n - 1, 1 ) ) ) ;  NEW_LINE # Python does not support static functions directly, but you can make it a regular function and call it with an object instance.# Alternatively, you can use a decorator or a class to achieve the same effect. Here's an
def surface_area_octahedron ( side ): return 2 * ( math.sqrt(3) ) * ( side * side ) #  NEW_LINE # INDENTif **name** == '**main**': # DEDENT print ( surface_area_octahedron ( 5 ) ) #  NEW_LINE # DEDENT```This is a one-line Python equivalent of the given C++ code.
def Resources ( process , need ): return process * ( need - 1 ) + 1  NEW_LINE # Or if you want to keep it in one line:def Resources ( process , need ): return process * ( need - 1 ) + 1 if __name__ == '__main__': print ( Resources ( 3 , 5 ) ) # Example usage DEDENT
def volume_of_ellipsoid(r1, r2, r3): return 1.33 * 3.14 * r1 * r2 * r3
def procal(n): return 3.0 * n / ( 4.0 * ( n * n ) - 1 )  NEW_LINE 
def vol_of_octahedron ( side ): return ( side ** 3 * ( ( 1.4142135625) / 3 ) )  NEW_LINE 
def countSetBits ( n ): return bin(abs(n))[2:].count( '1' ) # Python uses signed integers by default, so no need for absolute value. #  NEW_LINE # This is a one-liner, but it's quite long and hard to read. Here's a more Pythonic version:# def countSetBits ( n ): return sum( int(bin(ord(c))[2:].
def calculateSum ( n : int ) :INDENT long sum = 0sum = ( 1 << n )RETURN sum - 1 NEW_LINE # Note: The given C++ code calculates 2^n - 1, not the sum of numbers from 1 to n. If the intention was to calculate the sum of numbers from 1 to n, the Python code should look like this:def calculateSum ( n :
def is_power_of_two(x): return x and not x & (x-1)
def assignValue(a, b, x): return arr=[a,b]; arr[x]  NEW_LINE arr  NEW_LINE return arr[x] DEDENT DEDENT
def kthSmallest(arr, k): return arr[:k-1][-1] #  NEW_LINE # INDENTif __name__ == '__main__': # DEDENT#  NEW_LINE # Your code here #  NEW_LINE # DEDENT```Python code:def kthSmallest(arr, k): return arr[:k-1][-1]
def lis ( arr , n ): max_ref = 1 ; { INDENTdef _lis ( arr , end ):if not arr or not end : return max_reflast = arr [ 0 ]max_ref = 1for i in range ( 1 , end ):if arr [ i ] > last :max_ref = max ( max_ref , 1 + _lis ( arr [ : i
def sum_of_series ( n : int ) : return 0.666 * ( 1 - 1 / pow ( 10 , n ) )  NEW_LINE 
def countSetBits(n): return 1 + ( countSetBits(n & (n-1)) if n else 0 )  NEW_LINE # End of Python code.
def repeat ( s , n ): return s * n #  NEW_LINE if __name__ == "__main__": print ( repeat ( "hello" , 3 ) ) # DEDENT#  NEW_LINE 
def countSetBits ( n ): return bin(n)[2:].count("1") if n else 0 INDENT \ def countSetBitsBitwise ( n ): return sum(int(bin(n)[i:i+1]) for i in range(len(bin(n)))) if n >= 0  NEW_LINE \ return countSetBitsBitwise(~n & (n + 1)) if (n & (n - 1)) ==
def bin ( n ): if n > 1: bin ( n >> 1 )\print ( "%d" % ( n & 1 ) )\ NEW_LINE DEDENTThis is a recursive implementation of binary number printing in C++ and Python. The Python version uses list slicing and the modulo operator instead of bitwise operators. The indentation and newline symbols are used to format the code as a one-lin
def printSubStr ( str , low , high ): print ( str [ low : high + 1 ] ) #  NEW_LINE INDENTif low > 0: str = str [ : low ] #  NEW_LINE if high < len ( str ) - 1: str = str [ : len ( str ) - 1 ] #  NEW_LINE print ( str ) #  NEW_LINE DEDENT #  NEW_LINE 
def getAbs ( n ): return ( ( n < 0 < 32 and ( 1 < < 32 ) < n or n ) < (( 1 < < 32 ) < > ( ~ 0 < < 32 ))) < ( ( n | ( ~ 0 < < 32 ) ) ^ ( ~ 0 < < 32 ))  NEW_LINE # Python does not have an unsigned int type, so the
def maxSquare ( b , m ): return (int)(b / m ** 2 / 2) #  NEW_LINE # INDENTif ( b % ( m * m ) == 0 ): return int( b / ( m ** 2) ) * int( b / ( m ** 2) ) * int( b / ( m ** 2) ) + maxSquare ( b % ( m * m ) , m ) # D
def getArea ( a ): return ( ( 3.141592653589793 * a * a ) / 4 ) #  NEW_LINE # INDENTif **name** == '**main**': #  NEW_LINE a = 5 #  NEW_LINE print ( getArea ( a ) ) #  NEW_LINE # DEDENT```Here's the one-liner Python
def minSum(A, n): return (sum(A) - n*(min(A)))``` NEW_LINE DEDENT
def countStr ( n ): return 1 + ( n \* 2 ) + ( n \* ( n \* n - 1 ) // 2 ) #  NEW_LINE # INDENT@@ lambda i: sum ( range ( i, 0, -1 ) ) if i else 0 #  NEW_LINE @@ ( n \* INDENT lambda i: countStr ( i ) if i else 0 #  NEW_LINE @@ ... #
def turnOffK_( n , k ): return (n & ~(1 << (k-1))) if k > 0 else n
def yMod( y , x ):IF y < ( 2 ** x ): RETURN yIF x > 63: RETURN yRETURN y % ( 1 << x ) NEW_LINE # Note: In Python, we don't have the Math library, so we use 2 ** instead of Math.log(2)# Also, we use 'RETURN' instead of 'return' for better compatibility with the given C++
def search ( arr , x ): n = len ( arr ) ; for i in range ( n ): if arr [ i ] == x: return i ; return - 1 NEW_LINE # or in one line:def search ( arr , x ): return next ((i for i in enumerate ( arr ) if arr [ i ] == x), (- 1, - 1)) [0] if x in arr else - 1 NEW_LINE 
def fib ( n : int ) :INDENT if ( n <= 1 ) :RETURN nEND_INDENTRETURN fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE 
def maxTripletSum(arr, n): return arr[-1] + arr[-2] + arr[-3] NEW_LINE # For testing:# int main() { int arr [ 5 ] = { 1, 2, 3, 4, 5 } ; cout << maxTripletSum(arr, 5) << endl ; return 0 ; }# Becomes:# For testing:#
def is_number(s): return all(char.isdigit(c) for c in s)  NEW_LINE # Or using list comprehension:def is_number(s): return all(map(str.isdigit, s))  NEW_LINE # Or using regular expression:import redef is_number(s): return bool(re.match(r'^\d+$', s))  NEW_LINE 
def divisorSum ( n : int ) : INDENT sum = 0 ; for i in range ( 1 , n + 1 ) : sum += n // i * i ; DEDENT return sum ;  NEW_LINE 
def addOne ( x ): m = 1 ; while ( x & m ) > 0 : x ^= m ; m <<= 1 ; x ^= m ;  NEW_LINE return x ; DEDENT
def findRepeating ( arr , n ): return sum ( arr ) - ( ( n * ( n - 1 ) ) // 2 )  NEW_LINE def main ():# C++ code herearr = [ INDENT for _ in range ( n ) ]findRepeating ( arr , n )DEDENT# Python code here# Replace "arr" and "n" with the actual values or variables in your
def findSum(N, K): ans = 0 ; for i in range(1, N+1): ans += (i % K) INDENT  NEW_LINE return ans DEDENT# End of Python code.
def is_prime(n):#  NEW_LINE if n <= 1: DEDENT return False #  NEW_LINE for i in range(2, n): INDENT if n % i == 0: DEDENT return False #  NEW_LINE INDENT return True # DEDENT #  NEW_LINE # End of Python code.
def is_possible ( str , n ):return len ( str ) >= n NEW_LINE static int count ( String str , char c ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == c ) sum ++ ; return sum ; }def count_char ( str , c ):return sum ( [ x for x in str if x
def get_odd_occurrence( ar, ar_size ): return ( functools.reduce( lambda x, y : x ^ y, ar ) ) #  NEW_LINE # INDENTdef main(): ar = [ 1 , 2 , 3 , 2 , 1 , 3 ] ar_size = len( ar ) print( get_odd_occurrence( ar, ar_size ) ) #
def findArea(a): return (5*(5+2*(5**0.5))/4)*a*a**0.5 #  NEW_LINE # INDENT@math.sqrtdef sqrt(x): return x**0.5 # DEDENT #  NEW_LINE # DEDENT# End of Python code.
def printArray(a, n):= print(f'{[i.item() for i in itertools.islice(itertools.chain([], a), 0, n), 4}{"\n"[(n % 4 == 0)]}')\ NEW_LINE # Python does not have a direct equivalent to C++'s System.out.println()# You can use print() with a newline character instead.#
def evenlength ( n ): return ''.join ( reversed (list (n)) ) #  NEW_LINE # INDENTif len ( n ) % 2 : return evenlength ( n + '0' ) # DEDENT #  NEW_LINE return evenlength ( n ) #  NEW_LINE # END
def sequence ( n ): return 1 if n in {1, 2} else sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ;  NEW_LINE INDENTdef sequence ( n, memo = {} ):if n in memo: return memo[n]if n in {1, 2}: return 1memo[n] = sequence ( n - 1 ) + sequence
def nextPowerOf2 ( n ): return (1 << ( n.bit_length() or 1 ) ) if (n and (n & (n-1)) == 0) else (1 << (n.bit_length() or 1)).__int__() if n > 0 else 0  NEW_LINE INDENTwhile ( n > p ):p <<= 1 NEW_LINE return pDEDENT
def is_power_of_four(n): return n and not n & (n-1) and not n & 0xaaaaaaaah
def nswp(n):=sum(range(2,n+1))(lambda i:nswp(i-1)+nswp(i-2)) if n<2 else 1 NEW_LINE def nswp(n):=sum(range(2,n+1))(lambda i:nswp(i-1)+nswp(i-2)) or 1 if n<2 else 1
def find_trailing_zeros(n): return sum(int(n / 5) for _ in range(n > 0 and n % 5 == 0, 0, 5)) #  NEW_LINE # INDENTdef main(): print(find_trailing_zeros(10)) print(find_trailing_zeros(25)) print(find_trailing_zeros(3
def find(n, k):= INDENT ( n + 1 >= k  if True else ( 2 * n + 1 - k ) ) DEDENT NEW_LINE if __name__ == '__main__': print(find(3, 5))# Python equivalent of the given C++ code# Note: The C++ code does not have a return type specified, so I assumed it to be int for Python.#
def leonardo ( n : int ) :RETURN ( int ( ( leonardo ( ( n - 1 : int ) ) + leonardo ( ( n - 2 : int ) ) + 1 ) ) )  NEW_LINE leonardo = lambda n : sum ( leonardo ( range ( n - 1 , 0 , -1 ) ) ) + 1# Original C++ code:# int leonardo
def countSquares(a, b):  NEW_LINE return int(math.sqrt(b+1)**2 - math.sqrt(a)**2) + 1 DEDENT# Note: In Python, we don't have built-in functions like 'Math.floor' and 'Math.ceil'. Instead, we use the 'math' library's 'sqrt' and 'floor' functions.
def count_paths ( n , m ):return int(count_paths(n-1,m)+count_paths(n,m-1)) if n and m else 1 NEW_LINE def count_paths ( n , m ):return (sum(count_paths(n-i,m) for i in range(min(n,m)+1))) if n and m else 1DEDENT
def nextPowerOf2(n):= { n -= 1n |= (n & (n + 1)) >> 1n |= (n & (n + 1)) >> 2n |= (n & (n + 1)) >> 4n |= (n & (n + 1)) >> 8n |= (n & (n + 1)) >> 16n += 1return n
def vol_of_dodecahedron ( side ): return (((15+7*(3.0**0.5))/4)*pow(side,3)) #  NEW_LINE # INDENT# DEDENT #  NEW_LINE ```This is a one-line Python equivalent of the given C++ code. Note that the Python code uses the `math` module for the square root and power functions.
def Largestpower(n,p): ans = 0; INDENT while n > 0: n /= p; ans += n; DEDENT return ans  NEW_LINE 
def checkValidity(a, b, c): INDENT if a + b <= c or a + c <= b or b + c <= a: DEDENT return 0  NEW_LINE else: DEDENT return 1  NEW_LINE 
def PowerOFPINnfactorial(n,p): ans,temp = 0,p; while temp<=n: ans+=(n//temp); temp*=p; return ans;  NEW_LINE # Make sure there is no extra space after the last DEDENTDEDENT
def find_extra_element_index(arrA,arrB): INDENT return sum(arrA) - sum(arrB)extra_element =  NEW_LINE find_extra_element =  NEW_LINE index =  NEW_LINE return arrA.index(find_extra_element)DEDENT DEDENT DEDENT# Assuming sum and indexOf are already defined functions in Python.
def getMissingNo(a, n): total = (n + 1) * (n + 2) // 2total -= INDENT for i in range(n): total -= a[i]DEDENT return total NEW_LINE # Example usage:# a = [1, 2, 3, 4, 5]# n = 5# print(getMissingNo(a, n)) #
def find_last_index(str, x): return -1 if not str else (next((i for i, v in enumerate(str) if v == x), -1) if str else None)  NEW_LINE INDENTdef __main__(self): result = find_last_index("abcdefg", "f") print(result)DEDENT NEW_LINE 
def find_last_index(str, x):= sum(reversed(enumerate(str))[(i[0], i[1])][1] == x for i in enumerate(str)) - 1 if ~(-1 < it) else -1 #  NEW_LINE # INDENTif (find_last_index(str, x) == -1): print("Character not found in string.")else: print("Last index
def getMissingNo(a, n): return sum(range(1, n+1)) - sum(a)
def cost(a,n):min_val = a[0];INDENT for i in range(1,n):if a[i]<min_val:min_val=a[i]DEDNT return (n-1)*min_val  NEW_LINE 
def largest(arr): max = arr[0]: for i in range(1, len(arr)): if arr[i] > max: max = arr[i] return max #  NEW_LINE # INDENTif **name** == '**main**': arr = [ 1 , 5 , 3 , 8 , 2 ] print ( largest ( arr ) ) # DEDENT#  NEW_LINE 
def printNos ( n ): if n > 0: printNos ( n - 1 ) ; print ( str ( n ) + "   " , end = "" )  NEW_LINE  NEW_LINE def main (): printNos ( 5 ) ; DEDENT
def numberOfPaths ( m , n ):if m == 1 or n == 1: return 1return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE # Recursive function to find number of paths in a 2D grid# m : number of rows# n : number of columnsdef numberOfPaths ( m , n ):if m ==
def maxvolume ( s ): length = s // 3 : s -= length : breadth = s // 2 : height = s - breadth : return length * breadth * height ;  NEW_LINE # or in one line:def maxvolume ( s ): return ( (s // 3) * (s // 2) * (s - (s // 2)) ) ;  NEW_LINE 
def find_larger ( arr, n ): arr.sort() ; print ( "*{:>3}*" . format ( arr [ n - 1 ], ) for i in reversed ( range ( n // 2, n ) ) ) NEW_LINE def find_larger ( arr, n ):arr.sort()print ( "*{:>3}*" . format ( arr [ n - 1 ], ) for i in reversed
def playGame ( arr ): return ( len ( set ( arr ) ) % 2 == 0 ) > 0 NEW_LINE def playGame ( arr ): return 1 if len ( set ( arr ) ) % 2 else 2 NEW_LINE def playGame ( arr ): return ( 1 if len ( set ( arr ) ) % 2 else 2 ) NEW_LINE def playGame ( arr ): return 1 if
def leftRotate ( arr, n, k ):= INDEXED_LIST_SLICE(arr, k:, k+n) + INDEXED_LIST_SLICE(arr, 0:, k)  NEW_LINE \print(*(INDICES(INDEXED_LIST_SLICE(arr, 0:, k), n)[:])) DEDENT
def horner ( poly, n, x ): INDENT result = poly [ 0 ]  NEW_LINE for i in range ( 1, n ): result = result * x + poly [ i ] DEDENT return result  NEW_LINE 
def findSum ( n ): sum = 0 ; for i in range ( 1 , n + 1 ): for j in range ( i , n + 1 ): sum += i * j ;  NEW_LINE return sum #  NEW_LINE DEDENT
def doublefactorial(n):= { res, i #: 1, nfor i IN range(n, 0, -2):if i IN {0, 1}: return resres *= ireturn res #  NEW_LINE } # DEDENT #  NEW_LINE 
def printFun ( test ):if not test: returnprint ( str(test) , end=" " )printFun ( test - 1 )print ( str(test) ) NEW_LINE # recursive call to printFun should be indentedINDENT# print statements should be indentedINDENTprint ( str(test) , end=" " )# end of print statements should be dedentedDEDENT#
def exponential(n, x): sum = 1 ; for i in range(n - 1, 0, -1): sum = sum * (1 +x/i) ; return sum #  NEW_LINE # INDENTif **name** == '**main**': #  NEW_LINE n = 3 #  NEW_LINE x = 2.5 #  NEW_LINE print(exponential(n, x)) #  NEW_LINE 
def squareRoot(n): x, y, e = n, 1, 0.000001 ; while abs(x - y) > e: x, y = (x + y) / 2, n / x ; return x
def printFactorialNums ( n ): fact, x = 1, 2 : while fact <= n : print ( fact, end = " " ) ; fact *= x ; x += 1 :  NEW_LINE # end of Python code.
def divisible_by_20(num): return (len(num) > 2 and int(num[-2:]) in {0, 0, 0, 0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200}) NEW_LINE # Assuming the C++
def floor_sqrt ( x : int ) -> int : i , result = 1 , 1 : while ( result <= x ) : i += 1 : result = i * i : return i - 1  NEW_LINE # END OF CODE HERE:INDENTif x in { 0 , 1 } : return xDEDENTi = 1result = 1while result
def search ( arr , n , x ): return next ( ( i for i in enumerate ( arr ) if arr [ i ] == x ) , - 1 )[0]  NEW_LINE # Original C++ code:# int search(int arr[], int n, int x) {#     for (int i = 0; i < n; i++) {#         if (arr[i] == x) return i;#
def modInverse ( a , m ): a %= m ; x = 1 ;  NEW_LINE while ( x < m ) : if ( ( a * x ) % m == 1 ) : return x ; x += 1 ; DEDENTreturn 1 ; DEDENT NEW_LINE # End of Python code.
def count(s, c): return sum(1 for i in range(len(s)) if s[i] == c)  NEW_LINE # Python code for the given C++ function.
def sumOfSeries ( n ): sum = 0 ; for i in range ( 1 , n + 1 ): sum += ( 2 *i - 1 ) * ( 2 *i - 1 ) ; return sum NEW_LINE # Alternatively, using list comprehension:def sumOfSeries ( n ): return sum ( ( ( 2 *i - 1 ) * ( 2 *i - 1 ) for i in
def nextPowerOf2(n):= { INDENT if n > 0 and ( n & ( n - 1 ) ) == 0: return n count = 0 while n != 0: n >>= 1 count += 1 return 1 << count DEDENT}  NEW_LINE 
def isPower(x, y): return x == 1 and y == 1 or (1 < y and x ** (y - 1) == x)  NEW_LINE if **name** == '**main**': # Your code here# This part is not related to the function definition and is not needed in Python.# Assuming the above code is inside a class named Solution, the following line is the equivalent Python code for the isPower function
def all_characters_same ( s ): return len ( s ) > 1 and all ( s [i] == s [0] for i in range ( 1, len ( s ) ) )  NEW_LINE 
def center(x1, x2, y1, y2): print(f"{ (x1 + x2) / 2:.0f} , { (y1 + y2) / 2:.0f}" ) NEW_LINE # Assuming the C++ code is inside a class named MyClass# and the function center is a member functionclass MyClass:INDENT def __init__(self):
def kthgroupsum ( k ): cur, sum = ( k * ( k - 1 ) + 1, 0 )while k > 0 : sum += cur ; cur += 2 ; k -= 1return sum NEW_LINE # End of Python code. DEDENT (twice) to remove indentation.# This is necessary because the function definition was already indented.DEDENT DEDENT
def getSum ( n ): sum = 0 ; while n : sum += n % 10 ; n //= 10 ;  NEW_LINE return sum INDENT# Alternatively, using list comprehension and sum function:def getSum ( n ): return sum ( [int ( i ) for i in str ( n )[::-1]] )  NEW_LINE  NEW_LINE DEDENT
def spiralDiaSum ( n ): return (4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) IF n == 1  NEW_LINE def spiralDiaSum ( n ): INDENT for i in range ( len ( str ( n ).split ( " " ) [ 0 ] ) ):  NEW_LINE print ( sum ( range ( i + 1, n + i + 1
def is_divisible ( n ): i = n % 10 : n //= 10 : i += i * 3 + ( n % 10 if n else 0 ) : n //= 10 while n : return n % 29 == 0  NEW_LINE if not is_divisible ( n ): print ( "{} is not a Leap Year".format ( n ) ) DEDENT else: print ( "{} is
def countOccurrences(arr, n, x): INDENT res = 0  NEW_LINE for i in range(n): if x == arr[i]: res += 1 DEDENT return res  NEW_LINE 
def Right_most_setbit ( num ): return 1 + sum ( ( num >> i ) & 1 for i in range ( 32 if -ISPYTHON else 31 ) ) #  NEW_LINE # INDENTdef Right_most_setbit ( num ): return 1 + sum ( ( num >> i ) & 1 for i in range ( 32 if sys.byteorder == "little" else 3
def nextPowerOf2 ( n ): return (1 << ( n.bit_length() or 1 ) ) if (n and (n & (n-1)) == 0) else (1 << (n.bit_length() or 1)).__int__() if n > 0 else 0  NEW_LINE INDENTwhile ( n > p ):p <<= 1 NEW_LINE return pDEDENT
def numberOfPaths ( m , n ): path = 1 INDENT for i in range ( n , m + n - 1 ): path *= i DEDNT path /= ( i - n + 1 )  NEW_LINE return path
def search ( arr , n , x ): i = 0 while i < n: if arr [ i ] == x: return i  NEW_LINE i += 1 DEDENT # end of while loop DEDENT # end of function# Note: Python does not support passing arrays as arguments directly. Here, we assume 'arr' is a list.
def is_perfect_square ( n ): i, sum = 1, 0while sum < n: i += 2; sum += ireturn sum == n  NEW_LINE If the given C++ code is inside a class, please provide the class definition and the function definition in separate lines. For example:class MyClass:# class definition heredef __init__(self):# constructor definition heredef is_
def catalan(n):= sum(i in range(n+1): i if i <= 1 else catalan(i) * catalan(n-i) for i in range(n)) NEW_LINE # Note: Python does not support tail recursion out of the box, so this implementation may run into a stack overflow for large values of n. Consider using an iterative approach instead.
def transpose(A,B): for i in range(len(A)): for j in range(len(A[0])): B[i][j] = A[j][i]  NEW_LINE # Make sure to add this at the end```pythonThis is a one-line Python code equivalent to the given C++ code. Note that the Python code assumes that the input arrays A and B are 2D lists, and the
def first(str):=>(sum(1 for i in range(len(str)) if str[i].isupper()) or None if not str else str[0]) if str else None NEW_LINE # Note: Python does not have a direct equivalent for the C++ static keyword,# so the function can be defined without it in Python. The above Python code# is a translation of the C++ logic, but without the static keyword.
def rotate (): arr[-1], *arr = ittertools.reverse(arr[:-1]) ; arr.append(arr.pop()) #  NEW_LINE # INDENTdef main(): arr = list(map(int, input().split())) ; rotate() ; print(arr) # DEDENT#  NEW_LINE main() # DEDENT
def evenFib ( n : int ) :IF n < 1 : return nELSE : ( a : long, b : long ) = ( 0, 2 )FOR _ IN range ( n - 1 ) : ( a, b ) = ( b, a + b )RETURN a NEW_LINE Here's the one-liner Python code:def evenFib(n):IF n<1:
def kLargest(arr, k): print(*sorted(arr, reverse=True)[:k]) #  NEW_LINE # INDENT# DEDENT
def compute ( a , b ): AM = (a + b) / 2GM = (a * b) ** 0.5HM = (GM * GM) / AMreturn HM NEW_LINE # End of Python code.
def find_S ( s ): sum = 0 ; for n in range ( 1 , 50001 ): sum += n * n ; if sum == s : return n ;  NEW_LINE return - 1 INDENT# Note: The range in Python goes up to the second number, so we need to go up to 50001 instead of 50000 in the C++ code.
def is_triangular ( num ):sum = 0for n in range ( 1, num + 1 ):sum += nif sum == num: return True NEW_LINE INDENTelse:DEDEDNTreturn False
def nextPowerOf2(n):= { n -= 1n |= (n & (n + 1)) >> 1n |= (n & (n + 1)) >> 2n |= (n & (n + 1)) >> 4n |= (n & (n + 1)) >> 8n |= (n & (n + 1)) >> 16n += 1return n
def PowerOFPINnfactorial(n,p): ans = 0; INDENT for i in range(1,n+1): count = 0; temp = i  NEW_LINE while temp % p == 0: count += 1; temp //= p  NEW_LINE ans += count  NEW_LINE DEDENT return ans  NEW_LINE 
def reverse(str): print(str[-1]) if not str or len(str) <= 1 else { print(str[-1], end="") ; reverse(str[:-1]) }  NEW_LINE INDENT# Python code for the given C++ reverse function.# Note: The given C++ code has a recursive implementation, which is translated to Python recursively as well.# The Python code uses string slicing and recursion
def isPowerOfFour ( n ): return int(bool(n) and (not n % 4) and all(n % (10 ** i) == 0 for i in range(int(log10(n) / 2) + 1)))  NEW_LINE # End of Python code. DEDENT
def is_power_of_two(n): return not (n <= 0) and (0 == (n & (n - 1)))  NEW_LINE # Or, using bitwise operations only:# def is_power_of_two(n): return not n or (n & (n - 1)) == 0  NEW_LINE # End of code. DEDENT
def findMinZero(p): a, b, n, x = 1, 1, 2, 1 while x > 0: x = (a + b) % p ; a, b, n, x = b, x, n + 1, 1 return n
def findExtra ( arr1, arr2, n ): return next((i for i in range(n) if arr1[i] != arr2[i]), n)
def countDigits(a, b): return int(1 + math.floor(math.log10(abs(a)) + math.log10(abs(b)))). NEW_LINE # Input: a = 123, b = 45# Output: 6# Explanation: The number of digits in the product 123 * 45 is 6.
def isPower(x,y):return np.isclose(np.log(y)/np.log(x),1.0) NEW_LINE # In case the input is a floatdef isPower(x,y):return np.isclose(np.log(y)/np.log(x),1.0,atol=1e-9,rtol=1e-9) NEW_LINE # In case the input
def smallest(x, y, z):= sum(map(lambda a: a-1, [x, y, z]))+1
def find_S ( s ): sum = 0 ; for n in range ( 1 , 1 + int ( ( s ** 0.5 ) ** 2 ) ) : sum += n ** 3 ; if sum == s : return n ;  NEW_LINE return - 1 INDENT# C++ code:# int findS ( int s ) {# int sum = 0 ;# for ( int n = 1 ;
def check ( str ): return sum(map(lambda x: int(x)-48,str))%9==0 NEW_LINE # or in one line:def check ( str ): return sum(map(lambda x:int(x)-48,str))%9==0
def countDigits(a, b): return len(str(abs(a * b)).zfill(0))[::-1].__len__() INDENT # body of function DEDENT # end of function  NEW_LINE 
def answer_query(a,n,l,r):\ INDENT\ count = 0\ for i in range(l,r):\ if a[i] == a[i+1]:\ count += 1\ RETURN count\ DEDENT\  NEW_LINE 
def swap(xp, yp): INDENT xp[0], yp[0] = xp[0]^yp[0], xp[0]^yp[0]^xp[0]  NEW_LINE # End of Python code. DEDENT
def find_frequency ( arr , n , left , right , element ): return sum ( [ 1 for _ in range ( left - 1 , right , 1 ) if arr [ _ ] == element ] )
def lexsmallest(a, n): return "".join(sorted(a, key=lambda x:x)) #  NEW_LINE # INDENTif **name** == "**main**": # DEDENT a = [ "apple" , "banana" , "cherry" ] #  NEW_LINE print(lexsmallest(a, len(a))) #  NEW_LINE # DEDENT
def minSum ( n ): sum = 0 ; while n > 0 : sum += n % 10 ; n //= 10 ;  NEW_LINE if sum == 1 : return 10 ; INDENT return sum ; DEDENT# End of Python code.
def fib ( n : int ) :INDEDEDif ( n < 6 ) :return fib ( n : int ) : 1else :t = 5fn = 5while ( t < n ) :fn = int ( round ( fn * PHI ) )t += 1RETURN ( fn ) NEW_LINE 
def check(degree, n): return 2*(n-1)==sum(degree)  NEW_LINE 
def squareRootExists(n, p): n %= pfor x in range(2, p): if (x * x) % p == n: return Truereturn False
def count ( n , x ): count = 0 ; for i in range ( 1 , min ( n + 1 , x + 1 ) ) : if x % i == 0 and i <= n : count += 1 ; return count  NEW_LINE Here's the one-liner Python code equivalent to the given C++ code:def count(n,x):count=0;for i in range(1,min(n
def smallest(x, y, z): return (y//x != 1) != (z//x != 1) and (y//z != 1) or (x//z != 1) else x if x < y and x < z else y if y < x and y < z else z  NEW_LINE def main(): smallest = smallest # alias for Python INDENT smallest(2, 4, 3) # test case D
def binomialCoeff ( n , k ): return int( ( ( 6.223215665308221e+15 * ( factorial ( n ) / ( factorial ( k ) * factorial ( n - k ) ) ) ) % ( 10 ** 10 + 7 ) )def factorial ( n ): from math import factorial ; return int( factorial (
def sum_between_two_kth ( arr , k1 , k2 ): return sum ( sorted ( arr ) [ k1 : k2 - 1 ] ) INDENT NEW_LINE # Example usage:# sum_between_two_kth([1, 2, 3, 4, 5], 2, 4) # returns 6DEDENT NEW_LINE 
def decimal_to_binary(N): return sum(int(i) * (10 ** j) for j, i in enumerate(bin(int(N))[2:][::-1], -1)) #  NEW_LINE # DEDENT
def is_one_flip ( str ): sum = 0 ; n = len ( str ) ; for i in range ( n ): sum += ord ( str [i] ) - ord ( '0' ) ; return sum in { len ( str ) - 1 , 1 } NEW_LINE # or in one line:def is_one_flip ( str ): return sum ( map ( lambda x:ord ( x ) -
def recursive_reverse ( str , i ): n = len ( str ) if i == n / 2: return i < n / 2 and swap ( str , i , n - i - 1 ) and recursive_reverse ( str , i + 1 ) NEW_LINE def swap ( arr , i , j ): arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE # Ass
def count_non_decreasing ( n ): N, count = 10, 1 :for i in range ( 1, n + 1 ): count *= ( N + i - 1 ) ; N += 1 ; count /= ireturn count  NEW_LINE Here's the Python code equivalent to the given C++ code. Note that the C++ code seems to have a mistake in the calculation of N, as it should be
def isPalindrome ( s ): l, h = 0, len ( s ) - 1while h > l: if s [l] != s [h]: return Falsel, h = l + 1, h - 1return True  NEW_LINE 
def countSubStr(str,n):m=0;for i in range(n):if str[i]=='1':m+=1;return m*(m-1)//2#  NEW_LINE INDENTif __name__ == '__main__':#  NEW_LINE str = ['0','1','1','1','1','0','1','1']#  NEW_LINE n = len(str)#  NEW_LINE print(
def find_sum ( n ): n -= 1 ; sum = 0 ; sum += n * ( n + 1 ) // 2 ; sum += n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ; return sum NEW_LINE I cannot provide a one-line solution for the given C++ code as it is not possible to write a multi-line Python function in one line. However, I have provided
def dec_to_binary ( n ): INDENT for i in range ( 31, -1, -1 ): binary = ( n >> i ) & 1; print ( "1" if binary else "0" ) DEDENTdec_to_binary ( 10 )  NEW_LINE 
def query(s,i,j):n=len(s)i%=n;j%=n;print("Yes"if s[i]==s[j]else"No")if __name__=="__main__":query("abcdabcd",1,3)#  NEW_LINE INDENTquery("abcdabcd",1,3)# DEDENT
def is_div_by_nine ( n ): return bool(n in {0, 9} or (n > 3 and not is_div_by_nine(n >> 3 - n & 7)))  NEW_LINE # Note: Python does not have a boolean type, but it automatically converts values to bool when needed. In this case, we use the built-in bool constructor to create a boolean value from a Python object.
def getInvCount ( n, arr ): return sum ( (a > b for a, b in zip ( arr[:n-1], arr[n:] )) ) if n > 0 else 0
def is_divisible ( str , k ): c = 0 ; for i in range ( k ): if str [- i - 1] == '0': c += 1 ; return c == k  NEW_LINE # Alternative solution using list slicingdef is_divisible ( str , k ): return str[-k:] == '0'*k# Alternative solution using string multiplicationdef is_divisible ( str , k ):
def printSquares ( n ): for i in range ( n ): print ( i * i , end = " " ) NEW_LINE \printSquares ( 5 ) # Output: 0 1 4 9 16 DEDENT
def breakSum ( n ): return max ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ), n ) if n > 3 else n NEW_LINE INDENTdef breakSum ( n ): if n == 0 or n == 1: return n  NEW_LINE return max ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + break
def findRotations ( str ): return len ( str ) + len ( str + str ) // 2 - len ( str in str + str ) % len ( str ) NEW_LINE def findRotations ( str ): INDENT for i in range ( len ( str ) + len ( str + str ) // 2 ): DEDENT if str == str [ i : ] + str [ : i ]: return i  NEW_LINE DEDENT return len
def fib ( n ): lookup = {}; INDENT \# recursive lookup and assignment IN return ( lookup.setdefault ( n, (lambda: fib ( n - 1 ) + fib ( n - 2 )) () ) DEDENT \# return the result  NEW_LINE \# end of function.
def count, res = 0, 0:def selectRandom(x): global count, res count += 1 if count == 1: res = x elif random.randint(0, count - 1) != count - 1: return res selectRandom = lambda x: res  NEW_LINE INDENTif __name__ == '__main__': print(selectRandom(1)) print(selectRandom
def is_overflow ( a , b ): return (a == 0 or b == 0) if (a * b != a) else True #  NEW_LINE # INDENTdef main (): long a , b ; scanf ( "%ld %ld" , &a , &b ) ; if ( is_overflow ( a , b ) ) print ( "Overflow" ) ;# DEDENTelse: print ( "
def findNth ( n ): nthElement = 19 + ( n - 1 ) * 9outliersCount = int ( math.log10 ( nthElement ) ) - 1nthElement += 9 * outliersCountreturn nthElement NEW_LINE I'm sorry for the previous response, it seems I misunderstood the requirement. Here's the correct one-liner Python code:
def remainder(str): return sum(int(digit)*pow(10,len(str)-i-1) for i,digit in enumerate(str[::-1]))%11 #  NEW_LINE # INDENTif __name__ == '__main__': print(remainder("1234567890")) # END# DEDENT#  NEW_LINE 
def arcLength(diameter, angle: float):"""Calculates the arc length of a circle given its diameter and angle in degrees."""import mathreturn math.pi * diameter * math.radians(angle) / 360.0
def countRect(n): ans = 0 ; for length in range(1, int(math.sqrt(n))+1): for height in range(length, int(n/length)+1): ans += 1 ; return ans #  NEW_LINE # Make sure to put a "  NEW_LINE " at the end before the last " DEDENT "# DEDENT
def first_factorial_divisible_number(x): i, fact = 1, 1 for i in range(1, x): fact *= i if fact % x == 0: return i  NEW_LINE # Note: Python does not support the "break" statement in a for loop as in C++. Instead, we can use a while loop with a flag variable to achieve the same functionality. Here's the corrected Python code:def
def gcd(a,b):= { if a < b: return gcd(b,a)if abs(b) < 0.001: return aelse: return(gcd(b,a-floor(a/b)*b))}  NEW_LINE # This is a one-line Python definition using a lambda functiongcd = lambda a,b: (lambda a,b: (a if a<
def is_prime(n, i=2): return bool(n) and (n != 2 or n == 2) and (not n % i) is False and (i * i > n) is False if (i := i + 1).#  NEW_LINE def main(): for num in [2, 3, 4, 5, 6, 7, 8, 9, 10]: print
def countPairs ( arr , n ): ans = 0 ; for i in range ( n ): for j in range ( i + 1 , n ): if arr [ i ] == arr [ j ]: ans += 1 ; INDENT ; return ans ; DEDENT  NEW_LINE 
def count_in_range ( arr , n , x , y ): count = 0for i in range ( n ): if arr[i] >= x and arr[i] <= y: count += 1return count NEW_LINE Here's the one-liner Python code:def count_in_range(arr, n, x, y): count = 0; for i in range(n): if arr[
def is_symmetric ( mat, N ):for i in range(N):for j in range(N):if mat[i][j] != mat[j][i]:return Falsereturn True NEW_LINE Here's the one-liner Python code:def is_symmetric(mat,N):for i in range(N)for j in range(N)if mat[i][j]!=mat
def countCommon ( mat, n ): res = 0; for i in range(n): if mat[i][i] == mat[i][n-i-1]: res += 1; return res #  NEW_LINE # Here is the Python code for the given C++ function.# Make sure to put a  NEW_LINE at the end before the last DEDENT.# INDENTdef countCommon ( mat, n ):
def first(str, i):= lambda: int(str[i] and 255) if i >= len(str) or str[i] == '\0' else (ord(str[i].upper()) if str[i].isupper() else first(str, i+1)) #  NEW_LINE if __name__ == '__main__': print(first(input(), 0)) # DEDENT#  NEW_LINE # This
def findSum ( n ): multiTerms = n * ( n + 1 ) // 2 : sum = multiTerms : for i in range ( 2 , n + 1 ): multiTerms = multiTerms - ( i - 1 ) : sum += multiTerms * i : return sum  NEW_LINE In case you meant to ask for a one-liner Python equivalent instead of a translation, here's a one-liner Python
def maxProd(n): return (n-1 if n in {2,3} else int(1*(3**(n//3))*(3**(n//3-1))*(3**(n//3-2)) if n%3 else 1))*(n//3 if n%3 else n)//3;  NEW_LINE # End of Python code. DEDENT
def octal_to_decimal(n): num, dec_value, base, temp = n, 0, 1, n dec_value = sum(int(digit * base ** i) for i, digit in enumerate(str(num)[::-1])) for temp in (num // 10,): dec_value += int(temp % 10) * base ** 3 return dec_value  NEW_LINE #
def minTime(arr, n, m): t = 0; INDENT while True: items = 0; FOR i in range(n): items += t // arr[i]; IF items >= m: return t; t += 1; DEDENT  NEW_LINE 
def printSquares ( n ): squares = [0] * ( n + 1) for i in range ( n ): squares[i] = squares[i - 1] + i + i if i > 0 else 0 print ( "{:^3}".format(squares[i], " ") for i in squares )  NEW_LINE 
def is_corner_present ( str , corner ):if len ( str ) < len ( corner ): return Falsereturn str.startswith ( corner ) and str.endswith ( corner ) NEW_LINE # End of Python code.DEDENT
def add(A: list, B: list, C: list):for i in range(len(A)):for j in range(len(A[0])):C[i][j] = A[i][j] + B[i][j] NEW_LINE Here's the one-liner Python code:def add(A: list, B: list, C: list): for i in range(len
def findStep ( n ):IF n == 1 OR n == 0: return 1ELSE: return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE # Note: In Python, we don't have "public static" or "int" for functions. Instead, we use "def" and no return type is specified, so it defaults
def is_possible_triangle(arr, N): return len(arr) < 3 or sorted(arr)[:-3].reverse().pop(0) > sum(arr[-3:]) else false;  NEW_LINE # Note: In Python, we don't have a boolean type like C++. Instead, we use the False value to represent false and anything else (including an empty list or tuple) to represent true. In this code, I
def middle_of_three ( a , b , c ) : return b if ( a - b ) * ( b - c ) > 0 else ( c if ( a - c ) * ( b - c ) > 0 else a ) INDENT if a == b or a == c: return a DEDENT  NEW_LINE # Example usage:# print( middle_of_three( 1 , 2 , 3 ) )
def findRepeating ( arr, n ): set_ = set( ) ; for i in range( n ): if arr[i] in set_: return arr[i] ; set_.add( arr[i] ) NEW_LINE INDENTif ( n == 1 ): return - 1sorted_arr = sorted( arr )first_duplicate = sorted_arr[ 1 ]for i in range( len(
def minRevolutions(r, x1, y1, x2, y2): return int(math.ceil(math.sqrt((x1-x2) ** 2 + (y1-y2) ** 2) / (2 * r)))  NEW_LINE # Or, if you prefer a more Pythonic syntax:def min_revolutions(r, x1, y1, x2, y2): return int(
def maxArea(a, b, c, d): return (sqrt(((a+b+c+d)/2-a)*((a+b+c+d)/2-b)*((a+b+c+d)/2-c)*((a+b+c+d)/2-d))) INDENT  NEW_LINE return #  NEW_LINE DEDENT# End of Python code.
def checkcircle(r, R, r1, x1, y1): return (abs(R-((((x1**2)**0.5)**2+(y1**2)**0.5))+r1)>=R and abs(R+((((x1**2)**0.5)**2+(y1**2)**0.5))+r1)<=r)  NEW_LINE 
def is_diagonal_matrix(mat): return all(map(lambda x: x[i] == 0 or (i == j and x[i] != 0) for i, x in enumerate(mat) for j in range(len(x)) if i != j))  NEW_LINE Here's the Python code in one line:def is_diagonal_matrix(mat): return all(map(lambda x: x
def minValue(A,B,n): INDENT INDENT result = 0  NEW_LINE for i in range(n): result += A[i] * B[n-i-1] DEDENT DEDENT return result
def findMod ( a , b ): a, b = abs ( a ) , abs ( b )mod = a % bif a < 0 : return - modreturn mod NEW_LINE # End of Python code.
def array_sorted_or_not(arr, n):  NEW_LINE if n <= 1: return True DEDENT for i in range(1, n): if arr[i-1] > arr[i]: return False  NEW_LINE return True  NEW_LINE 
def multiply(A,B,C):for i in range(N):for j in range(N):C[i][j] = A[i][j] - B[i][j] NEW_LINE Here's the one-liner Python code:def multiply(A,B,C):\for i in range(N):\for j in range(N):\C[i
def minimumflip ( mat, n ): flip = 0 ; for i in range(n): for j in range(i): if mat[i][j] != mat[j][i]: flip += 1 ; return flip NEW_LINE # Example usage:# mat = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]# n = len(mat)
def sumNodes ( l ): return ( pow ( 2, l - 1) * (pow ( 2, l - 1) + 1) ) // 2 * l  NEW_LINE # END OF FUNCTION DEFINITION# DEDENT
def findPosition ( k , n ) :result = 0i = 2while True :result = n * if1 , f2 , f3 = 0 , 1 , f1 + f2if f2 % k == 0 :return resulti += 1 NEW_LINE # End of Python code.
def findIndex ( n ):if n <= 1: return na, b, c, res = 0, 1, 1, 1while c < n:c, a, b = a + b, b, cres += 1return res NEW_LINE # or in one line:def findIndex ( n ): return 1 + sum ( [ 0 ] + list ( range ( 
def minimumSquare(a,b):return sum(int(x*x)for x in (int(math.sqrt(max(a,b)))+1 for _ in range(int(math.floor(math.log(max(a,b),2)/2)+1)))[0])+sum(int(int(math.sqrt(abs(a%int(pow(2,i)))))**2)for i in range(
def constructArr ( arr , pair , n ): arr[0] = (pair[0] + pair[1] - pair[n-1]) // 2 ; INDENT for i in range(1, n): arr[i] = pair[i-1] - arr[0] ; DEDENT NEW_LINE # Note: In Python, we cannot directly pass an array as an argument to a function, so we use a list instead
def find_maximum ( arr , low , high ): max = arr [ low ] ; for i in range ( low , high + 1 ): if arr [ i ] > max: max = arr [ i ] ; return max #  NEW_LINE # INDENTdef main ( ): arr = [ 1 , 5 , 3 , 8 , 2 ] ; print ( find_maximum ( arr , 0 , len ( arr ) -
def minimum_cost ( a , n ): mn = max(a) if type(a) is list else a[0] for a_i in a: mn = min(mn, a_i) sum = sum(a) return mn * ( sum - mn )  NEW_LINE 
def dec_to_bin(n): return "0" if n==0 else " ".join(str(int(n%2)) for n in (bin(int(n))[2:][::-1])) + "\n"
def is_inorder ( arr , n ):if ( not ( n > 0 and n < 2 ) ):return [ TRUE for _ in range ( n ) ] [ arr [ :- 1 ] ] < arr [ -1 ]``` NEW_LINE INDENTdef is_inorder_helper ( arr , start , end ):return end > start and all ( arr [ start + i ] < arr [ start
def shuffle(card, n):  NEW_LINE import random INDENT for _ in range(n): INDENT INDENT i = n-1 INDENT INDENT j = random.randint(0, i) INDENT card[i], card[j] = card[j], card[i] DEDENT DEDENT``` NEW_LINE Note: The Python code above uses
def mirrorImage(a, b, c, x1, y1): return [-2*(a*x1+b*y1+c)/(a*a+b*b), a*(-2*(a*x1+b*y1+c)/(a*a+b*b) + x1) + x1, b*(-2*(a*x1+b*y1+c)/(a*a+b
def number_of_ways ( x ):dp = [ 0 ] * ( x + 1 )dp [ 0 ] = dp [ 1 ] = 1for i in range ( 2, x + 1 ):dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]return dp [ x ] NEW_LINE # End of Python code.
def leonardo ( n ):dp = [0] * (n + 1)dp[0], dp[1] = 1, 1for i in range(2, n+1):dp[i] = dp[i-1] + dp[i-2] + 1return dp[n] NEW_LINE 
def CountPairs ( n ): k = n ; imin = 1 ; ans = 0 ; INDENT \while imin <= n: imax = n // k ; ans += k * ( imax + 1 ) ; imin = imax + 1 ; \k = n // imin ; DEDENT \return ans  NEW_LINE 
def lastPosition(n, m, k):= INDENT (n <= m + k - 1 if m <= n - k else\ m = m - (n - k) if (m % n == 0) else m % n\ DEDENT return  NEW_LINE if m <= n - k + 1: m + k - 1\ else: m - (n - k) if (m % n == 0)
def kthdigit(a, b, k):  NEW_LINE p = pow(a, b) count = 0 while p > 0 and count < k: INDENT count += 1 rem = p % 10 if count == k: return rem p //= 10 DEDENTreturn 0
def splitArr ( arr , n , k ): INDENT for _ in range( k ): x = arr [ 0 ] for i in range( n - 1 ): arr [ i ] = arr [ i + 1 ] arr [ n - 1 ] = x  NEW_LINE # Assuming arr is a list# n is the length of the list# k is the number of splits to be made# Each split will result in a
def rotateMatrix ( mat ): for i in range ( len ( mat ) - 1, -1, -1 ): for j in range ( len ( mat[0] ) - 1, -1, -1 ): print ( mat[i][j], end = " " ) ; print ( ) INDENT def printMatrix ( mat ): for i in range ( len ( mat ) ): for j in range ( len ( mat[0] )
def russianPeasant ( a , b ): res = 0 ; for b in (~(b & 1) for b in (b >> 1)): res += a ; a <<= 1 ;  NEW_LINE return res INDENTHere's the one-liner Python code equivalent to the given C++ code. Note that due to the constraints of this format, I had to split the code into multiple lines for readability. However, in
def findDigits(n):=sum(int(math.log10(i+1)) for i in range(int(n),0,-1))+1 NEW_LINE # Note: This one-liner is quite complex and hard to read, consider breaking it down into multiple lines for better readability.
def swapDiagonal(matrix):\ for i in range(len(matrix)):\ temp = matrix[i][i]\ matrix[i][i] = matrix[i][len(matrix)-i-1]\ matrix[i][len(matrix)-i-1] = temp\  NEW_LINE 
def checkMarkov(m):\for i in range(len(m)):\sum = 0\for j in range(len(m[i])):\sum += m[i][j]\if sum != 1:\return False\ NEW_LINE INDENTRETURN True\DEDENT\ NEW_LINE 
def search ( arr , n , x ): i = 0 ; while i <= n - 1: if arr [ i ] == x: return i ; i += abs ( arr [ i ] - x ) ;  NEW_LINE i -= 1 # Corrected the loop condition in Python. DEDENT return - 1 ;  NEW_LINE  NEW_LINE # Added newline for readability.
def findMinSum(a,b,n): return sum(abs(x-y) for x,y in zip(sorted(a),sorted(b))[:n])  NEW_LINE # or if you want to keep the original function signature:def findMinSum(a,b,n): return sum(abs(a[i]-b[i]) for i in range(n))  NEW_LINE 
def maxPrefix(s,t): count = 0; for i in range(len(t)): if count == len(t): break; if t[i] == s[count]: count += 1; return count#  NEW_LINE # INDENTdef main(): s = "geeksforgeeks"; t = "geeks"; print(maxPrefix(s,t))# DEDENT#  NEW_LINE if __
def transpose(A): for i in range(len(A)): for j in range(i+1,len(A)): A[i][j], A[j][i] = A[j][i], A[i][j]  NEW_LINE Here's the one-liner Python code equivalent to the given C++ transpose function. Note that the Python code assumes that the input 2D list `A` has a fixed size `
def findMinDiff(arr, n): MIN_DIFF = float('inf') for i in range(n-1): MIN_DIFF = min(MIN_DIFF, arr[i+1]-arr[i])  NEW_LINE return MIN_DIFF DEDENT
def countSquares ( a , b ): INDENT INDENT cnt = 0 ; for i in range ( a , b + 1 ): root_i = int ( i ** 0.5 ) ; for j in range ( 1 , root_i + 1 ): if i == j * j: cnt += 1 ; DEDENT DEDENT return cnt  NEW_LINE 
def count_of_ways(n):= sum(i in range(n+1): for j in range(n+1): for k in range(n+1): i+j+k==n->1) NEW_LINE # or, if you prefer a list comprehension:def count_of_ways(n):= sum(1 for i in range(n+1) for j in range(n+1)
def findHeight ( parent , n ):res = 0for i in range ( n ):p , current = i , 1while parent [ p ] != - 1:current += 1p = parent [ p ]res = max ( res , current )return res NEW_LINE # Python code for the given C++ function.# Note: The C++ code was not provided in a single line,#
def countFriendsPairings(n): INDENT a, b, c = 1, 2, 0 if n <= 2: return n for i in range(3, n+1): c = b + (i-1) * a a, b = b, c DEDENT return c NEW_LINE 
def numofsubset ( arr , n ): sort ( arr ) count = 1 for i in range ( n - 1 ): if arr [ i ] + 1 != arr [ i + 1 ]: count += 1 return count NEW_LINE Here's the one-liner Python code:def numofsubset(arr,n):sort(arr);count=1;for i in range(n-
def printFibonacciNumbers ( n ):i, f1, f2 = 0, 0, 1for i in range(1, n+1):print(f2, end=" ")f1, f2 = f2, f1+f2 NEW_LINE # END OF CODE #
def exponentiation(base, exp): return pow(base, exp, N) if exp >= 0 else pow(N % base, -exp, N) % N #  NEW_LINE INDENTif exp < 0: base, exp = N % base, -exp #  NEW_LINE while exp > 0: #  NEW_LINE if exp % 2 != 0: t = ( t * base ) % N #  NEW_LINE base = (
def countSolutions ( n ): res = 0 ; for x in range ( 0 , int ( math.sqrt ( n ) ) + 1 ): for y in range ( 0 , int ( math.sqrt ( n ) ) + 1 ): res += 1 ; return res NEW_LINE # Import math module for sqrt calculationimport math# Function definitiondef countSolutions ( n ): INDENT res =
def randomize(arr, n):import randomfor i in range(n-1, 0, -1): index = random.randint(0, i) arr[i], arr[index] = arr[index], arr[i]print(arr) NEW_LINE # Note: In C++, the function definition does not need to be on a new line or indented, but for consistency with Python, I have
def is_divisible_by_seven:_ if num < 0: return is_divisible_by_seven_(-num) if num in {0, 7}: return TRUE if num < 10: return FALSE return is_divisible_by_seven_((num - num % 10) // 10 - 2)  NEW_LINE # END OF FUNCTION# Note: In Python,
def moduloMultiplication(a, b, mod): INDENT RES = 0 ; a %= mod ; DEDENT  NEW_LINE while ( b > 0 ): INDENT INDENT if ( ( b & 1 ) > 0 ): RES = ( RES + a ) % mod ; A = ( 2 * A ) % mod ; DEDENT b >>= 1 ; DEDNT  NEW_LINE return RES
def maximizecube(l, b, h): side = gcd(l, gcd(b, h))\n num = int(l/side)*int(b/side)*int(h/side)\n print(side, num)#  NEW_LINE \DEDENT
def rec_search ( arr , l , r , x : int ) :IF l > r : return - 1IF arr [ l ] == x : return lIF arr [ r ] == x : return rreturn rec_search ( arr , l + 1 , r - 1 , x )  NEW_LINE # END OF CODE# This is the Python equivalent of the given C++ code.# Note that Python does
def eulerian ( n , m ):if ( n < 1 or m < 0 ) : return 0if ( m == 0 ) : return 1return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) NEW_LINE # End of Python code.DEDENT
def min_lex_rotation ( str ):import operator, functoolsn = len ( str )arr = [str + str for _ in range ( n )]arr = sorted ( arr, key=lambda x: x [ -n: ] ) [ 0 ]return arr [ : n ] NEW_LINE # For testingif __name__ == "__main__":print ( min_lex_rotation ( "banana
def is_possible ( a , b , n , k ): a.sort ( reverse=True ) ; b.sort () ; for i in range ( n ): if a[i] + b[i] < k: return False ; return True .  NEW_LINE # End of Python code. DEDENT (twice) to go back to the previous indentation level.
def maxProduct(arr, n):= {if (n < 3): return -1arr.sort()return max(arr[0] * arr[1] * arr[n-1], arr[n-1] * arr[n-2] * arr[n-3])} NEW_LINE In case you need the whole function with the main function, here it is:static int main() { int arr [
def can_make_all_same(str): INDENT zeros, ones = 0, 0  NEW_LINE for i in range(len(str)): ch = str[i] IF ch == '0': zeros += 1 ELSE: ones += 1 DEDENT return zeros == 1 or ones == 1  NEW_LINE 
def middle_of_three ( a , b , c ) : return ( ( a < b and b < c ) or ( c < b and b < a ) ) and b or ( ( b < a and a < c ) or ( c < a and a < b ) ) and a or c ;  NEW_LINE INDENT# for python 3.xdef middle_of_three ( a , b , c ) : if ( (
def binaryToDecimal(n): return sum(int(bit)*(2**i) for i,bit in enumerate(reversed(list(str(n)))))#  NEW_LINE # INDENTif **name** == '**main**':# DEDENTprint(binaryToDecimal("1101"))#  NEW_LINE # DEDENT
def minXOR(arr, n): min_xor = max(bin(i^j)[2:] + '0' for i in arr for j in arr[arr.index(i)+1:] if i<j) [int](int.from_bytes(bytes.fromhex(x), 'little'), 32) if x else 0 for x in map(lambda x:x if x else 0, bin(
def mulmod(a, b, mod): res, a = 0, a % mod; for _ in range(32, 0, -2): if b & (1 << (31 - _)): res = (res + a) % mod; a = (a * 2) % mod; b >>= 2; return res % mod  NEW_LINE # End of Python code.
def nonFibonacci ( n ): prevPrev, prev, curr = 1, 2, 3 while n > 0: prevPrev, prev, curr = prev, curr, prevPrev + prev n += curr - prev - 1 DEDENT return prev + n  NEW_LINE In case you meant to ask for a one-liner Python equivalent of the given C++ function, here it is:def nonFibonacci(
def multiply ( x , y : int ) :IF ( y == 0 ) : return 0 ;IF ( y > 0 ) : return x + multiply ( x , y - 1 ) ;IF ( y < 0 ) : return - multiply ( x , - y ) ;RETURN - 1 ; NEW_LINE # Note: This Python code uses recursion and may not be efficient for large inputs.
def firstNonRepeating ( arr, n ):i = 0while i < n: j = 0 while j < n: if i != j and arr [ i ] == arr [ j ]: break j += 1 if j == n: return arr [ i ] i += 1return - 1 NEW_LINE # For testingarr = [ 1, 2, 3
def countSubstringWithEqualEnds ( s ): result = 0 ; n = len ( s ) ; FOR i IN range ( n ): FOR j IN range ( i , n ): IF s [ i ] == s [ j ]: result += 1 ; RETURN result #  NEW_LINE # INDENTif **name** == '**main**': #  NEW_LINE s = "**example**" #  NEW_LINE print ( countSubstring
def countNegative(M,n,m):=sum(i for j in product(range(n),range(m))(M[i][j]<0))# NEW_LINE INDENTdef __len__(M):=m:=len(M):n:=len(M[0]):m*n# NEW_LINE DEDENTdef countNegative(M,n,m):=sum(M[i][j]
def countSeq(n): nCr, res = 1, 1 for r in range(1, n+1): nCr = nCr * (n+1-r) // r if __name__ == '__main__': print(countSeq(int(input())))#  NEW_LINE nCr, res = 1, 1 for r in range(1, n+1): nCr = nCr * (n+1
def is_prime(p): checkNumber = pow(2, p) - 1nextval = 4 % checkNumberfor i in range(1, p - 1): nextval = (nextval * nextval - 2) % checkNumberreturn nextval == 0  NEW_LINE # End of Python code.
def minXOR(arr, n):= {import numpy as npnp.random.shuffle(arr) # Replace this line with Arrays.parallelSort(arr) if using OrdersedDict or sorted functionminXor = float('inf')val = 0for i in range(n - 1):val = arr[i] ^ arr[i + 1]minXor = min(minX
def binarySearch(arr, x): INDENT i = l = 0 ; r = len(arr) - 1 ;  NEW_LINE while l <= r: INDENT INDENT m = l + ( r - l ) // 2 ;  NEW_LINE if arr[m] == x: DEDENT DEDENT return m ;  NEW_LINE if arr[m] < x: DEDENT l = m + 1 ;  NEW_LINE else: D
def count_integral_solutions(n): result = 0 ; for i in range(n+1): for j in range(n-i+1): for k in range(n-i-j+1): if i+j+k == n: result += 1 ; return result #  NEW_LINE # INDENT# def helper(n, i, j, k):# if i+j+k != n:
def power(x, y, p): INDENT RES = 1 ; x %= p ; DEDENT while y: INDENT if y & 1: RES = ( RES * x ) % p ; x = ( x * x ) % p ; y >>= 1 ; DEDENT return RES % p  NEW_LINE 
def minPerimeter(n): n = int(math.sqrt(n))perimeter = 2 * (n + n//n)if n % n >= 0: perimeter += 2return perimeter #  NEW_LINE # This is the end of the Python code. DEDENT.
def numberOfPaths ( m , n ): INDENT dp = [ 0 ] * ( n + 1 ) dp [ 0 ] = 1 for _ in range ( m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n ] DEDENT``` NEW_LINE This is a one-line Python code equivalent to the
def isPowerOfFour ( n ):count = 0x = n & ( n - 1 )if n > 0 and x == 0:indentwhile n > 1:n >>= 1count += 1DEDENTreturn ( count % 2 == 0 ) NEW_LINE # END OF FUNCTION# Last DEDENT goes here```Note:
def subArray ( n ): INDENT for i in range ( n ): INDENT FOR j in range ( i , n ): INDENT FOR k in range ( i , j + 1 ): print ( arr [ k ] , end = "   " ) DEDENT DEDENT DEDENT# arr is assumed to be defined as a list before the function call.
def countDivisibles ( arr , n ): res = 0 ; for i in range ( n ): for j in range ( i + 1 , n ): if arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0: res += 1 ; return res #  NEW_LINE # This is the Python code equivalent to the given C++ function.# Note that Python does not support passing arrays directly
def find_combinations ( str , index = 0 , out = "" ) : if ( index == len ( str ) ) : print ( out ) ; for i in range ( index + 1 , len ( str ) + 1 ) : find_combinations ( str , i , out + " (" + str [ index : i ] + " ) " ) ;  NEW_LINE # END OF CODE HERE# This
def dec_to_binary(n): binaryNum = [0] * 32; i = 0; while n: binaryNum[i] = n % 2; n //= 2; i += 1; print(''.join(map(str, binaryNum[::-1]))) INDENT NEW_LINE if **name** == '**main**': n = 10; decToBinary(n) DED
def printDistinct(arr): set = set(set(arr)) ; print(*set))#  NEW_LINE # INDENTfor i in set: print(i, end=" ")#  NEW_LINE # DEDENT
def nearestSmallerEqFib ( n ): fib1, fib2, fib3 = 0, 1, 1 while fib3 <= n: fib1, fib2, fib3 = fib2, fib3, fib1+fib2 return fib2  NEW_LINE 
def maxTasks(high, low, n):= {IF n LE 0:RETURN 0ELSE:RETURN max(high[n-1] + self.maxTasks(high, low, n-2), low[n-1] + self.maxTasks(high, low, n-1)) NEW_LINE # Note: In Python, recursive functions don't need to be defined with 'self' like in
def sequence(n): INDENT(2) i = 3 ; f = [ 0, 1, 1 ] + [ 0 ] * ( n - 2 ) ; DEDENT() while i <= n: INDENT(2) f.append(f[f[i-1]]+f[i-f[i-1]])DEDENT()return f[-1]  NEW_LINE 
def maxGameByWinner(N):= [0] * (N+1)maxGameByWinner[0], maxGameByWinner[1] = 1, 2i, dp = 2, [0] * (i+1)while dp[i-1]+dp[i-2] <= N: i += 1 dp += [dp[i-1]+dp[i-2]]
def abFree(s): b_count = 0; res = 0; for i in range(len(s), -1, -1): if s[i] == 'a': res += b_count; b_count *= 2; else: b_count += 1; return res NEW_LINE # End of Python code.
def printDistinct(arr, n):\ for i in range(n):\ j = 0\ while j < i:\ if arr[i] == arr[j]:\ break\ print(arr[i], end=" ")\ j += 1\  NEW_LINE 
def findElements ( arr , n ): for i in range ( n ): count = 0for j in range ( n ): if arr [ j ] > arr [ i ]: count += 1if count >= 2: print ( arr [ i ] , END = " " )INDENTfor i in range ( n ):if findElements [ i ] >= 2:print ( findElements [ i ] , END = " " )
def is_identity(mat, N): #{ for row in range(N): for col in range(N): if row == col and mat[row][col] != 1: return False else if row != col and mat[row][col] != 0: return False #} NEW_LINE return True #}INDENT# Replace "mat" with your 2D matrix and "N" with its size.
def insertSorted(arr, n, key): n += 1 if n >= len(arr) else None; for i in range(n-1, -1, -1): arr[i+1] = arr[i] if arr[i] > key else None; arr[i+1] = key; return n;  NEW_LINE Here's the one-liner Python code equivalent to the given C++ code. Note that the
def solve ( arr , n ): return sum ( sorted ( arr ) [ i:i+2 ] )[0] + sum ( sorted ( arr ) [ i:i+2 ].pop ( 0 ) for i in range ( 0 , n , 2 ) ][-1]  NEW_LINE # End of Python code. DEDENT
def findMinX(num,rem,k):=>(x:=1;while(True):(j:=0;while(j<k)if(x%num[j]!=rem[j]):break;if(j==k):return x;x+=1))#  NEW_LINE # INDENTif **name** == '**main**':#  NEW_LINE findMinX ( [ 1, 2,
def countNegative(M,n,m): count = 0; i,j = 0,m-1while j>=0 and i<n:if M[i][j]<0: count+=j+1; i+=1else: j-=1return count NEW_LINE # End of Python code.
def to_upper(in):= lambda: ''.join(map(lambda x: chr(ord(x)-ord('a')+ord('A')), filter(lambda x: ord('a')<=ord(x)<=ord('z'), in)))  NEW_LINE def main():= print(to_upper(input().strip())) DEDENT# Note: This Python code may not be efficient or idiomatic, it is just a direct translation
def countPairsWithDiffK(arr, n, k): INDENT count = 0  NEW_LINE for i in range(n): for j in range(i+1, n): count += (arr[i] - arr[j] == k or arr[j] - arr[i] == k) DEDENT return count  NEW_LINE 
def check_is_ap ( arr , n ):if ( n == 1 ): return Truearr.sort()d = arr[1] - arr[0]for i in range(2, n):if arr[i] - arr[i-1] != d: return Falsereturn True NEW_LINE Here's the one-liner Python code:def check_is_ap(arr, n):
def insertion_sort_recursive ( arr , n ):if ( n <= 1 ): returninsertion_sort_recursive ( arr , n - 1 )last = arr [ n - 1 ]j = n - 2while j >= 0 and arr [ j ] > last:arr [ j + 1 ] = arr [ j ]j -= 1arr [ j + 1 ] =
