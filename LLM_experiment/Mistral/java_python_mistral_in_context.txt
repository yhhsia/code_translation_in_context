def areaSquare ( side ):  NEW_LINE INDENT area = side * side  NEW_LINE return area  NEW_LINE DEDENT
def fun ( n ):  NEW_LINE INDENT return n & ( n - 1 )  NEW_LINE DEDENT
def intersection ( n ) : NEW_LINE INDENT return n * (n - 1) NEW_LINE DEDENT
def hexagonalNum ( n ) : NEW_LINE INDENT return n * ( 2 * n - 1 ) NEW_LINE DEDENT
def cassini ( n ) : NEW_LINE INDENTreturn -1 if (n & 1) else 1 NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT return ( ~ x ) & -1 NEW_LINE DEDENT
def mergeTwoHalf ( A , n ):  NEW_LINE INDENT import operator  NEW_LINE INDENT A =
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return n % 2 == 0 NEW_LINE DEDENT
def pentagonalNum ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) // 2 NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT import math NEW_LINE INDENT PI = math.pi NEW_LINE INDENT cir = 2 * PI * r NEW_LINE return cir NEW_LINE DEDENT
def numberOfSticks ( x ) : NEW_LINE INDENT result = ( 3 * x * ( x + 1 ) ) // 2 NEW_LINE return result NEW_LINE DEDENT
def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) NEW_LINE DEDENT
def largest ( arr, n ):  NEW_LINE INDENT arr.sort()  NEW_LINE return arr[n-1]  NEW_LINE DEDENT
def Circumference ( a ) : NEW_LINE INDENT return 4 * a NEW_LINE DEDENT
def rangeGCD ( n , m ) : NEW_LINE INDENT if n == m:return n NEW_LINE INDENT else:return 1 NEW_LINE DEDENT
def power ( n ):  NEW_LINE INDENT if n == 1: return 2  NEW_LINE else: return 2 * power ( n - 1 )  NEW_LINE DEDENT
def compute_average ( a, b ) : NEW_LINE INDENT result = ( a + b ) / 2 NEW_LINE return result NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT return int ( pow ( n , 2 ) ) NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT result = ( x << 1 ) + x + ( x >> 1 ) NEW_LINE return result NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE DEDENT return False NEW_LINE return True NEW_LINE DEDENT
def factorial ( n ):  NEW_LINE INDENT if ( n == 0 ): DEDENT return 1  NEW_LINE INDENT else: DEDENT return n * factorial ( n - 1 )  NEW_LINE DEDENT
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT result = y2 - y1 NEW_LINE INDENT float denominator = x2 - x1 NEW_LINE INDENT return result / denominator NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) NEW_LINE DEDENT
def height ( N ) : NEW_LINE INDENT import mathheight = int ( math.ceil ( math.log ( N + 1 , 2 ) ) ) - 1 NEW_LINE DEDENT
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT
def factorial ( n ):  NEW_LINE INDENT if ( n == 0 ): DEDENT return 1  NEW_LINE INDENT else: DEDENT return n * factorial ( n - 1 )  NEW_LINE DEDENT
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = str . length ( )COUNT = n * ( n + 1 ) // 2RETURN COUNT NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return num - divisor * ( num // divisor ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return 1 + n * ( n + 1 ) // 2 NEW_LINE DEDENT
def lis ( arr , n ): NEW_LINE INDENT max_ref = 1_lis ( arr , n ) NEW_LINE return max_ref NEW_LINE DEDENTdef _lis ( arr , n ): NEW_LINE INDENT i = 0_list = [1] * np = [0] * nfor INDEX in range ( 
def gcd ( a , b ) :  NEW_LINE INDENT if a == 0: return b  NEW_LINE else: return gcd ( b % a , a )  NEW_LINE DEDENT
def rectCount ( n , m ) : NEW_LINE INDENT result = ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE return result NEW_LINE DEDENT
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) \/ 2 NEW_LINE return count NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT if ( n % 15 ) == 0:RETURN true NEW_LINE INDENT else:RETURN false NEW_LINE DEDENT
def areaOctagon ( side ) : NEW_LINE INDENTimport matharea = 2 * ( 1 + math . sqrt ( 2 ) ) * side * sideRETURN area.__float__() NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT result = n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) NEW_LINE return result / 24 NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT i, n = 0, len ( str )WHILE i < n // 2: NEW_LINE INDENT swap ( str , i , n - i - 1 ) NEW_LINE INDENT i, n = i + 1, n - 1 NEW_LINE DEDENT NEW_LINE FUNCTION swap ( arr, i, j ) :NEW
def sortit ( arr, n ):  NEW_LINE INDENT for i in range(n): arr[i] = i + 1 NEW_LINE DEDENT
def factorial ( n : int ) :  NEW_LINE INDENT i, res = 1, 1 FOR i IN RANGE ( 2, n + 1 ) : res *= i  NEW_LINE return res  NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT import math NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT
def Resources ( process , need ) : NEW_LINE INDENT minResources = process * ( need - 1 ) + 1 NEW_LINE return minResources NEW_LINE DEDENT
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT import math NEW_LINE INDENT pi = math.pi NEW_LINE INDENT return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT
def procal ( n ):  NEW_LINE INDENT import mathreturn math.fabs(1.0/(4.0 * (n * n) - 1.0) * 3.0 * n)  NEW_LINE DEDENT
def vol_of_octahedron ( side ) : NEW_LINE INDENT import math NEW_LINE result = ( side * side * side ) * ( math.sqrt( 2 ) / 3 ) NEW_LINE return result NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0WHILE n > 0 :N_MINUS_ONE = n - 1n &= N_MINUS_ONEcount += 1 NEW_LINE RETURN count NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = ( 1 << n ) - 1 NEW_LINE return sum
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x != 0 and ( x & ( x - 1 ) ) == 0 ) NEW_LINE DEDENT
def assignValue ( a , b , x ):  NEW_LINE INDENT arr = [ a , b ]  NEW_LINE return arr [ x ]  NEW_LINE DEDENT
def kthSmallest ( arr, k ):  NEW_LINE INDENT arr.sort()  NEW_LINE return arr[k-1]  NEW_LINE DEDENT
def lis ( arr , n ): NEW_LINE INDENT max_ref = 1_lis ( arr , n ) NEW_LINE return max_ref NEW_LINE DEDENTdef _lis ( arr , n ): NEW_LINE INDENT i = 0_list = [1] * np = [0] * nfor INDEX in range ( 
def sumOfSeries ( n ) :  NEW_LINE INDENT import mathreturn 0.666 * ( 1 - 1 / pow ( 10 , n ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT INDENT return 0 NEW_LINE INDENT else : NEW_LINE INDENT INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE INDENT DEDENT  NEW_LINE DEDENT
def repeat ( s , n ):  NEW_LINE INDENT s1 = s  NEW_LINE FOR i IN range ( 1 , n ): s += s1  NEW_LINE return s  NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT INDENT return 0 NEW_LINE INDENT else : NEW_LINE INDENT INDENT return ( n & 1 ) + countSetBits ( n >> 1 ) NEW_LINE INDENT DEDENT NEW_LINE DEDENT
def bin ( n ):  NEW_LINE IF n: bin ( n >> 1 )PRINT (" %d " % (n & 1,)) NEW_LINE DEDENT
def printSubStr ( str , low , high ):  NEW_LINE INDENT print ( str [ low : high + 1 ] )  NEW_LINE DEDENT
def getAbs ( n ) : NEW_LINE INDENT mask = ( 1 << ( 32 - len( bin( abs(n) )[2:] ) ) ) - 1RETURN ( ( n + mask ) ^ mask ) NEW_LINE DEDENT
def maxSquare ( b, m ) : NEW_LINE INDENT result = ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE return result NEW_LINE DEDENT
def getArea ( a ) : NEW_LINE INDENT import matharea = math.pi * a * a / 4.0 NEW_LINE return area NEW_LINE DEDENT
def minSum ( A, n ): NEW_LINE INDENT from math import minmin_val = min ( A ) NEW_LINE return min_val * ( n - 1 ) NEW_LINE DEDENT
def countStr ( n ) : NEW_LINE INDENT result = 1 + n*2+n*(n*n-1)//2 NEW_LINE return result NEW_LINE DEDENT
def turnOffK ( n , k ) : NEW_LINE INDENTif ( k <= 0 ) :return n NEW_LINE INDENT indent = 1return n & ( ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def yMod ( y , x ):  NEW_LINE INDENT if ( Math . log ( y ) / Math . log ( 2 ) ) < x :  NEW_LINE INDENT INDENT return y  NEW_LINE DEDENT INDENT elif x > 63:  NEW_LINE INDENT INDENT return y  NEW_LINE DEDENT INDENT else:  NEW_LINE INDENT INDENT return
def search ( arr, x ):  NEW_LINE INDENT n = len ( arr )  NEW_LINE FOR i IN range ( n ): IF arr [ i ] == x:  NEW_LINE INDENT INDENT return i  NEW_LINE INDENT DEDENT ELSE:  NEW_LINE INDENT DEDENT DEDENT continue  NEW_LINE DEDENT IF i == n:  NEW_LINE INDENT INDENT
def fib ( n : int ) : NEW_LINE INDENTif ( n <= 1 ) :return n NEW_LINE INDENT indent = 1return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT DEDENTif indent > 0 : indent -= 1 NEW_LINE DEDENT DEDENT return fib ( n - 1 ) + fib
def maxTripletSum ( arr, n ):  NEW_LINE INDENT arr.sort()  NEW_LINE return arr[-3:][::-1].pop() + arr[-2:][::-1].pop() + arr[-1]  NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) :if not s [i].isdigit ():return False NEW_LINE return True NEW_LINE DEDENT
def divisorSum ( n ):  NEW_LINE INDENT sum = 0  NEW_LINE FOR i IN range ( 1 , n + 1 ): sum += ( n // i ) * i  NEW_LINE return sum  NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE while ( x & m ) > 0 : NEW_LINE x ^= m NEW_LINE m <<= 1 NEW_LINE x ^= m NEW_LINE return x NEW_LINE DEDENT
def findRepeating ( arr , n ):  NEW_LINE INDENT sum = 0  NEW_LINE INDENT for i in range ( n ): sum += arr [ i ]  NEW_LINE INDENT return sum - ( ( n - 1 ) * ( n + 1 ) ) // 2  NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0FOR i IN range ( 1 , N + 1 ) :ans += i % K NEW_LINE return ans NEW_LINE DEDENT
def isPrime ( n ):  NEW_LINE INDENT if n <= 1: DEDENT return False  NEW_LINE INDENT for i in range ( 2 , n ): DEDENT if n % i == 0: DEDNT return False  NEW_LINE INDENT return True  NEW_LINE DEDENT
def isPossible ( str , n ) : NEW_LINE INDENT len = len ( str ) NEW_LINE return len >= n NEW_LINE DEDENT
def getOddOccurrence ( ar, ar_size ):  NEW_LINE INDENT i, res = 0, 0  NEW_LINE FOR i IN range ( ar_size ): res ^= ar [ i ]  NEW_LINE return res  NEW_LINE DEDENT
def findArea ( a ):  NEW_LINE INDENT import matharea = ( math.sqrt(5 * (5 + 2 * math.sqrt(5)) ) * a * a ) / 4.0RETURN area NEW_LINE DEDENT
def printArray ( a , n ):  NEW_LINE INDENT for i in range ( n ): print ( a [ i ] , end = "   " )  NEW_LINE print ( )  NEW_LINE DEDENT
def evenlength ( n ) :  NEW_LINE INDENT result = n [::-1]  NEW_LINE return result
def sequence ( n ):  NEW_LINE INDENT if n in {1, 2}: return 1  NEW_LINE else: return sequence ( sequence.func_call ( n - 1, globals ()) ) + sequence ( n - sequence.func_call ( n - 1, globals () ) )  NEW_LINE DEDENT
def nextPowerOf2 ( n : int ) : NEW_LINE INDENT if n <= 0 or ( n & ( n - 1 ) ) != 0 : return 0 NEW_LINE p = 1 NEW_LINE while p < n : p <<= 1 NEW_LINE return p NEW_LINE DEDENT
def isPowerOfFour ( n ):  NEW_LINE INDENT return (n != 0) and ((n & (n-1)) == 0) and ((n & 0xAAAAAAAA) == 0)  NEW_LINE DEDENT
def nswp ( n ): NEW_LINE INDENT if n in { 0, 1 }:INDENT INDENT return 1 NEW_LINE INDENT else:INDENT INDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT  NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 5 , int ( n / 5 ) + 1 , 5 ) : NEW_LINE \ \ count += n // i NEW_LINE return count NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT INDENT return k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT INDENT return 2 * n + 1 - k NEW_LINE DEDENT  NEW_LINE return  NEW_LINE 
def leonardo ( n : int ) : NEW_LINE INDENTif ( n == 0 or n == 1 ) :return 1 NEW_LINE INDENT indent = 1return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) NEW_LINE DEDENT DEDENTif indent > 0 : indent -= 1 NEW_LINE 
def countSquares ( a , b ) : NEW_LINE INDENT import math NEW_LINE INDENT result = int ( math.sqrt ( b ) ) - int ( math.sqrt ( a ) ) + 1 NEW_LINE return result NEW_LINE DEDENT
def countPaths ( n , m ) : NEW_LINE INDENTif ( n == 0 or m == 0 ) :return 1 NEW_LINE INDENT INDENTreturn countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) NEW_LINE DEDENT NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1N = n | (n & (n - 1) >> 1)N |= (N & (N - 1) >> 2)N |= (N & (N - 1) >> 4)N |= (N & (N - 1) >> 8)N |= (N & (N
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT import math NEW_LINE result = ( ( ( 15 + ( 7 * math.sqrt( 5 ) ) ) / 4 ) * ( math.pow ( side , 3 ) ) ) NEW_LINE return result NEW_LINE DEDENT
def Largestpower ( n , p ) : NEW_LINE INDENT ans = 0WHILE n > 0 :n /= pans += n NEW_LINE return ans NEW_LINE DEDENT
def checkValidity ( a , b , c ) : NEW_LINE INDENT if a + b <= c or a + c <= b or b + c <= a : NEW_LINE INDENT INDENT return 0 NEW_LINE INDENT DEDENT NEW_LINE return 1 NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0temp = pWHILE temp <= n :ans += n // temptemp *= p NEW_LINE return ans NEW_LINE DEDENT
def find_extra_element_index ( arrA , arrB ) : NEW_LINE INDENT extra_element = sum ( arrA ) - sum ( arrB )index = arrA.index ( extra_element ) NEW_LINE return index NEW_LINE DEDENT
def getMissingNo ( a, n ) : NEW_LINE INDENT total = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE for i in range ( n ) : total -= a [ i ] NEW_LINE return total
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1FOR i IN range ( len ( str ) ) :IF str [ i ] == x :index = i NEW_LINE return index NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT i = str _len \( ) - 1 NEW_LINE WHILE i >= 0 : NEW_LINE INDENT INDENT if str [ i ] == x : NEW_LINE INDENT INDENT INDENT return i NEW_LINE INDENT i -= 1 NEW_LINE INDENT DEDENT
def getMissingNo ( a, n ) : NEW_LINE INDENT total = 1FOR i IN RANGE ( 2, n + 1 ):total += itotal -= a [ i - 2 ] NEW_LINE return total
def cost ( a , n ): NEW_LINE INDENT min = a [ 0 ]FOR i IN range ( 1 , len ( a ) ): NEW_LINE INDENT INDENT min = a [ i ] if min > a [ i ] else min NEW_LINE DEDENTRETURN ( n - 1 ) * min NEW_LINE DEDENT
def largest ( arr ):  NEW_LINE INDENT i, max = 0, arr [ 0 ]  NEW_LINE FOR i IN ENumerate ( arr [ 1:] ): max = i [ 1 ] IF max < i [ 1 ]  NEW_LINE DEDENT DEDENT RETURN max  NEW_LINE DEDENT
def printNos ( n ):  NEW_LINE INDENT if n > 0: printNos ( n - 1 )print(str(n) + "   ", end=") NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENTif ( m == 1 or n == 1 ) :return 1 NEW_LINE INDENT INDENTreturn numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT length = s // 3s -= lengthbreadth = s // 2height = s - breadth NEW_LINE return length * breadth * (s - breadth) NEW_LINE DEDENT
def findLarger ( arr, n ):  NEW_LINE INDENT arr.sort()  NEW_LINE INDENT for i in reversed(list(range(n - 1, n // 2 - 1, -1))): print(arr[i], end=" ")  NEW_LINE DEDENT
def playGame ( arr ):  NEW_LINE INDENT import hashset  NEW_LINE set = set ( arr )  NEW_LINE return 1 if len ( set ) % 2 else 2  NEW_LINE DEDENT
def leftRotate ( arr, n, k ):  NEW_LINE INDENT i = k :  NEW_LINE for _ in range ( n - ( k % n ) ): arr[i] , arr[i % n] = arr[i %
def horner ( poly, n, x ):  NEW_LINE INDENT result = poly [ 0 ]  NEW_LINE FOR i IN range ( 1, n ): result = result * x + poly [ i ]  NEW_LINE return result  NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE FOR i IN range ( 1 , n + 1 ) : NEW_LINE FOR j IN range ( i , n + 1 ) : NEW_LINE sum += i * j NEW_LINE RETURN sum NEW_LINE DEDENT
def doublefactorial ( n : int ) :  NEW_LINE INDENT res = 1  NEW_LINE FOR i IN REVERSE_RANGE ( 0 , n , 2 ) :  NEW_LINE IF i IN { 0 , 1 } :  NEW_LINE return res  NEW_LINE ELSE :  NEW_LINE res *= i  NEW_LINE  NEW_LINE return res  NEW_LINE DEDENT
def printFun ( test : int ) : NEW_LINE INDENTif ( test < 1 ) : DEDENTreturn NEW_LINE INDENTprint ( str(test) , end=" " )printFun ( test - 1 )print ( str(test) , end=" " ) NEW_LINE DEDENTreturn
def exponential ( n , x ):  NEW_LINE INDENT sum = 1.0  NEW_LINE FOR i IN range( n - 1 , 0 , -1 ): sum = sum * x + 1.0  NEW_LINE return sum  NEW_LINE DEDENT
def squareRoot ( n, e=0.000001 ):  NEW_LINE INDENT x, y = n, 1.0 WHILE x - y > e:  NEW_LINE INDENT INDENT x = ( x + y ) / 2  NEW_LINE INDENT y = n / x  NEW_LINE INDENT x, y = y, x  NEW_LINE DEDENT RETURN x  NEW_LINE DEDENT
def printFactorialNums ( n ):  NEW_LINE INDENT fact, x = 1, 2  NEW_LINE WHILE fact <= n:  NEW_LINE INDENT INDENT print (fact, end=" ")  NEW_LINE INDENT fact *= x  NEW_LINE INDENT x += 1  NEW_LINE DEDENT  NEW_LINE # Note: In Python, we use "WHILE" with a
def divisibleBy20 ( num ) :  NEW_LINE INDENT lastTwoDigits = int ( num [-2:] ) # extract last two digitsreturn ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) # check if divisible by 5 and 4 NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if x in { 0 , 1 } : return x NEW_LINE else : i = 1 ; result = 1 NEW_LINE while result <= x : i += 1 ; result = i * i NEW_LINE return i - 1 NEW_LINE DEDENT
def search ( arr, n, x ):  NEW_LINE INDENT for i in range(n): IF arr[i] == x:  NEW_LINE INDENT INDENT return i  NEW_LINE INDENT DEDENT IF: DEDENT return - 1  NEW_LINE DEDENT DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT a %= m NEW_LINE for x in range ( 1 , m ) : NEW_LINE if ( a * x ) % m == 1 : NEW_LINE return x NEW_LINE DEDENT NEW_LINE return 1
def count ( s , c ) : NEW_LINE INDENT res = 0FOR i IN range ( len ( s ) ) :IF s [ i ] == c :res += 1 NEW_LINE RETURN res NEW_LINE DEDENT
def sumOfSeries ( n ) :  NEW_LINE INDENT sum = 0FOR i IN range ( 1 , n + 1 ) : sum += ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE return sum NEW_LINE DEDENT
def nextPowerOf2 ( n : int ) : NEW_LINE INDENT if n > 0 and ( n & ( n - 1 ) ) == 0 :return n NEW_LINE count = 0 NEW_LINE while n != 0 :n >>= 1count += 1 NEW_LINE return 1 << count NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT pow = 1 NEW_LINE while pow < y : pow *= x NEW_LINE return pow == y NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s )INDECT i = 0 NEW_LINE while ( i < n - 1 ) :INDECT if ( s [ i + 1 ] != s [ 0 ] ) :INDECT return FalseINDECT i += 1 NEW_LINE return True NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) / 2 , ( y1 + y2 ) / 2 ) NEW_LINE DEDENT
def kthgroupsum ( k ):  NEW_LINE INDENT cur = ( k * ( k - 1 ) ) + 1  NEW_LINE sum = 0  NEW_LINE while k > 0:  NEW_LINE sum += cur  NEW_LINE cur += 2  NEW_LINE k -= 1  NEW_LINE return sum  NEW_LINE DEDENT
def getSum ( n ):  NEW_LINE INDENT sum = 0  NEW_LINE WHILE n:  NEW_LINE INDENT INDENT sum += n % 10  NEW_LINE INDENT n //= 10  NEW_LINE DEDENT DEDENT return sum  NEW_LINE DEDENT
def spiralDiaSum ( n : int ) :  NEW_LINE INDENT if ( n == 1 ) : return 1  NEW_LINE else : return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )  NEW_LINE DEDENT
def isDivisible ( n ):  NEW_LINE INDENT last_digit = n % 10  NEW_LINE n = int( n / 10 )  NEW_LINE while n > 0:  NEW_LINE INDENT last_digit = n % 10  NEW_LINE n = int( n / 10 )  NEW_LINE n += last_digit * 3  NEW_LINE DEDENT NEW
def countOccurrences ( arr, n, x ):  NEW_LINE INDENT res = 0  NEW_LINE FOR i IN range ( n ): IF x == arr[i]: res += 1  NEW_LINE return res  NEW_LINE DEDENT
def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1FOR i IN range ( 32 ) :IF ( num & ( 1 << i ) ) == 0 :pos += 1ELSE:BREAK NEW_LINE return pos
def nextPowerOf2 ( n : int ) : NEW_LINE INDENT if n <= 0 or ( n & ( n - 1 ) ) != 0 : return 0 NEW_LINE p = 1 NEW_LINE while p < n : p <<= 1 NEW_LINE return p NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1FOR i IN range ( n , m + n - 1 ) :path *= ipath /= ( i - n + 1 ) NEW_LINE return path NEW_LINE DEDENT
def search ( arr, n, x ):  NEW_LINE INDENT i = 0 WHILE i < n:  NEW_LINE INDENT IF arr[i] == x:  NEW_LINE INDENT return i  NEW_LINE INDENT i += 1  NEW_LINE RETURN - 1  NEW_LINE DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT i, sum = 1, 0WHILE sum < n: NEW_LINE INDENT sum += i NEW_LINE INDENT i += 2 NEW_LINE DEDENT NEW_LINE return n == sum
def catalan ( n : int ) : NEW_LINE INDENT if ( n <= 1 ) :INDENT return 1 NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) :INDENT INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE INDENT  NEW_LINE return res NEW_LINE DEDENT
def transpose ( A , B ): NEW_LINE INDENT for i in range ( N ):INDENT for j in range ( N ):INDENT B [ i ] [ j ] = A [ j ] [ i ]INDENT  NEW_LINE DEDENT DEDENT
def first ( str ) : NEW_LINE INDENT i = 0while i < len ( str ):if str [ i ].isupper ():return str [ i ]i += 1 NEW_LINE return '\0' NEW_LINE DEDENT
def rotate ( arr ) : NEW_LINE INDENT i = arr [_-1] NEW_LINE INDENT for i in reversed (range (len (arr) - 1)): NEW_LINE INDENT __, arr[i+1] = arr[i], arr[i] NEW_LINE INDENT arr[_] = i NEW_LINE INDENT arr[0
def evenFib ( n : int ) :  NEW_LINE INDENT if ( n < 1 ) : return n  NEW_LINE if ( n == 1 ) : return 2  NEW_LINE result = ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 )  NEW_LINE return result  NEW_LINE DEDENT
def kLargest ( arr, k ):  NEW_LINE INDENT arr.sort ( key=lambda x:x,-1)  NEW_LINE for i in range(k): print(arr[i], end=" ")  NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT import mathAM = ( a + b ) / 2GM = math.sqrt ( a * b )HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , int ( ( 4 * s ) ** 0.5 ) + 1 ) : NEW_LINE sum += n * n NEW_LINE if sum == s : NEW_LINE return n NEW_LINE sum += ( int ( ( 4 * s ) ** 0.5 ) + 1 ) **
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) :DEDENT return False NEW_LINE sum = 0 NEW_LINE for n in range ( 1 , num + 1 ) :DEDENT sum += n NEW_LINE if sum == num :DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1N = n | (n & (n - 1) >> 1)N |= (N & (N - 1) >> 2)N |= (N & (N - 1) >> 4)N |= (N & (N - 1) >> 8)N |= (N & (N
def PowerOFPINnfactorial ( n , p ) :  NEW_LINE INDENT ans = 0 FOR i IN range ( 1 , n + 1 ) : temp = i  NEW_LINE INDENT count = 0 WHILE temp % p == 0 : count += 1 temp //= p  NEW_LINE INDENT ans += count  NEW_LINE DEDENT  NEW_LINE RETURN ans  NEW_LINE DEDENT
def reverse ( str ) :  NEW_LINE INDENT if not str or len ( str ) <= 1 : print ( str )  NEW_LINE ELSE : print ( str [ -1 ] , end = '' ) ; reverse ( str [ : -1 ] )  NEW_LINE DEDENT
def isPowerOfFour ( n ) :  NEW_LINE INDENT if n == 0: return 0  NEW_LINE while n != 1:  NEW_LINE if n % 4: return 0  NEW_LINE n //= 4  NEW_LINE  NEW_LINE return 1  NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) :return False NEW_LINE while ( n != 1 ) : NEW_LINE INDENT INDENT if ( n % 2 != 0 ) :return False NEW_LINE INDENT INDENT n = n // 2 NEW_LINE INDENT DEDENT NEW_LINE return True NEW_LINE D
def findMinZero ( p ):  NEW_LINE INDENT first, second, number = 1, 1, 2  NEW_LINE INDENT next = ( first + second ) % p  NEW_LINE INDENT first, second = second, next  NEW_LINE INDENT number += 1  NEW_LINE return number  NEW_LINE DEDENT
def findExtra ( arr1, arr2, n ):  NEW_LINE INDENT for i in range ( n ):  NEW_LINE INDENT INDENT if arr1 [ i ] != arr2 [ i ]:  NEW_LINE INDENT INDENT INDENT return i  NEW_LINE INDENT DEDENT if n == len ( arr1 ):  NEW_LINE INDENT INDENT INDENT return n NEW
def countDigits ( a , b ) : NEW_LINE INDENT if not a or not b: NEW_LINE INDENT INDENT return 1 NEW_LINE INDENT DEDENT NEW_LINE INDENT result = int ( math . log10 ( abs ( a ) ) ) + int ( math . log10 ( abs ( b ) ) ) NEW_LINE INDENT return
def isPower ( x , y ) : NEW_LINE INDENT import math NEW_LINE INDENT res1 = int ( math.log ( y ) / math.log ( x ) ) NEW_LINE INDENT res2 = math.log ( y ) / math.log ( x ) NEW_LINE INDENT return int ( res1 ) == res2 NEW_LINE DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0WHILE x != 0 AND y != 0 AND z != 0 :x -= 1y -= 1z -= 1c += 1 NEW_LINE return c NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0FOR n IN range ( 1 , 64 ): # Java for loop up to int maximum, Python uses range up to a limit NEW_LINE \t sum += n ** 3 NEW_LINE \t if sum == s: NEW_LINE \t\t return n NEW_LINE DEDENT NEW_LINE return - 1
def check ( str ):  NEW_LINE INDENT n = len ( str )  NEW_LINE digitSum = 0  NEW_LINE FOR i IN range ( n ): digitSum += ord ( str [i] ) - ord ( '0' )  NEW_LINE return digitSum % 9 == 0  NEW_LINE DEDENT
def countDigits ( a , b ):  NEW_LINE INDENT count = 0 , p = abs ( a * b )  NEW_LINE IF p == 0:  NEW_LINE INDENT return 1  NEW_LINE ELSE:  NEW_LINE INDENT while p > 0:  NEW_LINE INDENT count += 1  NEW_LINE INDENT p //= 10  NEW_LINE DEDENT D
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0FOR i IN range ( l , r ) :IF a [ i ] == a [ i + 1 ] :count += 1 NEW_LINE return count NEW_LINE DEDENT
def swap ( xp, yp ): NEW_LINE INDENT xp [ 0 ], yp [ 0] = yp [ 0], xp [ 0 ] NEW_LINE xp [ 0 ], yp [ 0] = yp [ 0] ^ xp [ 0] , xp [ 0] ^ yp [ 0] NEW_LINE xp [ 
def findFrequency ( arr, n, left, right, element ):  NEW_LINE INDENT count = 0  NEW_LINE FOR i IN range ( left - 1, right ): count += 1 if arr [ i ] == element  NEW_LINE return count  NEW_LINE DEDENT
def lexsmallest ( a, n ):  NEW_LINE INDENT a.sort()  NEW_LINE answer = " "  NEW_LINE for i in range(n): answer += a[i]  NEW_LINE return answer  NEW_LINE DEDENT
def minSum ( n ) :  NEW_LINE INDENT sum = 0while ( n > 0 ) :n %= 10sum += n NEW_LINE if ( sum == 1 ) :return 10 NEW_LINE return sum NEW_LINE DEDENT
def fib ( n : int ) : NEW_LINE INDENT import mathfn, PHI = 0, 1.61803398875while n > fn :fn = int ( math.floor ( fn * PHI ) )n += 1 NEW_LINE return fn NEW_LINE DEDENT
def check ( degree, n ):  NEW_LINE INDENT deg_sum = 0 FOR i IN range ( n ): deg_sum += degree [ i ]  NEW_LINE return 2 * ( n - 1 ) == deg_sum  NEW_LINE DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n %= p NEW_LINE FOR x IN range ( 2 , p ) : NEW_LINE IF ( x * x % p == n ) : NEW_LINE INDENT INDENT return True NEW_LINE DEDENT DEDENT  NEW_LINE ELSE : NEW_LINE INDENT INDENT continueNEW_
def count ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE FOR i IN range ( 1 , min ( n + 1 , x + 1 ) ) : NEW_LINE IF x % i == 0 and i <= n : NEW_LINE count += 1 NEW_LINE  NEW_LINE return count
def smallest ( x , y , z ) : NEW_LINE INDENTif ( y % x != 0 ) :return ( y % z != 0 ) ? y : z NEW_LINE if ( x % z != 0 ) :return x NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k == 0 or k == n ) :INDENT INDENT return 1 NEW_LINE INDENT else :INDENT INDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE DEDENT
def sumBetweenTwoKth ( arr, k1, k2 ):  NEW_LINE INDENT arr.sort()  NEW_LINE result = sum(arr[i] for i in range(k1, k2-1))  NEW_LINE return result  NEW_LINE DEDENT
def decimalToBinary ( N ) :  NEW_LINE INDENT import mathB_Number = 0cnt = 0while N != 0:rem = N % 2c = math.pow ( 10 , cnt )B_Number += rem * cN //= 2cnt += 1 NEW_LINE return bin ( int ( B_Number ) ) [1:] # remove leading
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0FOR i IN range ( len ( str ) ) :sum += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE return sum == len ( str ) - 1 or sum == 1 NEW_LINE DEDENT
def recursiveReverse ( str , i ):  NEW_LINE INDENT n = len ( str ) IF n == i >> 1: DEDENT RETURN: SWAP ( str , i , n - i - 1 )  NEW_LINE recursiveReverse ( str , i + 1 )  NEW_LINE DEDENTNote: I assumed you meant to define a function called "swap" to handle swapping characters in
def countNonDecreasing ( n ): NEW_LINE INDENT N, count = 1, 1FOR i IN range ( 1, n + 1 ): NEW_LINE INDENT INDENT count *= N + i - 1 NEW_LINE INDENT INDENT count /= i NEW_LINE DEDENT NEW_LINE return count NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT l = 0h = len ( str ) - 1WHILE h > l:IF str [ l ] != str [ h ]:RETURN False NEW_LINE INDENT l += 1h -= 1 NEW_LINE RETURN True NEW_LINE DEDENT
def countSubStr ( str , n ):  NEW_LINE INDENT m = 0  NEW_LINE FOR i IN range ( n ):  NEW_LINE IF str [ i ] == '1':  NEW_LINE m += 1  NEW_LINE DEDENT  NEW_LINE return m * ( m - 1 ) // 2  NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT n --sum = 0sum += ( n * ( n + 1 ) ) // 2sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6RETURN sum NEW_LINE DEDENT
def decToBinary ( n ):  NEW_LINE INDENT for i in range ( 31, -1, -1 ):  NEW_LINE INDENT INDENT k = ( n >> i ) & 1  NEW_LINE INDENT print ( "1" if k else "0" )  NEW_LINE DEDENT DEDENT  NEW_LINE 
def query ( s , i , j ): NEW_LINE INDENT n = len ( s )i %= nj %= nIF i == j: PRINT " Yes "ELSE: PRINT " No " NEW_LINE DEDENT
def isDivBy9 ( n : int ) : NEW_LINE INDENT if n in ( 0, 9 ) :return True NEW_LINE if n < 9 :return False NEW_LINE return isDivBy9 ( ( int ) ( ( n >> 3 ) - ( n & 7 ) ) ) NEW_LINE DEDENT
def getInvCount ( n, arr ):  NEW_LINE INDENT inv_count = 0  NEW_LINE FOR i IN range ( n - 1 ): FOR j IN range ( n, 0, -1 ): IF arr [ i ] > arr [ j ]: inv_count += 1  NEW_LINE return inv_count  NEW_LINE DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str )c = 0FOR i IN range ( k ) :IF str [ n - i - 1 ] == '0' :c += 1 NEW_LINE return c == k NEW_LINE DEDENT
def printSquares ( n ) :  NEW_LINE INDENT import mathsquare , odd = 0 , 1for _ in range ( n ) : print ( int ( math.sqrt ( square ) ) * int ( math.sqrt ( square ) ) , end = "   " ) square += odd odd += 2 NEW_LINE DEDENT
def breakSum ( n ) :  NEW_LINE INDENT if n in ( 0 , 1 ) : return n  NEW_LINE else : return max ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) , n )  NEW_LINE DEDENT
def findRotations ( str ) : NEW_LINE INDENT tmp = str + strn = len ( str )FOR i IN range ( 1 , n + 1 ) :sub = tmp [ i : ]if str == sub :return i NEW_LINE DEDENTreturn n
def fib ( n, lookup = {} ): NEW_LINE INDENT if n not in lookup: NEW_LINE INDENT INDENT if n <= 1: NEW_LINE INDENT INDENT INDENT lookup [ n ] = n NEW_LINE INDENT INDENT else: NEW_LINE INDENT INDENT INDENT lookup [ n ] = fib ( n - 1 )
def selectRandom ( x ): NEW_LINE INDENT global count, rescount += 1if not count:res = xelse:import randomi = random.randint ( 0, count - 1 )if i == count - 1:res = x NEW_LINE DEDENT
def isOverflow ( a , b ) : NEW_LINE INDENT if not a or not b: NEW_LINE INDENT INDENT return False NEW_LINE DEDENT DEDENT result = a * b NEW_LINE INDENT if a == result / b: NEW_LINE INDENT INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE D
def findNth ( n ) : NEW_LINE INDENT import mathOUTLIERS_INCREMENT = 9nthElement = 19 + ( n - 1 ) * OUTLIERS_INCREMENToutliersCount = int ( math.log10 ( nthElement ) ) - 1nthElement += OUTLIERS_INCREMENT * outliersCountNEW_
def remainder ( str ):  NEW_LINE INDENT num, rem = 0, 0 FOR i IN range ( len ( str ) ): num = rem * 10 + ( ord ( str [i] ) - ord ( '0' ) )  NEW_LINE rem = num % 11  NEW_LINE DEDENT return rem  NEW_LINE 
def arcLength ( diameter , angle ): NEW_LINE INDENT import math NEW_LINE INDENT pi = math.pi NEW_LINE INDENT if angle >= 360: NEW_LINE INDENT INDENT print(f"Angle cannot be formed") NEW_LINE INDENT INDENT return 0 NEW_LINE INDENT else: NEW_LINE INDENT IN
def countRect ( n ) : NEW_LINE INDENT ans = 0FOR length IN range ( 1 , int ( Math . sqrt ( n ) ) + 1 ) :FOR height IN range ( length , int ( n / length ) + 1 ) :ans += 1 NEW_LINE return ans NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ):  NEW_LINE INDENT i, fact = 1, 1  NEW_LINE FOR i IN RANGE( 1, x ):  NEW_LINE fact *= i  NEW_LINE IF fact % x == 0:  NEW_LINE return i  NEW_LINE DEDENT
def gcd ( a , b ):  NEW_LINE INDENT if a < b:a, b = b, a NEW_LINE elif abs ( b ) < 0.001:return a NEW_LINE else:gcd = lambda b, a: gcd ( b, a - int ( a / b ) * b ) NEW_LINE return gcd ( b, a ) NEW_LINE DEDENT
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT INDENT return n == 2 NEW_LINE INDENT DEDENT else : NEW_LINE INDENT INDENT if ( n % i ) : NEW_LINE INDENT INDENT INDENT return False NEW_LINE IND
def countPairs ( arr, n ): NEW_LINE INDENT ans = 0FOR i IN range ( n ):FOR j IN range ( i + 1, n ):IF arr [ i ] == arr [ j ]:ans += 1 NEW_LINE return ans NEW_LINE DEDENT
def countInRange ( arr, n, x, y ): NEW_LINE INDENT count = 0FOR i IN range ( n ):IF arr [ i ] >= x AND arr [ i ] <= y:count += 1 NEW_LINE return count NEW_LINE DEDENT
def isSymmetric ( mat, N ):  NEW_LINE INDENT for i in range(N): for j in range(N): if mat[i][j] != mat[j][i]: return False  NEW_LINE return True  NEW_LINE DEDENT
def countCommon ( mat, n ): NEW_LINE INDENT res = 0FOR i IN range ( n ):IF mat[i][i] == mat[i][n-i-1]:res += 1 NEW_LINE DEDENTRETURN res NEW_LINE 
def first ( str , i : int ) :  NEW_LINE INDENT if len ( str ) <= i: return 0  NEW_LINE if str [i].isupper(): return str [i]  NEW_LINE return first ( str , i + 1 )  NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2sum = multiTermsFOR i IN range ( 2 , n + 1 ) :multiTerms -= i - 1sum += multiTerms * i NEW_LINE return sum NEW_LINE DEDENT
def maxProd ( n : int ) :  NEW_LINE INDENT if n in { 2, 3 } : return ( n - 1 )  NEW_LINE res = 1  NEW_LINE while n > 4 : n -= 3  NEW_LINE res *= 3  NEW_LINE return ( n * res )  NEW_LINE DEDENT
def octalToDecimal ( n ):  NEW_LINE INDENT num, base, dec_value = n, 1, 0  NEW_LINE while num > 0:  NEW_LINE INDENT last_digit = num % 10  NEW_LINE dec_value += last_digit * base  NEW_LINE base *= 8  NEW_LINE num //= 10  NEW_LINE DEDENT  NEW_LINE return
def minTime ( arr , n , m ) : NEW_LINE INDENT t = 0items = 0WHILE True:items += SUM(map(lambda x:t//x,arr))IF items >= m:RETURN t NEW_LINE INDENT t += 1 NEW_LINE DEDENT
def printSquares ( n ) :  NEW_LINE INDENT square, prev_x = 0, 0FOR x IN range ( n ) : NEW_LINE square = square + x + prev_xPRINT(square, "\t", END="")prev_x = x NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str )cl = len ( corner ) NEW_LINE if n < cl :return False NEW_LINE return str [ : cl ] == corner and str [ -cl : ] == corner NEW_LINE DEDENT
def add ( A , B , C ): NEW_LINE INDENT for i in range ( N ):INDENT for j in range ( N ):INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT
def findStep ( n ) : NEW_LINE INDENTif ( n in { 1, 0 } ) : return 1elif n == 2 : return 2else :return sum ( findStep ( n - 3 ) for _ in range ( 3 ) ) + findStep ( n - 1 ) NEW_LINE DEDENT
def isPossibleTriangle ( arr , N ):  NEW_LINE INDENT arr.sort()  NEW_LINE for i in range(N - 2):  NEW_LINE if sum(arr[i:i+2]) > arr[i+2]:  NEW_LINE return True  NEW_LINE DEDENT return False  NEW_LINE 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - by = b - cz = a - c NEW_LINE if x * y > 0:return b NEW_LINE elif x * z > 0:return c NEW_LINE else:return a NEW_LINE DEDENT
def findRepeating ( arr, n ):  NEW_LINE INDENT s = set ( arr [ : n ] )  NEW_LINE for i in range ( n ): if arr [ i ] in s: return arr [ i ]  NEW_LINE s.add ( arr [ i ] )  NEW_LINE DEDENT return - 1  NEW_LINE 
def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT import math NEW_LINE INDENT d = math.sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE INDENT return math.ceil ( d / ( 2 * r
def maxArea ( a, b, c, d ):  NEW_LINE INDENT import math  NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2  NEW_LINE INDENT return math.sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) )  NEW_LINE DEDENT
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT import math NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE INDENT return ( dis - r1 > R or dis + r1 < r ) NEW_LINE DEDENT
def isDiagonalMatrix ( mat ): NEW_LINE INDENT for i in range(len(mat)):for j in range(len(mat)):if (i != j and mat[i][j]):return False NEW_LINE return True NEW_LINE DEDENT
def minValue ( A, B, n ):  NEW_LINE INDENT A.sort()  NEW_LINE INDENT B.sort()  NEW_LINE INDENT result = 0  NEW_LINE INDENT for i in range(n): result += (A[i] * B[n-i-1])  NEW_LINE DEDENT  NEW_LINE return result  NEW_LINE DEDENT
def findMod ( a , b ):  NEW_LINE INDENT a = abs ( a ) ; b = abs ( b )  NEW_LINE mod = a % b  NEW_LINE if a < 0 :  NEW_LINE return - mod  NEW_LINE ELSE:  NEW_LINE return mod  NEW_LINE DEDENT
def arraySortedOrNot ( arr, n ):  NEW_LINE INDENT if ( n <= 1 ):  NEW_LINE INDENT INDENT return true  NEW_LINE INDENT DEDENT else:  NEW_LINE INDENT for i in range ( 1, n ):  NEW_LINE INDENT INDENT if arr [ i - 1 ] > arr [ i ]:  NEW_LINE INDENT IND
def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) :for j in range ( N ) :C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT
def minimumflip ( mat, n ):  NEW_LINE INDENT flip = 0  NEW_LINE INDENT for i in range(n):  NEW_LINE INDENT INDENT for j in range(i):  NEW_LINE INDENT INDENT INDENT if mat[i][j] != mat[j][i]:  NEW_LINE INDENT INDENT INDENT INDENT flip += 1
def sumNodes ( l ) : NEW_LINE INDENT import mathINDENT leafNodeCount = math.pow ( 2 , l - 1 )INDENT sumLastLevel = 0INDENT sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2INDENT sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def findPosition ( k , n ) : NEW_LINE INDENT i = 2long f1 = 0long f2 = 1long f3WHILE i != 0: NEW_LINE INDENT INDENT f3 = f1 + f2f1 = f2f2 = f3IF f2 % k == 0: NEW_LINE INDENT
def findIndex ( n : int ) : NEW_LINE INDENT a , b , c = 0 , 1 , 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE c = a + b NEW_LINE res += 1 NEW_LINE a , b = b , c NEW_LINE return res NEW_LINE DEDENT
def minimumSquare ( a , b ):  NEW_LINE INDENT result , rem = 0 , 0 :  NEW_LINE INDENT if a < b : a , b = b , a :  NEW_LINE INDENT while b > 0 :  NEW_LINE INDENT...... INDENT result += a // b :  NEW_LINE INDENT rem = a % b :  NEW_LINE INDENT a ,
def constructArr ( arr , pair , n ):  NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2  NEW_LINE arr [ 1 : ] = [ pair [ i - 1 ] - arr [ 0 ] for i in range ( 1 , n ) ]  NEW_LINE DEDENT
def findMaximum ( arr, low, high ):  NEW_LINE INDENT max = arr [ low ]INDENT for i in range ( low, high + 1 ):INDENT if arr [ i ] > max:INDENT max = arr [ i ]INDENT  NEW_LINE RETURN max  NEW_LINE DEDENT
def minimum_cost ( a, n ):  NEW_LINE INDENT mn = float('inf')  NEW_LINE sum = 0  NEW_LINE for i in range(n):  NEW_LINE mn = min(mn, a[i])  NEW_LINE sum += a[i]  NEW_LINE return mn * (sum - mn)  NEW_LINE DEDENT
def decToBin ( n ):  NEW_LINE INDENT bin = "" if n == 0 else " "  NEW_LINE WHILE n > 0: bin = str( int( n % 2 ) ) + bin ; n >>= 1  NEW_LINE return bin  NEW_LINE DEDENT
def isInorder ( arr , n ):  NEW_LINE INDENT if ( n <= 1 ):  NEW_LINE INDENT INDENT return True  NEW_LINE DEDENT DEDENT else:  NEW_LINE INDENT INDENT for i in range ( 1 , n ):  NEW_LINE INDENT INDENT INDENT if ( arr [ i - 1 ] > arr [ i ] ):  NEW_LINE INDENT INDENT
def shuffle ( card, n ):  NEW_LINE INDENT import randomRAND = random.Random ( )FOR i IN range ( n ):R = i + RAND.randint ( 52 - i )TEMP = card [ R ]card [ R ] = card [ i ]card [ i ] = TEMP NEW_LINE DEDENT
def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT import math NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE INDENT x = temp * a + x1 NEW_LINE INDENT y = temp * b + y1
def numberOfWays ( x : int ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 )dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE FOR i IN RANGE ( 2 , x + 1 ) :dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2
def leonardo ( n ): NEW_LINE INDENT dp = [ 0 ] * ( n + 1 )dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE FOR i IN RANGE ( 2, n + 1 ):dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 NEW_LINE RETURN dp [
def CountPairs ( n ) : NEW_LINE INDENT k = nimin = 1ans = 0 NEW_LINE INDENT while ( imin <= n ) :imax = n // kans += k * ( imax + 1 - imin )imin = imax + 1k = n // imin NEW_LINE return ans NEW_LINE D
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE \ \ return m + k - 1 NEW_LINE else : NEW_LINE \ \ m -= n - k + 1 NEW_LINE \ \ return ( m % n == 0 ) ? n : m % n
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = pow ( a , b )count = 0 NEW_LINE WHILE p > 0 AND count < k :rem = p % 10count += 1 NEW_LINE IF count == k :return rem NEW_LINE p //= 10 NEW_LINE DEDENTRETURN 
def splitArr ( arr , n , k ):  NEW_LINE INDENT for _ in range ( k ):  NEW_LINE INDENT INDENT x = arr [ 0 ]  NEW_LINE INDENT for i in range ( n - 1 ): arr [ i ] = arr [ i + 1 ]  NEW_LINE INDENT arr [ - 1 ] = x  NEW_LINE INDENT DEDENT  NEW_LINE 
def rotateMatrix ( mat ):  NEW_LINE INDENT for
def russianPeasant ( a , b ):  NEW_LINE INDENT res = 0WHILE b > 0:  NEW_LINE INDENT INDENT if ( b & 1 ) != 0:  NEW_LINE INDENT INDENT INDENT res += a NEW_LINE INDENT a <<= 1 NEW_LINE INDENT b >>= 1 NEW_LINE IND
def findDigits ( n ):  NEW_LINE INDENT if n < 0:  NEW_LINE return 0  NEW_LINE if n <= 1:  NEW_LINE return 1  NEW_LINE digits = 0  NEW_LINE for i in range ( 2, n + 1 ):  NEW_LINE digits += math.log10 ( i )  NEW_LINE return int ( math.floor ( digits ) ) + 1  NEW_LINE DEDENT
def swapDiagonal ( matrix ):  NEW_LINE INDENT for i in range( N ): temp = matrix[i][i]matrix[i][i], matrix[i][N-i-1] = matrix[i][N-i-1], temp NEW_LINE DEDENT
def checkMarkov ( m ):  NEW_LINE INDENT for i in range(len(m)):  NEW_LINE INDENT INDENT sum = 0  NEW_LINE INDENT INDENT for j in range(len(m[i])): sum += m[i][j]  NEW_LINE INDENT INDENT if sum != 1:  NEW_LINE INDENT INDENT return False  NEW_LINE 
def search ( arr, n, x ):  NEW_LINE INDENT i = 0  NEW_LINE WHILE i <= n - 1:  NEW_LINE INDENT IF arr [ i ] == x:  NEW_LINE INDENT INDENT return i  NEW_LINE INDENT ELSE:  NEW_LINE INDENT INDENT i += abs ( arr [ i ] - x )  NEW_LINE INDENT DED
def findMinSum ( a, b, n ):  NEW_LINE INDENT a.sort() ; b.sort()  NEW_LINE sum = 0  NEW_LINE FOR i IN range( n ): sum += abs( a[i] - b[i] )  NEW_LINE RETURN sum  NEW_LINE DEDENT
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0FOR i IN range ( len ( t ) ) :IF count == len ( t ) :BREAKIF t [i] == s [count] :count += 1 NEW_LINE return count NEW_LINE DEDENT
def transpose ( A ):  NEW_LINE INDENT for i in range( N ):  NEW_LINE INDENT INDENT for j in range( i + 1, N ):  NEW_LINE INDENT INDENT temp = A [ i ] [ j ]  NEW_LINE INDENT INDENT A [ i ] [ j ] = A [ j ] [ i ]  NEW_LINE INDENT INDENT A [
def findMinDiff ( arr, n ):  NEW_LINE INDENT arr.sort()  NEW_LINE diff = float('inf')  NEW_LINE for i in range(n-1): if arr[i+1]-arr[i]<diff: diff=arr[i+1]-arr[i]  NEW_LINE return diff  NEW_LINE DEDENT
def countSquares ( a , b ) : NEW_LINE INDENT cnt = 0 NEW_LINE INDENT FOR i IN range ( a , b + 1 ) : NEW_LINE INDENT INDENT FOR j in range ( 1 , int ( math.isqrt ( i ) + 1 ) ) : NEW_LINE INDENT INDENT INDENT if i == j
def count_of_ways ( n ): NEW_LINE INDENT count = 0 NEW_LINE INDENT for i in range ( n + 1 ): NEW_LINE INDENT INDENT for j in range ( n + 1 ): NEW_LINE INDENT INDENT INDENT for k in range ( n + 1 ): NEW_LINE INDENT INDENT INDENT
def findHeight ( parent , n ):  NEW_LINE INDENT res = 0  NEW_LINE FOR i IN range ( n ):  NEW_LINE INDENT_INDENT p = i  NEW_LINE INDENT_INDENT current = 1  NEW_LINE INDENT_INDENT while parent [ p ] != - 1:  NEW_LINE INDENT_INDENT_INDENT current += 1  NEW_LINE IND
def countFriendsPairings ( n ) : NEW_LINE INDENT a , b , c = 1 , 2 , 0 NEW_LINE if ( n <= 2 ) : NEW_LINE return n NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE c = b + ( i - 1 ) * a NEW_LINE a , b = b ,
def numofsubset ( arr, n ):  NEW_LINE INDENT import operator arr.sort(key=operator.less_equal)  NEW_LINE count = 1  NEW_LINE for i in range(n-1): if arr[i]+1!=arr[i+1]: count+=1  NEW_LINE return count  NEW_LINE DEDENT
def printFibonacciNumbers ( n : int ) : NEW_LINE INDENT i, f1, f2 = 0, 0, 1 NEW_LINE if ( n < 1 ) : return NEW_LINE for i in range ( 1, n+1 ) : NEW_LINE print ( f2, end=" " ) NEW_LINE f1, f2 = f2, f1+f2
def exponentiation ( base , exp ) : NEW_LINE INDENT t = 1WHILE exp > 0:INDENT INDENT if exp % 2 != 0:INDENT INDENT INDENT t = ( t * base ) % NINDENT INDENT base = ( base * base ) % NINDENT exp /= 2 NEW_LINE INDENT return t % N
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE FOR x IN range ( 0 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE FOR y IN range ( 0 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE res += 1 NEW_LINE DEDENT NEW_LINE return res
def randomize ( arr, n ):  NEW_LINE INDENT import randomFOR i IN REVERSE RANGE ( n - 1, 0 ): j = random . randint ( i + 1 ) temp = arr [ i ] arr [ i ] = arr [ j ] arr [ j ] = tempPRINT ( arr ) NEW_LINE DEDENT
def isDivisibleBy7 ( num ) : NEW_LINE INDENTif num < 0 : num = - num NEW_LINE if num in ( 0, 7 ) : return true NEW_LINE if num < 10 : return false NEW_LINE return isDivisibleBy7 ( num // 10 - 2 * ( num % 10 ) ) NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ):  NEW_LINE INDENT res = 0 ; a %= mod  NEW_LINE while ( b > 0 ):  NEW_LINE INDENT INDENT if ( b & 1 ) > 0:  NEW_LINE INDENT INDENT res = ( res + a ) % mod  NEW_LINE INDENT a = ( 2 * a ) % mod NEW_
def maximizecube ( l , b , h ) : NEW_LINE INDENT side = gcd ( l , gcd ( b , h ) )side, num = side, l // sidenum *= b // sidenum *= h // sideprint ( side , num ) NEW_LINE DEDENT
def recSearch ( arr, l, r, x ):  NEW_LINE INDENT if r < l:  NEW_LINE return - 1  NEW_LINE if arr[l] == x:  NEW_LINE return l  NEW_LINE if arr[r] == x:  NEW_LINE return r  NEW_LINE INDENT result = recSearch ( arr, l + 1, r - 1, x )  NEW_LINE if result != - 1:  NEW_LINE return result
def eulerian ( n , m ) :  NEW_LINE INDENT if ( n < m or n == 0 ) : return 0  NEW_LINE if ( m == 0 ) : return 1  NEW_LINE return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m )  NEW_LINE DEDENT
def minLexRotation ( str ): NEW_LINE INDENT import operator NEW_LINE INDENT n = len ( str ) NEW_LINE INDENT concat = str + str NEW_LINE INDENT arr = [concat[i:i+n] for i in range(n)] NEW_LINE INDENT arr.sort(key=operator.itemgetter(0)) NEW_LINE 
def isPossible ( a, b, n, k ):  NEW_LINE INDENT a.sort ( reverse=True )  NEW_LINE b.sort ()  NEW_LINE FOR i IN range ( n ): IF a [ i ] + b [ i ] < k: RETURN False  NEW_LINE RETURN True  NEW_LINE DEDENT
def maxProduct ( arr, n ):  NEW_LINE INDENT import math, operator arr.sort()  NEW_LINE return max(arr[0] * arr[1] * arr[n-1], arr[n-1] * arr[n-2] * arr[n-3], key=operator.mul)  NEW_LINE DEDENT
def canMakeAllSame ( str ) : NEW_LINE INDENT zeros = 0ones = 0FOR i IN range ( len ( str ) ) :ch = str [ i ]IF ch == '0' :++ zerosELSE :++ ones NEW_LINE return ( zeros == 1 OR ones == 1 ) NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT if a < b and b < c :return b NEW_LINE elif c < b and b < a :return a NEW_LINE elif b < a and a < c :return a NEW_LINE elif a < c and c < b :return c NEW_LINE elif c < a and a < b :return c NEW_LINE 
def binaryToDecimal ( n ):  NEW_LINE INDENT base, dec_value = 1, 0  NEW_LINE for i in reversed (list (str (n) [::-1])):  NEW_LINE if i == '1':  NEW_LINE dec_value += base  NEW_LINE base *= 2  NEW_LINE  NEW_LINE return dec_value  NEW_LINE DEDENT
def minXOR ( arr, n ):  NEW_LINE INDENT min_xor = 0xFFFFFFFFFOR i IN range ( n ): FOR j IN range ( n ): i < j: min_xor = min ( min_xor, arr [ i ] ^ arr [ j ] ) NEW_LINE return min_xor NEW_LINE DEDENT
def mulmod ( a , b , mod ):  NEW_LINE INDENT res = 0 ; a %= mod ; DEDENT  NEW_LINE while b:  NEW_LINE INDENT if b % 2:  NEW_LINE INDENT INDENT res = ( res + a ) % mod  NEW_LINE INDENT a = ( a * 2 ) % mod  NEW_LINE INDENT b >>= 1 NEW
def nonFibonacci ( n ):  NEW_LINE INDENT prevPrev, prev, curr = 1, 2, 3  NEW_LINE while n > 0:  NEW_LINE INDENT prevPrev, prev = prev, curr  NEW_LINE INDENT curr = prevPrev + prev  NEW_LINE INDENT n -= curr - prev - 1  NEW_LINE INDENT prev, curr = curr, prevPrev
def multiply ( x , y ) : NEW_LINE INDENTif ( y == 0 ) : return 0 NEW_LINE if y > 0 : return x + multiply ( x , y - 1 ) NEW_LINE if y < 0 : return - multiply ( x , - y ) NEW_LINE return - 1 NEW_LINE DEDENT
def firstNonRepeating ( arr, n ):  NEW_LINE INDENT for i in range ( n ): j = 0  NEW_LINE INDENT for j in range ( n ):  NEW_LINE INDENT if i != j and arr [ i ] == arr [ j ]:  NEW_LINE INDENT INDENT break  NEW_LINE INDENT DEDENT if j == n:  NEW_LINE INDENT return
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0N = len ( s )FOR i IN range ( N ) :FOR j IN range ( i + 1 , N + 1 ) :IF s [ i ] == s [ j - 1 ] :result += 1 NEW_LINE RETURN result NEW_LINE DEDENT
def countNegative ( M, n, m ):  NEW_LINE INDENT count = 0  NEW_LINE INDENT for i in range ( n ):  NEW_LINE INDENT INDENT for j in range ( m ):  NEW_LINE INDENT INDENT INDENT if M [ i ] [ j ] < 0 :  NEW_LINE INDENT INDENT INDENT INDENT count += 1
def countSeq ( n ) : NEW_LINE INDENT nCr, res = 1, 1FOR r IN range ( 1, n + 1 ) : NEW_LINE INDENT INDENT nCr = ( nCr * ( n + 1 - r ) ) / r NEW_LINE INDENT res += nCr * nCr NEW_LINE DEDENT NEW_LINE return res NEW_LINE D
def isPrime ( p : int ) : NEW_LINE INDENT import mathCHECK_NUMBER = math.pow ( 2 , p ) - 1NEXT_VAL = 4 % CHECK_NUMBERFOR i IN range ( 1 , p - 1 ) :NEXT_VAL = ( nextval * nextval - 2 ) % CHECK_NUMBERRETURN nextval == 0  NEW_LINE DED
def minXOR ( arr, n ):  NEW_LINE INDENT import operator  NEW_LINE arr.sort(key=operator.xiXOR)  NEW_LINE minXor = float('inf')  NEW_LINE for i in range(n-1): val = arr[i] ^ arr[i+1]  NEW_LINE minXor = min(minXor, val)  NEW_LINE DEDENT return minXor
def binarySearch ( arr, x ):  NEW_LINE INDENT l, r = 0, len(arr) - 1  NEW_LINE INDENT while l <= r:  NEW_LINE INDENT INDENT m = l + ( r - l ) // 2  NEW_LINE INDENT INDENT if arr [m] == x:  NEW_LINE INDENT INDENT INDENT return m NEW_
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE FOR i IN range ( n + 1 ) : NEW_LINE FOR j IN range ( n - i + 1 ) : NEW_LINE FOR k IN range ( n - i - j + 1 ) : NEW_LINE IF i + j + k == n : NEW_LINE result += 1
def power ( x , y , p ) : NEW_LINE INDENT res = 1x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT INDENT res = ( res * x ) % p NEW_LINE INDENT x = ( x * x ) % p NEW_LINE INDENT y >>= 1NEW
def minPerimeter ( n ):  NEW_LINE INDENT l = int ( math . sqrt ( n ) )  NEW_LINE sq = l * l  NEW_LINE if sq == n:  NEW_LINE perimeter = l * 4  NEW_LINE else:  NEW_LINE row = n // l  NEW_LINE perimeter = 2 * ( l + row )  NEW_LINE if n % l:  NEW_LINE perimeter += 
def numberOfPaths ( m , n ): NEW_LINE INDENT dp = [ 0 ] * ndp [ 0 ] = 1 NEW_LINE FOR i IN range ( m ): NEW_LINE INDENT FOR j IN range ( 1 , n ): NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT NEW_LINE RETURN
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0x = n & ( n - 1 ) NEW_LINE IF x == 0 AND n > 0 : NEW_LINE INDENT INDENT while n > 1 :n >>= 1count += 1 NEW_LINE INDENT INDENT END NEW_LINE return ( count %
def subArray ( n ):  NEW_LINE INDENT for i in range ( n ):  NEW_LINE INDENT INDENT for j in range ( i , n ):  NEW_LINE INDENT INDENT INDENT for k in range ( i , j + 1 ):  NEW_LINE INDENT INDENT INDENT INDENT print (arr[k], end=" ")  NEW_LINE INDENT INDENT DEDENT D
def countDivisibles ( arr, n ): NEW_LINE INDENT res = 0 NEW_LINE FOR i IN range ( n ): NEW_LINE FOR j IN range ( i + 1, n ): NEW_LINE IF arr [ i ] % arr [ j ] == 0 OR arr [ j ] % arr [ i ] == 0: NEW_LINE res += 1 NEW_LINE  NEW_LINE 
def findCombinations ( str , index , out = "" ) : NEW_LINE INDENT if index == len ( str ) : NEW_LINE print ( out ) NEW_LINE DEDENT for i in range ( index + 1 , len ( str ) + 1 ) : NEW_LINE findCombinations ( str , i , out + " (" + str [ index : i ] + " ) " )
def decToBinary ( n ):  NEW_LINE INDENT binaryNum = [ 0 ] * 32 ; i = 0 ; n > 0 : i += 1, binaryNum [ - i ] = n % 2, n //= 2  NEW_LINE print ( ''.join ( str ( num ) for num in binaryNum [ ::-1 ] ) )  NEW_LINE DEDENT
def printDistinct ( arr ):  NEW_LINE INDENT import hashset as hs SET = hs.Set( ) FOR i IN range ( len( arr ) ): IF i NOT IN SET: SET.add( arr[i] ) PRINT(arr[i], END=" ")  NEW_LINE DEDENT
def nearestSmallerEqFib ( n ):  NEW_LINE INDENT f1 , f2 , f3 = 0 , 1 , 1  NEW_LINE while f3 <= n:  NEW_LINE INDENT f1 , f2 = f2 , f3  NEW_LINE INDENT f3 = f1 + f2  NEW_LINE DEDENT return f2  NEW_LINE DEDENT
def maxTasks ( high, low, n ):  NEW_LINE INDENT if ( n <= 0 ): return 0  NEW_LINE INDENT INDENT return max( high[n-1] + maxTasks(high, low, n-2 ), low[n-1] + maxTasks(high, low, n-1 ) )  NEW_LINE DEDENT DEDENT  NEW_LINE DEDENT DEDENT
def sequence ( n : int ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 )f [ 0 ] = 0f [ 1 ] = 1f [ 2 ] = 1I = 3WHILE I <= n: NEW_LINE INDENT f [ I ] = f [ f [ I - 1 ] ] + f [ I - f
def maxGameByWinner ( N ): NEW_LINE INDENT dp = [ 0 ] * Ndp [ 0 ] = 1 ; dp [ 1 ] = 2i = 2 NEW_LINE INDENT while dp [ i ] <= N:dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]i += 1 NEW_LINE return i -
def abFree ( s ):  NEW_LINE INDENT b_count = 0 ; res = 0 ; for i in range ( len ( s ) [ :: -1 ] ):  NEW_LINE INDENT INDENT if s [ i ] == ' a ':  NEW_LINE INDENT INDENT INDENT res += b_count * 2 ; b_count = 0  NEW_LINE INDENT IND
def printDistinct ( arr, n ):  NEW_LINE INDENT for i in range ( n ): j = 0  NEW_LINE INDENT INDENT while j < i:  NEW_LINE INDENT INDENT INDENT if arr [ i ] == arr [ j ]:  NEW_LINE INDENT INDENT INDENT break  NEW_LINE INDENT INDENT if j == i:  NEW_LINE 
def findElements ( arr, n ):  NEW_LINE INDENT for i in range ( n ):  NEW_LINE INDENT INDENT count = 0  NEW_LINE INDENT for j in range ( n ):  NEW_LINE INDENT INDENT INDENT if arr [ j ] > arr [ i ]: count += 1  NEW_LINE INDENT INDENT if count >= 2: print ( arr [
def isIdentity ( mat, N ):  NEW_LINE INDENT for row in range( N ):  NEW_LINE INDENT INDENT for col in range( N ):  NEW_LINE INDENT INDENT INDENT if row == col and mat [ row ] [ col ] != 1:  NEW_LINE INDENT INDENT INDENT INDENT return False  NEW_LINE INDENT INDENT IND
def insertSorted ( arr, n, key ):  NEW_LINE INDENT i = n - 1  NEW_LINE WHILE i >= 0 AND arr[i] > key: arr[i + 1] = arr[i] ; i -= 1  NEW_LINE arr[i + 1] = key  NEW_LINE return n + 1  NEW_LINE DEDENT
def solve ( arr, n ):  NEW_LINE INDENT import operator  NEW_LINE INDENT arr.sort ( key = operator.itemgetter ( 0 ) )  NEW_LINE INDENT a, b = 0, 0  NEW_LINE INDENT for i in range ( n ):  NEW_LINE INDENT if i % 2 != 0:  NEW_LINE INDENT a = a * 10
def findMinX ( num, rem, k ):  NEW_LINE INDENT x = 1  NEW_LINE INDENT while True:  NEW_LINE INDENT INDENT j = 0  NEW_LINE INDENT INDENT for j in range(k):  NEW_LINE INDENT INDENT INDENT if x % num[j] != rem[j]:  NEW_LINE INDENT INDENT INDENT break
def countNegative ( M, n, m ):  NEW_LINE INDENT count = 0, i = 0, j = m - 1  NEW_LINE WHILE j >= 0 AND i < n:  NEW_LINE INDENT INDENT if M [ i ] [ j ] < 0 :  NEW_LINE INDENT INDENT INDENT count += j + 1  NEW_LINE INDENT i
def to_upper ( in ):  NEW_LINE INDENT for i in range ( len ( in ) ): in[i] = chr ( ord ( in[i] ) - ord ( 'a' ) + ord ( 'A' ) )  NEW_LINE return ''.join ( in )  NEW_LINE DEDENT
def countPairsWithDiffK ( arr, n, k ): NEW_LINE INDENT count = 0 NEW_LINE FOR i IN range ( n ): NEW_LINE FOR j IN range ( i + 1, n ): NEW_LINE IF arr [ i ] - arr [ j ] == k OR arr [ j ] - arr [ i ] == k: NEW_LINE count += 1 NEW_LINE 
def checkIsAP ( arr, n ):  NEW_LINE INDENT if n == 1:  NEW_LINE INDENT INDENT return True  NEW_LINE INDENT DEDENT arr.sort()  NEW_LINE INDENT d = arr[1] - arr[0]  NEW_LINE INDENT for i in range(2, n):  NEW_LINE INDENT INDENT if arr[i] - arr
def insertionSortRecursive ( arr, n ):  NEW_LINE INDENT if ( n <= 1 ):  NEW_LINE DEDENT return  NEW_LINE INDENT insertionSortRecursive ( arr, n - 1 )  NEW_LINE INDENT last = arr [ n - 1 ]  NEW_LINE INDENT j = n - 2  NEW_LINE INDENT while ( j >= 0 and arr [ j ]
