def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT
def fun ( n ):  NEW_LINE INDENT return n & ( n - 1 )  NEW_LINE DEDENT
def cassini ( n ) : NEW_LINE INDENT return -1 if (n & 1) else 1 NEW_LINE DEDENT
def hexagonalNum ( n ) : NEW_LINE INDENT return n * ( 2 * n - 1 ) NEW_LINE DEDENT
def addOne ( x ) :  NEW_LINE INDENT return - ( ~ x )  NEW_LINE DEDENT
def circumference ( r ) : NEW_LINE INDENT cir = 2 * 3.141592653589793 * r NEW_LINE return cir NEW_LINE DEDENT
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def mergeTwoHalf ( A, n ) : NEW_LINE INDENT import operator NEW_LINE INDENT import functools NEW_LINE INDENT A.sort ( key = functools.partial ( operator.lt ) ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENTreturn n % 2 == 0 NEW_LINE DEDENT
def largest ( arr, n ):  NEW_LINE INDENT import operatorreturn operator.mul( * (sorted(arr, reverse=True)[:1]) )[0] NEW_LINE DEDENT
def height ( N ) : NEW_LINE INDENT import mathreturn int ( math.ceil ( math.log2 ( N + 1 ) ) ) - 1 NEW_LINE DEDENT
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) // 2 NEW_LINE DEDENT
def summingSeries ( n ) : NEW_LINE INDENT return pow ( n , 2 ) NEW_LINE DEDENT
def pentagonalNum ( n ) : NEW_LINE INDENT return ( 3 * n * n - n ) // 2 NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return not ( n & 1 ) NEW_LINE DEDENT
def binomialCoeffSum ( n ) :  NEW_LINE INDENT return ( 1 << n )  NEW_LINE DEDENT
)
def power ( n ) :  NEW_LINE INDENT if ( n == 1 ) :return 2else :return 2 * power ( n - 1 ) NEW_LINE DEDENT
def compute_average ( a , b ) : NEW_LINE INDENT result = ( a + b ) / 2 NEW_LINE return result NEW_LINE DEDENT
def Circumference ( a ) : NEW_LINE INDENTreturn 4 * a NEW_LINE DEDENT
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT result = (x << 1) + x + (x >> 1) NEW_LINE return result NEW_LINE DEDENT
def slope ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENTif ( n == 0 ) :return 1 NEW_LINE return n * factorial ( n - 1 ) NEW_LINE DEDENT
def oppositeSigns ( x , y ) : NEW_LINE INDENTreturn ( ( x ^ y ) < 0 ) NEW_LINE DEDENT
def swapNibbles ( x ) : NEW_LINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEW_LINE DEDENT
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = str \( 'length' \) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT
def getModulo ( n , d ) : NEW_LINE INDENT return n & ( d - 1 ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT
def isMultipleOf10 ( n ) : NEW_LINE INDENT return n % 15 == 0 NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENTif ( n == 0 ) :return 1 NEW_LINE return n * factorial ( n - 1 ) NEW_LINE DEDENT
def count_of_ways ( n ) : NEW_LINE INDENT ll count = ( n + 1 : : 2 ) / 2 NEW_LINE return count NEW_LINE DEDENT
def gcd ( a , b ) :  NEW_LINE INDENT if a == 0: return b  NEW_LINE else: return gcd ( b % a , a )  NEW_LINE DEDENT
def rectCount ( n , m ) :  NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT
def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT import math NEW_LINE INDENT pi = math.pi NEW_LINE INDENT return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return num - divisor * ( num // divisor ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT result = 1 + n * ( n + 1 ) // 2 NEW_LINE return result NEW_LINE DEDENT
def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT
def lis ( arr, n ):  NEW_LINE INDENT import functools MAX = 1 _lis = functools.lru_cache(None)  NEW_LINE INDENT MAX = _lis(arr[:], n, MAX)  NEW_LINE return MAX  NEW_LINE DEDENTdef _lis ( arr, n, max ):  NEW_LINE INDENT if not arr: return max  NEW_LINE 
def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + 3.141592653589793 * 0.5 ) * side * side NEW_LINE DEDENT
def surface_area_octahedron ( side ) : NEW_LINE INDENT import mathRETURN 2 * ( math.sqrt ( 3 ) ) * ( side * side ) NEW_LINE DEDENT
def sortit ( arr, n ):  NEW_LINE INDENT for i in range( n ): arr[i] = i + 1 NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return (n * (n + 1) * (n + 2) * (3 * n + 1)) // 24 NEW_LINE DEDENT
def vol_of_octahedron ( side ) : NEW_LINE INDENT import math NEW_LINE INDENT return ( side * side * side * math.sqrt ( 2 ) / 3 ) NEW_LINE DEDENT
def Resources ( process, need ):  NEW_LINE INDENT minResources = process * ( need - 1 ) + 1  NEW_LINE return minResources  NEW_LINE DEDENT
def procal ( n ) : NEW_LINE INDENT import math NEW_LINE return 1.0 / ( ( 4.0 * ( n * n ) - 1.0 ) / ( 3.0 * n ) ) NEW_LINE DEDENT
def cost ( a, n ):  NEW_LINE INDENT import operator  NEW_LINE INDENT result = ( n - 1 ) * ( min( a[ : n ] ) )  NEW_LINE return result  NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return x and not ( x & ( x - 1 ) ) NEW_LINE DEDENT
def factorial ( n ):  NEW_LINE INDENT import mathres = 1for i in range ( 2 , n + 1 ):res *= ireturn int(res) if n > 1 else 1 NEW_LINE DEDENT
def findRepeating ( arr , n ) : NEW_LINE INDENT import functools NEW_LINE INDENT return sum ( arr [ : n ] ) - ( ( n - 1 ) * n // 2 ) NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT n = len ( str )i = 0 NEW_LINE INDENT WHILE i < n / 2 :str[i], str[n-i-1] = str[n-i-1], str[i]i += 1 NEW_LINE DEDENT
def assignValue ( a , b , x ) : NEW_LINE INDENT arr = [ a , b ] NEW_LINE return arr [ int ( x ) ] NEW_LINE DEDENT
def countSetBits ( self, n ) : NEW_LINE INDENT count = 0WHILE n:NLINE INDENT INDENT n &= ( n - 1 )NLINE INDENT count += 1NLINE DEDENTNLINE return countNLINE DEDENT
def bin ( n ): NEW_LINE INDENT if n > 1:INDENT bin ( n >> 1 ) NEW_LINE INDENT print ( " %d" % (n & 1) ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT import math NEW_LINE INDENT return 0.666 * ( 1 - 1 / pow ( 10 , n ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT long_long_int sum = 0sum = ( 1 << n ) NEW_LINE return sum - 1 NEW_LINE DEDENT
def countSetBits ( n ) :  NEW_LINE INDENT if ( n == 0 ) : return 0  NEW_LINE else : return ( n & 1 ) + countSetBits ( ( n >> 1 ) )  NEW_LINE DEDENT
def countSetBits ( n ) :  NEW_LINE INDENT if ( n == 0 ) : DEDENT return 0  NEW_LINE else : DEDENT return 1 + countSetBits ( n & ( n - 1 ) )  NEW_LINE DEDENT
def kthSmallest ( arr, n, k ) : NEW_LINE INDENT arr.sort() NEW_LINE return arr [ k - 1 ] NEW_LINE DEDENT
def lis ( arr, n ):  NEW_LINE INDENT import functools MAX = 1 _lis = functools.lru_cache(None)  NEW_LINE INDENT MAX = _lis(arr[:], n, MAX)  NEW_LINE return MAX  NEW_LINE DEDENTdef _lis ( arr, n, max ):  NEW_LINE INDENT if not arr: return max  NEW_LINE 
def getArea ( a ) : NEW_LINE INDENT import matharea = math.pi * a * a / 4.0 NEW_LINE return area NEW_LINE DEDENT
def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE s += s1 NEW_LINE return s NEW_LINE DEDENT
def yMod ( y , x ):  NEW_LINE INDENT if ( log2 ( y ) < x ) :  NEW_LINE INDENT INDENT return y  NEW_LINE DEDENT INDENT elif x > 63 :  NEW_LINE INDENT INDENT return y  NEW_LINE DEDENT INDENT else :  NEW_LINE INDENT INDENT return y % ( 1 << x ) NEW
def minSum ( A, n ) : NEW_LINE INDENT import operatormin_val = min ( A, key = operator.itemgetter(0) )RETURN min_val * ( n - 1 ) NEW_LINE DEDENT
def reverse ( str ) :  NEW_LINE INDENT if len ( str ) == 0 : DEDENT return DEDENT reverse ( str [ 1 : ] )print ( str [ 0 ] ) NEW_LINE DEDENT
def addOne ( x ) : NEW_LINE INDENT m = 1WHILE x & m :INDENT INDENT x ^= mm <<= 1DEDENT DEDENT x ^= m NEW_LINE return x
def search ( arr, n, x ) :  NEW_LINE INDENT i = 0 WHILE i < n:  NEW_LINE INDENT INDENT if arr[i] == x:  NEW_LINE INDENT INDENT INDENT return i  NEW_LINE INDENT INDENT i += 1  NEW_LINE INDENT return - 1  NEW_LINE DEDENT
def maxSquare ( b , m ) :  NEW_LINE INDENT return ( b // m - 1 ) * ( b // m ) // 2  NEW_LINE DEDENT
def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) :if not s [ i ].isdigit ():return False NEW_LINE return True NEW_LINE DEDENT
def printArray ( a , n ):  NEW_LINE INDENT for i in range ( n ): print ( a [ i ] , end = "   " )  NEW_LINE print ()  NEW_LINE DEDENT
def findArea ( a ) : NEW_LINE INDENT import matharea = ( math.sqrt ( 5 * ( 5 + 2 * math.sqrt ( 5 ) ) ) * a * a ) / 4 NEW_LINE return area NEW_LINE DEDENT
def printSubStr ( str , low , high ) : NEW_LINE INDENT for i in range ( low , high + 1 ) :PRINT(str[i]) NEW_LINE DEDENT
def getAbs ( n ) : NEW_LINE INDENT mask = ( n >> ( CHARBIT * sizeof ( int ) - 1 ) ).to_bytes ( 1, byteorder='little') [0]INDEPEND mask = int.from_bytes ( mask, byteorder='little')abs_value = n + maskresult = abs_value - mask NEW_LINE return result.to_bytes
def countStr ( n ) :  NEW_LINE INDENT return 1 + n*2+(n*(n*n-1)//2)  NEW_LINE DEDENT
def turnOffK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT INDENT return n NEW_LINE INDENT else : NEW_LINE INDENT INDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT  NEW_LINE DEDENT
def fib ( n : int ) :  NEW_LINE INDENTif n <= 1: return n NEW_LINE else: return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def getOddOccurrence ( ar, ar_size ) :  NEW_LINE INDENT import mathres = 0for i in range ( ar_size ) : res ^= ar [ i ] NEW_LINE return res ^ ( math.fac ( ar_size ) >> 1 ) NEW_LINE DEDENT # Note: math.fac is a Python function to calculate factorial.
def countSquares ( a , b ) :  NEW_LINE INDENT return int ( pow ( sqrt ( b ) , 2 ) ) - int ( pow ( sqrt ( a ) , 2 ) ) + 1  NEW_LINE DEDENT
def divisorSum ( n ) :  NEW_LINE INDENT sum = 0FOR i IN range ( 1 , n + 1 ) :sum += n // i * i NEW_LINE return sum NEW_LINE DEDENT
def maxTripletSum ( arr, n ):  NEW_LINE INDENT arr.sort()  NEW_LINE return arr [-1] + arr [-2] + arr [-3]  NEW_LINE DEDENT
def evenlength ( n ) : NEW_LINE INDENT result = n [::-1] NEW_LINE return result NEW_LINE DEDENT
def findSum ( N , K ) :  NEW_LINE INDENT ans = 0  NEW_LINE FOR i IN range ( 1 , N + 1 ) : ans += ( i % K )  NEW_LINE return ans  NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT INDENT return false NEW_LINE INDENT else : NEW_LINE INDENT INDENT for ( i in range( 2 , n ) ) : NEW_LINE INDENT INDENT INDENT if ( n % i == 0 ) :NEW_
def isPossible ( str , n ) : NEW_LINE INDENT import mathINDETER len = len ( str ) NEW_LINE return len >= n NEW_LINE DEDENT
def printFun ( test ): NEW_LINE INDENT if ( test < 1 ):DEDENT return NEW_LINE INDENT else:DEDENT DEDENT print(test, end=" ")DEDENT DEDENT printFun(test-1)DEDNT DEDNT print(test, end=" ")DEDNT return
def sequence ( n ): NEW_LINE INDENTifnin[1,2]: NEW_LINE INDENTreturn1: NEW_LINE INDENTelse: NEW_LINE INDENTreturnsequence(sequence(n-1))+sequence(n-sequence(n-1)): NEW_LINE  NEW_LINE DEDT
def nextPowerOf2 ( n ):  NEW_LINE INDENT if n and not ( n & ( n - 1 ) ): return n  NEW_LINE p = 1  NEW_LINE while p < n: p <<= 1  NEW_LINE return p  NEW_LINE DEDENT
def leonardo ( n : int ) : NEW_LINE INDENTif ( n == 0 or n == 1 ) :return 1 NEW_LINE INDENT indent = 1return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 NEW_LINE DEDENT DEDENTdef leonardo ( a : int ) : NEW_LINE IND
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1n |= n >> 1n |= n >> 2n |= n >> 4n |= n >> 8n |= n >> 16n += 1 NEW_LINE return n NEW_LINE DEDENT
def vol_of_dodecahedron ( side ) : NEW_LINE INDENT import math NEW_LINE INDENT return ( ( ( 15 + ( 7 * math.sqrt ( 5 ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0temp = p NEW_LINE INDENT WHILE temp <= n :ans += n // temptemp *= p NEW_LINE return ans NEW_LINE DEDENT
def find ( n , k ) : NEW_LINE INDENTif ( n + 1 >= k ) :return ( k - 1 ) NEW_LINE else :return ( 2 * n + 1 - k ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT return ( n != 0 and ( n & ( n - 1 ) ) == 0 and not ( n & 0xAAAAAAAA ) )  NEW_LINE DEDENT
def nswp ( n ): NEW_LINE INDENT if n in { 0, 1 }:INDENT INDENT return 1 NEW_LINE INDENT else:INDENT INDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT  NEW_LINE DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 5 , int ( n / 5 ) + 1 , 5 ) : NEW_LINE \ \ count += n // i NEW_LINE return count NEW_LINE DEDENT
def getMissingNo ( a, n ) : NEW_LINE INDENT total = ( n + 1 + n + 2 ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE total -= a [ i ] NEW_LINE return total
def countPaths ( n , m ) :  NEW_LINE INDENTif n == 0 or m == 0: return 1  NEW_LINE return countPaths ( n - 1 , m ) + countPaths ( n , m - 1 )  NEW_LINE DEDENT
def largestPower ( n , p ) : NEW_LINE INDENT x = 0WHILE n :N NEW_LINE INDENT INDENT n /= p NEW_LINE INDENT x += n NEW_LINE DEDENTRETURN x
def checkValidity ( a , b , c ) : NEW_LINE INDENT if a + b <= c or a + c <= b or b + c <= a : NEW_LINE INDENT INDENT return False NEW_LINE DEDENT DEDENT else: NEW_LINE INDENT INDENT return True NEW_LINE DEDENT DEDENT  NEW_LINE 
T
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1FOR i IN range ( len ( str ) ) :IF str [ i ] == x :index = i NEW_LINE return index NEW_LINE DEDENT
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0temp = p NEW_LINE INDENT WHILE temp <= n :ans += n // temptemp *= p NEW_LINE return ans NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE while i >= 0 : NEW_LINE if str [ i ] == x : NEW_LINE return i NEW_LINE i -= 1 NEW_LINE  NEW_LINE return - 1
def printNos ( self, n ):  NEW_LINE INDENT if ( n > 0 ):INDENT self.printNos ( n - 1 )INDENT print(str(n), end=" ") NEW_LINE return  NEW_LINE 
def findLarger ( arr, n ):  NEW_LINE INDENT import operator  NEW_LINE sort ( arr, key=operator.lt_ )  NEW_LINE for i in reversed(list(slice(n-1, int(n/2),-1))): print(arr[i], end="   ")  NEW_LINE DEDENT
def swap ( xp , yp ) : NEW_LINE INDENT x, y = xp, yp NEW_LINE x ^= y NEW_LINE y ^= x NEW_LINE x ^= y NEW_LINE DEDENT
def printFactorialNums ( n ):  NEW_LINE INDENT fact, x = 1, 2 :  NEW_LINE WHILE fact <= n:  NEW_LINE PRINT(fact, end=" ") :  NEW_LINE fact *= x :  NEW_LINE x += 1 :  NEW_LINE DEDENT  NEW_LINE DEDENT
def getMissingNo ( a , n ) : NEW_LINE INDENT total = 1FOR i IN range ( 2 , n + 1 ) :total += itotal -= a [ i - 2 ] NEW_LINE return total NEW_LINE DEDENT
def numberOfPaths ( m , n ) :  NEW_LINE INDENTif m == 1 or n == 1: return 1  NEW_LINE return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 )  NEW_LINE DEDENT
def count ( s , c ) : NEW_LINE INDENT res = 0FOR i IN range ( len ( s ) ) :IF s [ i ] == c :res += 1 NEW_LINE return res NEW_LINE DEDENT
def maxvolume ( s ) : NEW_LINE INDENT length = s // 3s -= lengthbreadth = s // 2height = s - breadth NEW_LINE return length * breadth * (s - breadth) NEW_LINE DEDENT
def horner ( poly, n, x ):  NEW_LINE INDENT result = 0  NEW_LINE FOR i IN range ( 1, n+1 ): result = result * x + poly[i]  NEW_LINE return result  NEW_LINE DEDENT
def countDigits ( a , b ) :  NEW_LINE INDENT if a == 0 or b == 0 :  NEW_LINE INDENT INDENT return 1  NEW_LINE DEDENT else :  NEW_LINE INDENT INDENT return int ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1  NEW_LINE DEDENT DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE if s [ i ] != s [ 0 ] : NEW_LINE return False NEW_LINE return True NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT import mathres1 = math.log ( y ) / math.log ( x )res2 = log ( y ) / log ( x ) NEW_LINE return res1 == res2 NEW_LINE DEDENT
def modInverse ( a , m ) :  NEW_LINE INDENT a %= mFOR x IN range ( 1 , m ) :IF ( a * x ) % m == 1 :RETURN x NEW_LINE DEDENT
def doublefactorial ( n ) :  NEW_LINE INDENT result = 1FOR i IN reversed(range(n, 0, -2)):IF i IN (0, 1):BREAKresult *= i NEW_LINE RETURN result  NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( str ( ( x1 + x2 ) / 2 ) + " , " + str ( ( y1 + y2 ) / 2 ) NEW_LINE DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0FOR i IN range( n - 1 , 0 , -1 ) :INDENT INDENT sum = sum * ( 1 + x / i ) NEW_LINE return sum
def largest ( arr, n ):  NEW_LINE INDENT max = arr [ 0 ]FOR i IN range ( 1, n ):IF arr [ i ] > max:max = arr [ i ] NEW_LINE return max NEW_LINE DEDENT
def nextPowerOf2 ( n ):  NEW_LINE INDENT if n and not ( n & ( n - 1 ) ): return n  NEW_LINE count = 0  NEW_LINE while n: n >>= 1  NEW_LINE count += 1  NEW_LINE return 1 << count  NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if x == 0 or x == 1: NEW_LINE INDENT INDENT return x NEW_LINE DEDENT else: NEW_LINE INDENT INDENT i, result = 1, 1 NEW_LINE INDENT INDENT while result <= x: NEW_LINE INDENT INDENT IN
def search ( arr, n, x ):  NEW_LINE INDENT for i in range ( n ): if arr [ i ] == x:  NEW_LINE INDENT INDENT return i  NEW_LINE INDENT DEDENT return - 1  NEW_LINE DEDENT
def isPower ( x , y ) : NEW_LINE INDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow *= x NEW_LINE INDENT NEW_LINE return pow == y NEW_LINE DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT cur = k * ( k - 1 ) + 1sum = 0 NEW_LINE INDENT while k > 0 :sum += curcur += 2k -= 1 NEW_LINE return sum NEW_LINE DEDENT
def sumOfSeries ( n ) :  NEW_LINE INDENT sum = 0FOR i IN range ( 1 , n + 1 ) : sum += ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE return sum NEW_LINE DEDENT
def divisibleBy20 ( num ) :  NEW_LINE INDENT lastTwoDigits = int(num[-2:])  NEW_LINE return ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 )  NEW_LINE DEDENT
def squareRoot ( self, n ) :  NEW_LINE INDENT e = 0.000001 x = n y = 1 while abs ( x - y ) > e : x = ( x + y ) / 2 y = n / x  NEW_LINE return x  NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE FOR i IN range ( 1 , n + 1 ) : NEW_LINE FOR j IN range ( i , n + 1 ) : NEW_LINE sum += i * j NEW_LINE RETURN sum NEW_LINE DEDENT
def playGame ( arr, n ):  NEW_LINE INDENT from collections import defaultdict, Counter, OrderedDict hash = defaultdict ( int, Counter ( arr ) ) . most_common ( ) [ 0 ] [ 0 ]  NEW_LINE return int ( len ( hash ) % 2 )  NEW_LINE DEDENT
def isDivisible ( n ) :  NEW_LINE INDENT last_digit  NEW_LINE while n > 10 :  NEW_LINE INDENT n = n / 10  NEW_LINE INDENT last_digit = n % 10  NEW_LINE INDENT n += last_digit * 3  NEW_LINE DEDENT  NEW_LINE return n % 29 == 0  NEW_LINE DEDENT
def first ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) :if str [ i ].isupper ( ) :return str [ i ] NEW_LINE return 0 NEW_LINE DEDENT
def find_extra_element_index ( arrA , arrB , n , m ) : FROM i,j IMPORT HEAPQ NEW_LINE INDENT import heapqextra_element = sum ( arrA [ : n ] ) - sum ( arrB [ : m ] )heap = heapq.Heap [ ( abs ( x - extra_element ) , i) for i, x in enumerate ( arrA [ : n
def spiralDiaSum ( n : int ) :  NEW_LINE INDENT if ( n == 1 ) : return 1  NEW_LINE else : return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) )  NEW_LINE DEDENT
T
def search ( arr, n, x ) :  NEW_LINE INDENT i = 0 WHILE i < n:  NEW_LINE INDENT INDENT if arr[i] == x:  NEW_LINE INDENT INDENT return i  NEW_LINE INDENT INDENT i += 1  NEW_LINE INDENT return - 1  NEW_LINE DEDENT
def Right_most_setbit ( num ) :  NEW_LINE INDENT pos = 1  NEW_LINE for i in range ( 32 if ( 32 <= INT_SIZE ) else int.bit_length ( num ) ) :  NEW_LINE if not ( num & ( 1 << i ) ) :  NEW_LINE pos += 1  NEW_LINE else :  NEW_LINE break  NEW_LINE  NEW_LINE return pos  NEW_LINE D
def smallest ( x , y , z ) : NEW_LINE INDENT int_x = xINT_Y = yINT_Z = z NEW_LINE INDENT WHILE int_x and INT_y and INT_z:INT_x -= 1INT_y -= 1INT_z -= 1INT_c += 1 NEW_LINE DEDENT return INT_
def countOccurrences ( arr, n, x ):  NEW_LINE INDENT res = 0  NEW_LINE FOR i IN range ( n ): IF x == arr[i]: res += 1  NEW_LINE return res  NEW_LINE DEDENT
def getSum ( self, n ) :  NEW_LINE INDENT sum = 0  NEW_LINE while ( n != 0 ) :  NEW_LINE INDENT INDENT sum += n % 10  NEW_LINE INDENT n //= 10  NEW_LINE DEDENT DEDENT return sum  NEW_LINE DEDENT
def nextPowerOf2 ( n ):  NEW_LINE INDENT if n and not ( n & ( n - 1 ) ): return n  NEW_LINE p = 1  NEW_LINE while p < n: p <<= 1  NEW_LINE return p  NEW_LINE DEDENT
def numberOfPaths ( m , n ) : NEW_LINE INDENT path = 1FOR i IN range ( n , m + n - 1 ) :path *= ipath /= ( i - n + 1 ) NEW_LINE return path NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1n |= n >> 1n |= n >> 2n |= n >> 4n |= n >> 8n |= n >> 16n += 1 NEW_LINE return n NEW_LINE DEDENT
def singleNumber ( a , n ) : NEW_LINE INDENT from collections import defaultdict, Counters = defaultdict ( int , Counter ( a ) )arr_sum = sum ( a )set_sum = sum ( list ( s.values ( ) ) )RETURN ( 3 * set_sum - arr_sum ) / 2 NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT import mathAM = ( a + b ) / 2GM = math.sqrt ( a * b )HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT
def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1sum = 0WHILE sum < n: NEW_LINE INDENT INDENT sum += i NEW_LINE INDENT if sum == n: NEW_LINE INDENT INDENT return True NEW_LINE INDENT i += 2 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : FROM IMPORT operator  NEW_LINE INDENT arr.sort()  NEW_LINE return SUM(arr[k1:k2-1])  NEW_LINE DEDENT
def kLargest ( arr, n, k ):  NEW_LINE INDENT arr.sort( reverse=True )  NEW_LINE for i in range( k ): print(arr[i], end=" ")  NEW_LINE DEDENT
def findMinZero ( p ):  NEW_LINE INDENT first, second, number = 1, 1, 2  NEW_LINE INDENT next = ( first + second ) % p  NEW_LINE INDENT while next:  NEW_LINE INDENT \tfirst, second = second, next  NEW_LINE INDENT \tnumber += 1  NEW_LINE INDENT next = ( first + second ) % p
def catalan ( n ):  NEW_LINE INDENT if n <= 1: return 1  NEW_LINE INDENT res = 0  NEW_LINE INDENT for i in range ( n ): res += catalan ( i ) * catalan ( n - i - 1 )  NEW_LINE return res  NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , 0 - ( 1 if s < 0 else 1000001 ) , 1 ) : NEW_LINE INDENT INDENT sum += n * n NEW_LINE INDENT if sum == s : NEW_LINE INDENT INDENT
def evenFib ( n : int ) : NEW_LINE INDENTif ( n < 1 ) : return n NEW_LINE if ( n == 1 ) : return 2 NEW_LINE else : NEW_LINE INDENT INDENT return ( 4 * evenFib ( n - 1 ) + evenFib ( n - 2 ) ) NEW_LINE INDENT DED
def isTriangular ( num ) : NEW_LINE INDENT bool is_triangular = Falsesum = 0n = 1 NEW_LINE INDENT INDENT while ( sum <= num ) :sum += n NEW_LINE INDENT INDENT INDENT if ( sum == num ) :is_triangular = True NEW_LINE INDENT INDENT DEDENT
def check ( str ) :  NEW_LINE INDENT n = len ( str )  NEW_LINE digitSum = sum ( map ( lambda x : ord ( x ) - ord ( '0' ) , str.encode ( ) ) )  NEW_LINE return digitSum % 9 == 0  NEW_LINE DEDENT
def transpose ( A , B ): NEW_LINE INDENT for i in range ( N ):INDENT for j in range ( N ):INDENT B [ i ] [ j ] = A [ j ] [ i ]INDENT  NEW_LINE DEDENT DEDENT
def fib ( n : int ) :  NEW_LINE INDENT import mathPHI = ( 1 + 5 ** 0.5 ) / 2fn = 0 if n < 6 : return fib ( n )ELSE: t = 0WHILE t < n: fn = int ( fn * PHI )t += 1RETURN fn NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) :return 0 NEW_LINE while ( n != 1 ) : NEW_LINE INDENT INDENT if ( n % 2 != 0 ) :return 0 NEW_LINE INDENT INDENT n = n >> 1 NEW_LINE DEDENT DEDENT return 1 NEW_LINE D
def countDigits ( a , b ) :  NEW_LINE INDENT count = 0  NEW_LINE p = abs ( a * b )  NEW_LINE if p == 0 : return 1  NEW_LINE while p > 0 :  NEW_LINE count += 1  NEW_LINE p //= 10  NEW_LINE return count  NEW_LINE DEDENT
def findExtra ( arr1 , arr2 , n ) :  NEW_LINE INDENT for i in range ( n ): if arr1 [ i ] != arr2 [ i ]: return i  NEW_LINE else: return n  NEW_LINE DEDENT
def reverseStr ( str : str ) :  NEW_LINE INDENT n = len ( str ) INDENT for i in range ( 0 , n // 2 ) : INDENT j = n - i - 1 INDENT str [ i ] , str [ j ] = str [ j ] , str [ i ]  NEW_LINE DEDENT
def rotate ( arr , n ):  NEW_LINE INDENT x = arr [ n - 1 ]  NEW_LINE for i in range ( n - 1 , 0 , - 1 ): arr [ i ] = arr [ i - 1 ]  NEW_LINE arr [ 0 ] = x  NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( 1 , 100001 ) : NEW_LINE if sum + ( n ** 3 ) == s : NEW_LINE return n NEW_LINE sum += n ** 3 NEW_LINE DEDENT NEW_LINE return - 1
def isPowerOfFour ( self, n : int ) :  NEW_LINE INDENT if n == 0: return 0  NEW_LINE while n != 1:  NEW_LINE if n % 4 != 0: return 0  NEW_LINE n = n // 4  NEW_LINE  NEW_LINE return 1  NEW_LINE DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0FOR i IN range ( l , r ) :IF a [ i ] == a [ i + 1 ] :count += 1 NEW_LINE return count NEW_LINE DEDENT
def findFrequency ( arr, n, left, right, element ) : NEW_LINE INDENT count = 0 NEW_LINE FOR i IN range ( left - 1, right + 1 ) : NEW_LINE IF arr [ i ] == element : NEW_LINE count += 1 NEW_LINE RETURN count NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s )I = i % nJ = j % nPRINT ("Yes" if ( s [ I ] == s [ J ] ) else "No") NEW_LINE DEDENT
def smallest ( x , y , z ) :  NEW_LINE INDENT if ( y % x != 0 ) return ( y % z != 0 ) * y else z  NEW_LINE if ( x % z != 0 ) return x  NEW_LINE DEDENT
def check ( degree, n ):  NEW_LINE INDENT deg_sum = 0 FOR i IN range ( n ): deg_sum += degree [ i ]  NEW_LINE return 2 * ( n - 1 ) == deg_sum  NEW_LINE DEDENT
def isPalindrome ( str ) :  NEW_LINE INDENT l = 0 ; h = len ( str ) - 1  NEW_LINE while ( h > l ) :  NEW_LINE if str [ l + 1 ] != str [ h ] :  NEW_LINE return False  NEW_LINE l += 1 ; h -= 1  NEW_LINE return True  NEW_LINE DEDENT
def printSquares ( n ) :  NEW_LINE INDENT import mathsquare, odd = 0, 1for _ in range ( n ) : print ( int ( math.sqrt ( square ) ) ** 2 , end = "   " ) square, odd = square + odd, odd + 2 NEW_LINE DEDENT
def minSum ( n ) :  NEW_LINE INDENT sum = 0  NEW_LINE WHILE n > 0 :  NEW_LINE INDENT INDENT sum += n % 10  NEW_LINE INDENT n //= 10  NEW_LINE DEDENT  NEW_LINE return sum if sum == 1 else 10  NEW_LINE DEDENT
def isOneFlip ( str ) : NEW_LINE INDENT sum = 0FOR i IN range ( len ( str ) ) :sum += ord ( str [ i ] ) - ord ( '0' ) NEW_LINE return sum == len ( str ) - 1 OR sum == 1 NEW_LINE DEDENT
def squareRootExists ( n , p ) : NEW_LINE INDENT n %= p NEW_LINE for x in range ( 2 , p ) : NEW_LINE if ( x * x % p == n ) : NEW_LINE return True NEW_LINE DEDENT NEW_LINE return False
def count ( n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , min ( n + 1 , x + 1 ) ) : NEW_LINE if x % i == 0 and i <= n : NEW_LINE count += 1 NEW_LINE return count NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k == 0 or k == n ) : NEW_LINE INDENT INDENT return 1 NEW_LINE INDENT DEDENT else : NEW_LINE INDENT INDENT return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff (
def swapDiagonal ( matrix ): NEW_LINE INDENT for i in range( len(matrix) ):INDENT swap(matrix[i][i], matrix[i][len(matrix)-i-1]) NEW_LINE DEDENT
def arcLength ( diameter , angle ) : NEW_LINE INDENT import math NEW_LINE INDENT pi = math.pi NEW_LINE INDENT if ( angle >= 360 ) : NEW_LINE INDENT INDENT print ( " Angle cannot be formed " ) NEW_LINE INDENT INDENT return 0 NEW_LINE INDENT else : NEW_LINE 
def breakSum ( n ) :  NEW_LINE INDENT if ( n in { 0, 1 } ) : return n  NEW_LINE else : return max ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) , n )  NEW_LINE DEDENT
def isDivBy9 ( n ) :  NEW_LINE INDENT if n in ( 0, 9 ) : return TRUE  NEW_LINE elif n < 9 : return FALSE  NEW_LINE else : return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )  NEW_LINE DEDENT
def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str )c = 0FOR i IN range ( k ) :IF str [ n - i - 1 ] == '0' :c += 1 NEW_LINE return c == k NEW_LINE DEDENT
def findSum ( n ) :  NEW_LINE INDENT n --= 1  NEW_LINE sum = 0  NEW_LINE sum += n * ( n + 1 ) / 2  NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6  NEW_LINE return sum  NEW_LINE DEDENT
def findNth ( n ) : NEW_LINE INDENT import mathINDETER outliersCount = int ( math.log10 ( 19 + ( n - 1 ) * 9 ) ) - 1INDETER nthElement = 19 + 9 * ( outliersCount + 1 ) NEW_LINE return nthElement NEW_LINE DEDENT
def decimalToBinary ( N ) :  NEW_LINE INDENT import mathULL B_Number = 0cnt = 0while N != 0:rem = N % 2c = int(math.pow(10, cnt))B_Number += rem * cN //= 2cnt += 1 NEW_LINE return B_Number NEW_LINE DEDENT
def first ( str , i = 0 ) : NEW_LINE INDENT if len ( str ) <= i : return 0 NEW_LINE if str [ i ].isupper () : return str [ i ] NEW_LINE return first ( str , i + 1 ) NEW_LINE DEDENT
def lexSmallest ( a, n ):  NEW_LINE INDENT a.sort( key=lambda x:x )  NEW_LINE answer = " " * n  NEW_LINE for i in range( n ): answer += a[i]  NEW_LINE return answer  NEW_LINE DEDENT
def countSubStr ( str ) :  NEW_LINE INDENT m = 0  NEW_LINE FOR i IN range ( len ( str ) ) : if str [ i ] == '1' : m += 1  NEW_LINE return m * ( m - 1 ) // 2  NEW_LINE DEDENT
def remainder ( str ) :  NEW_LINE INDENT import math # for string to int conversion INDENT num , rem = 0, 0 # initialize num and rem INDENT for i in range ( len ( str ) ) : num = num * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) # convert char to int and add to num INDENT rem = math.fmod
def findRotations ( str ) : NEW_LINE INDENT tmp = str + strN = len ( str )FOR i IN range ( 1 , N + 1 ) :substring = tmp [ i : i + N ]IF str == substring :return i NEW_LINE DEDENTRETURN N
def randomize ( arr , n ):  NEW_LINE INDENT import randomsrand = lambda:None # C++ srand(time(NULL)) is not directly translatable to Pythonfor i in range ( n - 1 , 0 , - 1 ):  NEW_LINE INDENT j = random.randint ( 0 , i )arr[i], arr[j] = arr[j], arr[i
def gcd ( a , b ) :  NEW_LINE INDENT if a < b : return gcd ( b , a )  NEW_LINE if abs ( b ) < 0.001: return a  NEW_LINE else: return gcd ( b , a - floor ( a / b ) * b )  NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT import mathN = 10count = 1FOR i IN range ( 1 , n + 1 ) :count *= ( N + i - 1 )count /= i NEW_LINE return math.factorial ( N ) // math.factorial ( n + 1 ) * count NEW_LINE DEDENT
def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE FOR length IN range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE FOR height IN range ( length , int ( sqrt ( n ) ) * -1 , -1 ) : NEW_LINE IF n >= length * height : NEW_LINE ans += 1 NEW_LINE  NEW_LINE RETURN ans
def canMakeAllSame ( str ) : NEW_LINE INDENT zeros = 0ones = 0FOR ch IN str:IF ch == '0':NEW_LINE INDENT INDENT zeros += 1ELSE:NEW_LINE INDENT INDENT ones += 1NEW_LINERETURN zeros == 1 OR ones == 1 NEW_LINE DEDENT
def fib ( n, lookup = { 1: 1 } ):  NEW_LINE INDENT if n not in lookup: lookup[n] = fib(n-1, lookup) + fib(n-2, lookup)  NEW_LINE return lookup[n]  NEW_LINE DEDENT
def selectRandom ( x ):  NEW_LINE INDENT static count = 0, res = None  NEW_LINE count += 1  NEW_LINE if count == 1: res = x  NEW_LINE else: i = random.randint ( 0, count - 1 )  NEW_LINE if i == count - 1: res = x  NEW_LINE return res  NEW_LINE DEDENT
def transpose ( A ): NEW_LINE INDENT for i in range( len( A ) ):INDENT for j in range( i + 1 , len( A ) ):INDENT A[i][j], A[j][i] = A[j][i], A[i][j]INDENT  NEW_LINE DEDENT DEDENT
def printSquares ( n ) :  NEW_LINE INDENT import mathsquare, prev_x = 0, 0for x in range ( n ) :square, prev_x = square + x + prev_x, xprint ( int ( math.sqrt ( square ) ) ** 2, end = "\t" ) NEW_LINE DEDENT
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1fact = 1 NEW_LINE INDENT WHILE ( fact % x != 0 ) :fact *= ii += 1 NEW_LINE return i NEW_LINE DEDENT
def getInvCount ( arr, n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE FOR i IN range ( n - 1 ): NEW_LINE FOR j IN range ( n, 0, -1 ): NEW_LINE IF arr [ i ] > arr [ j ]: NEW_LINE inv_count += 1 NEW_LINE  NEW_LINE RETURN inv_count
def countPairs ( arr, n ) : NEW_LINE INDENT ans = 0FOR i IN range ( n ) :FOR j IN range ( n ) :IF i < j AND arr [ i ] == arr [ j ] :ans += 1 NEW_LINE return ans NEW_LINE DEDENT
def recursiveReverse ( str , i = 0 ):  NEW_LINE INDENT if i == len ( str ) / 2:  NEW_LINE INDENT INDENT return  NEW_LINE INDENT else:  NEW_LINE INDENT INDENT str [ i ] , str [ len ( str ) - i - 1 ] = swapped ( str [ i ] , str [ len ( str ) - i -
def countInRange ( arr, n, x, y ): NEW_LINE INDENT count = 0 NEW_LINE FOR i IN range ( n ): NEW_LINE IF arr [ i ] >= x AND arr [ i ] <= y: NEW_LINE count += 1 NEW_LINE  NEW_LINE RETURN count
def isOverflow ( a , b ) : NEW_LINE INDENT if ( not a or not b ) : NEW_LINE INDENT INDENT return False NEW_LINE DEDENT DEDENT result = a * b NEW_LINE INDENT if ( a == result / b ) : NEW_LINE INDENT INDENT return False NEW_LINE DEDENT DEDENT return True
def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT import mathDIS = math.sqrt ( x1 * x1 + y1 * y1 ) NEW_LINE return ( DIS - r1 > R and DIS + r1 <= r ) NEW_LINE DEDENT
def octalToDecimal ( n ) :  NEW_LINE INDENT dec_value = 0 , base = 1  NEW_LINE while temp := n % 10 :  NEW_LINE dec_value += last_digit := temp * base  NEW_LINE base *= 8  NEW_LINE n = n // 10  NEW_LINE return dec_value  NEW_LINE DEDENT
def isSymmetric ( mat, N ):  NEW_LINE INDENT for i in range( N ):  NEW_LINE INDENT INDENT for j in range( N ):  NEW_LINE INDENT INDENT INDENT if mat[i][j] != mat[j][i]:  NEW_LINE INDENT INDENT INDENT INDENT return False  NEW_LINE INDENT INDENT DEDENT
def shuffle ( card , n ):  NEW_LINE INDENT import randomINDENT import copy NEW_LINE shuffle = lambda card, n:random.shuffle(card[:n]) NEW_LINE card = copy.deepcopy(card) NEW_LINE for i in range(n): NEW_LINE r = i + ( random.randint(0, 52 - i) ) NEW_LINE 
def minRevolutions ( r , x1 , y1 , x2 , y2 ) :  NEW_LINE INDENT import math d = math.sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) )  NEW_LINE return math.ceil ( d / ( 2 * r ) )  NEW_LINE DEDENT
def countCommon ( mat, n ):  NEW_LINE INDENT res = 0  NEW_LINE FOR i IN range ( n ): IF mat[i][i] == mat[i][n-i-1]: res += 1  NEW_LINE DEDENT  NEW_LINE return res  NEW_LINE 
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT INDENT return n == 2 NEW_LINE INDENT else : NEW_LINE INDENT INDENT if ( n % i == 0 ) : NEW_LINE INDENT INDENT INDENT return False NEW_LINE IND
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) :INDENT return ( n - 1 ) * 3 NEW_LINE else :INDENT res = 1 NEW_LINE while ( n > 4 ) :INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE  NEW_LINE return n * resNEW
def minTime ( arr , n , m ) : NEW_LINE INDENT t = 0 NEW_LINE INDENT while ( 1 ) : NEW_LINE INDENT __INDENT items = 0 NEW_LINE INDENT __INDENT for i in range ( n ) : NEW_LINE INDENT __INDENT __INDENT items += t // arr [
def isPossibleTriangle ( arr, N ):  NEW_LINE INDENT arr.sort()  NEW_LINE for i in range( N - 2 ): if arr[i] + arr[i+1] > arr[i+2]:  NEW_LINE return True  NEW_LINE DEDENT
def middleOfThree ( a , b , c ) :  NEW_LINE INDENT x = a - b ; y = b - c ; z = a - c ;  NEW_LINE if x * y > 0 :  NEW_LINE return b ;  NEW_LINE else if x * z > 0 :  NEW_LINE return c ;  NEW_LINE else :  NEW_LINE return a ;  NEW_LINE DEDENT
def findRepeating ( arr , n ) :  NEW_LINE INDENT import collections  NEW_LINE s = set ( arr [ : n ] )  NEW_LINE return next ( filter ( lambda x : arr.index ( x ) < n , arr ) , - 1 )  NEW_LINE DEDENT
def maxArea ( a , b , c , d ) : NEW_LINE INDENT import mathINDENT semiperimeter = ( a + b + c + d ) / 2INDENT return math.sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT
def findDigits ( n ):  NEW_LINE INDENT if n < 0:  NEW_LINE return 0  NEW_LINE digits = 0FOR i IN range ( 2, n + 1 ):  NEW_LINE digits += log10 ( i )  NEW_LINE return int ( digits ) + 1  NEW_LINE DEDENT
def isInorder ( arr, n ):  NEW_LINE INDENT if ( n <= 1 ):  NEW_LINE INDENT INDENT return true  NEW_LINE INDENT DEDENT for i in range ( 1, n ):  NEW_LINE INDENT INDENT INDENT if ( arr [ i - 1 ] > arr [ i ] ):  NEW_LINE INDENT INDENT INDENT IND
def isMajority ( a, n ) : NEW_LINE INDENT from collections import CounterINDETER counter = Counter ( a )INDETER return next ( ( k for k, v in counter.items () if v > n // 2 ), False ) NEW_LINE DEDENT
def findStep ( self, n ) :  NEW_LINE INDENT if ( n == 1 or n == 0 ) :return 1 NEW_LINE elif ( n == 2 ) :return 2 NEW_LINE else :return self.findStep ( n - 3 ) + self.findStep ( n - 2 ) + self.findStep ( n - 1 ) NEW_LINE DEDENT
def findPosition ( k , n ) : NEW_LINE INDENT unsigned_long_long_int f1 = 0INDENT unsigned_long_long_int f2 = 1INDENT unsigned_long_long_int f3 NEW_LINE for i in range ( 2 , MAX + 1 ) :INDENT f3 = f1 + f2INDENT f1 = f2IND
def minimum_cost ( a , n ) : NEW_LINE INDENT mn = float ('inf')sum = 0FOR i IN range ( n ) :mn = min ( a [ i ] , mn )sum += a [ i ] NEW_LINE return mn * ( sum - mn ) NEW_LINE DEDENT
def kthdigit ( a , b , k ) : NEW_LINE INDENT import mathp = math.pow ( a , b )count = 0 NEW_LINE INDENT WHILE p > 0 AND count < k:rem = p % 10count += 1 NEW_LINE INDENT IF count == k:return rem NEW_LINE INDENT p //
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ 0 ] * ( x + 1 )dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE FOR i IN range ( 2 , x + 1 ) :dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]NEW_
def sumNodes ( l ) : NEW_LINE INDENT import mathINDETER leafNodeCount = int( math.pow( 2 , l - 1 ) )INDETER sumLastLevel = leafNodeCount * ( leafNodeCount + 1 ) // 2INDETER sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 )dp [ 0 ] = dp [ 1 ] = 1 NEW_LINE FOR i IN range ( 2, n + 1 ) :dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 NEW_LINE return dp [ n
def add ( A , B , C ): NEW_LINE INDENT for i in range ( N ):INDENT for j in range ( N ):INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT  NEW_LINE DEDENT
def arraySortedOrNot ( arr, n ):  NEW_LINE INDENT if ( n <= 1 ):  NEW_LINE INDENT INDENT return true  NEW_LINE INDENT DEDENT else:  NEW_LINE INDENT for i in range ( 1, n ):  NEW_LINE INDENT INDENT if arr [ i - 1 ] > arr [ i ]:  NEW_LINE INDENT IND
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2INDENT sum = multiTerms NEW_LINE FOR i IN range ( 2 , n + 1 ) :INDENT multiTerms -= ( i - 1 )INDENT sum += multiTerms * i NEW_LINE return sum NEW_LINE DEDENT
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str )cl = len ( corner )IF n < cl : RETURN FalseELSE:RETURN ( str [ : cl ] == corner AND str [ -cl : ] == corner ) NEW_LINE DEDENT
def isDiagonalMatrix ( mat [ N ] [ N ] ) : NEW_LINE INDENT for i in range( N ) :for j in range( N ) :if ( i != j ) and mat[i][j] :return False NEW_LINE return True NEW_LINE DEDENT
def minimumflip ( mat, n ):  NEW_LINE INDENT flip = 0  NEW_LINE INDENT FOR i IN range( n ):  NEW_LINE INDENT INDENT FOR j IN range( i ):  NEW_LINE INDENT INDENT INDENT if mat[i][j] != mat[j][i]:  NEW_LINE INDENT INDENT INDENT INDENT flip += 1
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) :RETURN n NEW_LINE INDENT a , b , c , res = 0 , 1 , 1 NEW_LINE INDENT while ( c < n ) :INDENT INDENT c = a + bINDENT INDENT a = bINDENT INDENT b = cNEW
def constructArr ( arr , pair , n ): NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 NEW_LINE arr [ 0] += -arr[0] if n > 1 else 0 NEW_LINE for i in range ( 1 , n ): NEW_LINE INDENT arr [
def checkMarkov ( m ): NEW_LINE INDENT for i in range( len( m ) ):INDENT sum = 0 NEW_LINE INDENT for j in range( len( m [ i ] ) ):INDENT sum += m [ i ] [ j ] NEW_LINE INDENT if sum != 1: NEW_LINE INDENT INDENT return False NEW_LINE D
def findMod ( a , b ) : NEW_LINE INDENT if a < 0 : a = - a NEW_LINE mod = a NEW_LINE if b < 0 : b = - b NEW_LINE while mod >= b : mod -= b NEW_LINE if a < 0 : return - mod NEW_LINE return mod NEW_LINE DEDENT
def recursiveReverse ( str ) :  NEW_LINE INDENT import stack  NEW_LINE INDENT stack = stack.Stack ( )  NEW_LINE for i in range ( len ( str ) ) :  NEW_LINE INDENT INDENT st.push ( str [ i ] )  NEW_LINE DEDENT INDENT str = str [ 0 : i ] + str [ - 1 - i : - 1 ]  NEW_LINE DED
def multiply ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) :INDENT for j in range ( N ) :INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT  NEW_LINE DEDENT
def minValue ( A, B, n ):  NEW_LINE INDENT A.sort()  NEW_LINE INDENT B.sort()  NEW_LINE INDENT result = 0  NEW_LINE INDENT for i in range(n): result += ( A[i] * B[n-i-1] )  NEW_LINE DEDENT return result  NEW_LINE DEDENT
def decToBin ( n ):  NEW_LINE INDENT bin = "" if n == 0 else " "  NEW_LINE while n > 0: n, rem = divmod( n, 2 )  NEW_LINE bin = str( rem ) + bin  NEW_LINE return bin  NEW_LINE DEDENT
[
def russianPeasant ( a , b ):  NEW_LINE INDENT res = 0  NEW_LINE WHILE b > 0:  NEW_LINE INDENT INDENT if b & 1:  NEW_LINE INDENT INDENT INDENT res += a  NEW_LINE INDENT INDENT a <<= 1  NEW_LINE INDENT INDENT b >>= 1  NEW_LINE IND
def splitArr ( arr , n , k ):  NEW_LINE INDENT for _ in range ( k ):  NEW_LINE INDENT INDENT x = arr [ 0 ]  NEW_LINE INDENT for i in range ( n - 1 ): arr [ i ] = arr [ i + 1 ]  NEW_LINE INDENT arr [ - 1 ] = x  NEW_LINE INDENT del arr [ 0]
def CountPairs ( n ) : NEW_LINE INDENT k = nimin = 1ans = 0 NEW_LINE INDENT INDENT while ( imin <= n ) :imax = n // kans += k * ( imax + 1 - imin )imin = imax + 1k = n // imin NEW_LINE return ansNEW
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE INDENT INDENT return m + k - 1 NEW_LINE INDENT else : NEW_LINE INDENT INDENT m -= n - k + 1 NEW_LINE INDENT INDENT return ( m % n == 0 )
def minimumSquare ( a , b ) : NEW_LINE INDENT result = 0rem = 0IF a < b : a, b = b, aWHILE b > 0 :result += a // brem = a % ba, b = b, rem NEW_LINE return result NEW_LINE DEDENT
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 , f2 , i = 0 , 1 NEW_LINE if ( n < 1 ) : return NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE print ( f2 , end = "   " ) NEW_LINE f1 , f2 = f2 , f1
def minLexRotation ( str ): NEW_LINE INDENT import operatorINDEDT n = len ( str )INDEDT arr = [str + str] * nINDEDT arr = list ( map ( lambda x: x [i:] + x [:i] , arr ))INDEDT arr.sort ( key = operator.itemgetter ( 0 ))INDEDT return arr [
def search ( arr , n , x ) :  NEW_LINE INDENT i = 0  NEW_LINE WHILE i <= n - 1:  NEW_LINE INDENT INDENT if arr [ i ] == x:  NEW_LINE INDENT INDENT INDENT return i  NEW_LINE INDENT INDENT i += abs ( arr [ i ] - x )  NEW_LINE INDENT DEDENT DEDENT return
def findHeight ( parent , n ) : NEW_LINE INDENT res = 0FOR i IN range ( n ) :CURRENT = 1P = iWHILE parent [ P ] != - 1 :CURRENT += 1P = parent [ P ]res = max ( res , CURRENT ) NEW_LINE return res NEW_LINE DEDENT
def maxPrefix ( s, t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( t ) ) : NEW_LINE if count == len ( s ) : NEW_LINE break NEW_LINE if t [ i ] == s [ count ] : NEW_LINE count += 1 NEW_LINE  NEW_LINE return count NEW_LINE DEDENT
def findMaximum ( arr, low, high ):  NEW_LINE INDENT max = arr [ low ]i = low + 1while i <= high:  NEW_LINE INDENT IF arr [ i ] > max:max = arr [ i ]ELSE:breaki += 1 NEW_LINE return max  NEW_LINE DEDENT
def findSum ( str ) : NEW_LINE INDENT temp = ""sum = 0FOR ch IN str:IF isdigit ( ch ) :temp += chELSE:sum += int ( temp )temp = "" NEW_LINE return sum + int ( temp ) NEW_LINE DEDENT
def mirrorImage ( a , b , c , x1 , y1 ) : NEW_LINE INDENT import math NEW_LINE INDENT temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) NEW_LINE INDENT x = temp * a + x1 NEW_LINE INDENT y = temp * b + y1
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT res = 0a %= mod NEW_LINE WHILE b:INDENT INDENT if b & 1 :INDENT INDENT res = ( res + a ) % modINDENT a = ( 2 * a ) % modINDENT b >>= 1 NEW_LINE DEDENT
def subset ( arr , n ):  NEW_LINE INDENT from collections import defaultdict, Counter  NEW_LINE INDENT mp = defaultdict(int)  NEW_LINE INDENT for i in range(n): mp[arr[i]] += 1  NEW_LINE INDENT res = max(values(Counter(mp).values()))  NEW_LINE INDENT return res  NEW_LINE DEDENT
def findMinDiff ( arr, n ):  NEW_LINE INDENT arr.sort()  NEW_LINE diff = float('inf')  NEW_LINE FOR i IN range( n - 1 ): IF arr[i+1] - arr[i] < diff: diff = arr[i+1] - arr[i]  NEW_LINE RETURN diff  NEW_LINE DEDENT
def countSquares ( a , b ) :  NEW_LINE INDENT cnt = 0  NEW_LINE FOR i IN range ( a , b + 1 ) :  NEW_LINE INDENT FOR j IN range ( 1 , int ( i ** 0.5 ) + 1 ) :  NEW_LINE INDENT IF i == j * j :  NEW_LINE INDENT INDENT cnt += 1  NEW_LINE IND
def count_of_ways ( n ) : NEW_LINE INDENT count = 0FOR i IN range ( n + 1 ) :FOR j IN range ( n + 1 ) :FOR k IN range ( n + 1 ) :IF i + j + k == n :count += 1 NEW_LINE return count NEW_LINE DEDENT
def countFriendsPairings ( n ) :  NEW_LINE INDENT a , b , c = 1 , 2 , 0  NEW_LINE if ( n <= 2 ) :  NEW_LINE INDENT return n  NEW_LINE DEDENT for i in range ( 3 , n + 1 ) :  NEW_LINE INDENT INDENT c = b + ( i - 1 ) * a  NEW_LINE INDENT
def exponentiation ( base , exp ) : NEW_LINE INDENT t = 1LWHILE exp > 0:INDENT INDENT if exp % 2 != 0:INDENT INDENT INDENT t = ( t * base ) % NINDENT INDENT base = ( base * base ) % NINDENT exp /= 2 NEW_LINE INDENT return
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE INDENT for x in range ( 0 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT INDENT for y in range ( 0 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT INDENT INDENT if x
def maximizecube ( l , b , h ) : NEW_LINE INDENT side = gcd ( l , gcd ( b , h ) )side = int ( side )num = int ( l / side )num = num * int ( b / side )num = num * int ( h / side )print ( side , num ) NEW_LINE DEDENT
def minXOR ( arr , n ) : NEW_LINE INDENT min_xor = 0xFFFFFFFFFOR i IN range ( n ) :FOR j IN range ( n ) :IF i < j :min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) NEW_LINE return min_xor NEW_LINE DEDENT
def maxProduct ( arr , n ):  NEW_LINE INDENT arr.sort()  NEW_LINE return max(arr[0] * arr[1] * arr[n-1] , arr[n-1] * arr[n-2] * arr[n-3])  NEW_LINE DEDENT
def isDivisibleBy7 ( num ) : NEW_LINE INDENTif ( num < 0 ) return isDivisibleBy7 ( - num ) NEW_LINE if num == 0 or num == 7: return 1 NEW_LINE if num < 10: return 0 NEW_LINE return isDivisibleBy7 ( num // 10 - 2 * ( num % 10 ) )NEW
def eulerian ( n , m ) :  NEW_LINE INDENT if ( m >= n or n == 0 ) : return 0  NEW_LINE if ( m == 0 ) : return 1  NEW_LINE return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m )  NEW_LINE DEDENT
def recSearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT INDENT return - 1 NEW_LINE INDENT else : NEW_LINE INDENT INDENT INDENT if ( arr [ l ] == x ) : NEW_LINE INDENT INDENT INDENT INDENT return lNEW
def numofsubset ( arr , n ):  NEW_LINE INDENT arr.sort()  NEW_LINE count = 1  NEW_LINE for i in range( n - 1 ): if arr[i] + 1 != arr[i+1]: count += 1  NEW_LINE return count  NEW_LINE DEDENT
def binaryToDecimal ( n ):  NEW_LINE INDENT num = n [::-1] # reverse string dec_value = 0 # initialize base = 1 base = 1 # initialize len = len ( num ) for i in range ( len ( num ) - 1 , -1 , -1 ): if num [ i ] == '1': dec_value += base base *= 2  NEW_LINE return dec_value NEW_
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0N = len ( s )FOR i IN range ( N ) :FOR j IN range ( i + 1 , N + 1 ) :IF s [ i ] == s [ j - 1 ] :result += 1 NEW_LINE RETURN result NEW_LINE DEDENT
def binarySearch ( arr, l, r, x ):  NEW_LINE INDENT while l <= r:  NEW_LINE INDENT INDENT m = l + ( r - l ) // 2  NEW_LINE INDENT INDENT if arr [ m ] == x:  NEW_LINE INDENT INDENT INDENT return m  NEW_LINE INDENT INDENT elif arr [ m ] < x: NEW
def decToBinary ( n ) :  NEW_LINE INDENT binaryNum = [ 0 ] * 32, i = 0, j = 0, binaryStr = ""  NEW_LINE while ( n > 0 ) :  NEW_LINE INDENT i += 1  NEW_LINE INDENT binaryNum [ i - 1 ] = n % 2 NEW_Line NUM n /= 2  NEW_LINE 
def mulmod ( a , b , mod ) : NEW_LINE INDENT ll_a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT INDENT INDENT res = ( res + ll_a ) % mod NEW_LINE INDENT INDENT ll
def firstNonRepeating ( arr, n ):  NEW_LINE INDENT import collections  NEW_LINE mp = collections.defaultdict ( int )  NEW_LINE for i in range ( n ): mp [ arr [ i ] ] += 1  NEW_LINE for i in range ( n ): if mp [ arr [ i ] ] == 1: return arr [ i ]  NEW_LINE return - 1  NEW_LINE DEDENT
def middleOfThree ( a , b , c ) :  NEW_LINE INDENT if ( a < b and b < c ) or ( c < b and b < a ) :  NEW_LINE INDENT INDENT return b  NEW_LINE INDENT elif ( b < a and a < c ) or ( c < a and a < b ) :  NEW_LINE INDENT INDENT return a  NEW_LINE INDENT else :
def multiply ( self , x , y ) :  NEW_LINE INDENT if ( y == 0 ) : DEDENT return 0  NEW_LINE elif ( y > 0 ) : DEDENT return x + self.multiply ( x , y - 1 )  NEW_LINE elif ( y < 0 ) : DEDENT return - self.multiply ( x , - y )  NEW_LINE DEDENT DEDENT
def to_upper ( in_str ): NEW_LINE INDENT for i in range ( len ( in_str ) ):if in_str [ i ] < ' a' or in_str [ i ] > 'z':continuein_str [ i ] = ord ( in_str [ i ] ) - ord ( 'a' ) + ord ( 'A' ) NEW_LINE return in_str
def findMinSum ( a, b, n ): NEW_LINE INDENT a.sort()b.sort() NEW_LINE INDENT sum = 0FOR i IN range( n ):sum += abs( a[i] - b[i ] ) NEW_LINE return sum NEW_LINE DEDENT
def checkCount ( arr , n , k ) : NEW_LINE INDENT from collections import defaultdicthash = defaultdict ( int , { i : 0 for i in arr } ) NEW_LINE for i in range ( n ) : hash [ arr [ i ] ] += 1 NEW_LINE for x in hash.items () :if x [ 1 ] > 2 * k :return False
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev, prev, curr = 1, 2, 3WHILE n > 0: NEW_LINE INDENT INDENT prevPrev, prev, curr = prev, curr, prevPrev + prev NEW_LINE INDENT INDENT n = n - ( curr - prev ) NEW_LINE DEDENTNEW
def minXOR ( arr , n ) : NEW_LINE INDENT arr.sort() NEW_LINE INDENT minXor = float('inf') NEW_LINE INDENT val = 0 NEW_LINE INDENT for i in range(n - 1) : NEW_LINE INDENT INDENT val = arr[i] ^ arr[i + 1] NEW_LINE IN
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0IF n :IF not ( n & ( n - 1 ) ) : NEW_LINE INDENT INDENT while n > 1 :n >>= 1count += 1 NEW_LINE INDENT INDENT return ( count % 2 == 0 )ELSE :RETURN 
def firstNonRepeating ( arr, n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT INDENT j = 0 NEW_LINE INDENT INDENT while j < n : NEW_LINE INDENT INDENT INDENT if i != j and arr [ i ] == arr [ j ] : NEW_LINE INDENT INDENT
def power ( x , y , p ) : NEW_LINE INDENT result = 1x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT INDENT result = ( result * x ) % p NEW_LINE INDENT x = ( x * x ) % p NEW_LINE INDENT y >>= 1NEW
def isPossible ( a, b, n, k ):  NEW_LINE INDENT a.sort ( ) # Python does not support passing arrays to functions, so we assume a and b are lists.b.sort ( reverse = True )for i in range ( n ):if a [ i ] + b [ i ] < k:return False NEW_LINE DEDENT
def printDistinct ( arr, n ):  NEW_LINE INDENT import set s = set ( arr [ : n ] ) print ( *s )  NEW_LINE DEDENT
def countSeq ( n ) : NEW_LINE INDENT nCr = 1res = 1FOR r IN range ( 1 , n + 1 ) :nCr = nCr * ( n + 1 - r ) // rres += nCr * nCr NEW_LINE return res NEW_LINE DEDENT
def countNegative ( M, n, m ) : NEW_LINE INDENT count = 0 NEW_LINE INDENT INDENT for i in range ( n ) : NEW_LINE INDENT INDENT INDENT for j in range ( m ) : NEW_LINE INDENT INDENT INDENT INDENT if M [ i ] [ j ] < 0 :NEW_
def isPrime ( p ) :  NEW_LINE INDENT import mathcheckNumber = pow ( 2 , p ) - 1nextval = pow ( 4 , 32 ) % checkNumber if p > 3: nextval = pow ( nextval , 2 , checkNumber ) - 2RETURN nextval == 0  NEW_LINE DEDENT
def minPerimeter ( n ) :  NEW_LINE INDENT import mathl = int ( math.sqrt ( n ) )sq = l * lif sq == n :perimeter = l * 4else :row = n // lperimeter = 2 * ( l + row )if n % l != 0 :perimeter += 2return perimeter NEW_LINE D
def sequence ( n ) : NEW_LINE INDENT f = [ 0 ] * ( n + 1 )i = 0f [ 0 ] = 0f [ 1 ] = 1f [ 2 ] = 1 NEW_LINE FOR i IN RANGE ( 3, n + 1 ) :f [ i ] = f [ i - 1 ] + f [
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE FOR i IN range ( n + 1 ) : NEW_LINE FOR j IN range ( n - i + 1 ) : NEW_LINE FOR k IN range ( n - i - j + 1 ) : NEW_LINE IF i + j + k == n : NEW_LINE result += 1
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 ] * Ndp [ 0 ] = 1dp [ 1 ] = 2i = 2 NEW_LINE INDENT while dp [ i ] <= N :dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]i += 1 NEW_LINE 
def numberOfPaths ( m , n ) :  NEW_LINE INDENT dp = [ 1 ] * n  NEW_LINE for _ in range ( m ) :  NEW_LINE INDENT INDENT for j in range ( 1 , n ) :  NEW_LINE INDENT INDENT dp [ j ] += dp [ j - 1 ]  NEW_LINE DEDENT DEDENT  NEW_LINE return dp [ n -
def minOperation ( arr , n ):  NEW_LINE INDENT from collections import defaultdict :  NEW_LINE hash = defaultdict ( int , arr ) :  NEW_LINE max_count = max ( hash.values ( ) ) :  NEW_LINE return n - max_count
def bubbleSort ( arr , n ):  NEW_LINE INDENT for i in range( n - 1 ):  NEW_LINE INDENT INDENT for j in range( n - i - 1 ):  NEW_LINE INDENT INDENT INDENT if arr [ j ] > arr [ j + 1 ]:  NEW_LINE INDENT INDENT INDENT INDENT arr [ j ] , arr [
def findCombinations ( str , index , out = "" ) : NEW_LINE INDENT if index == len ( str ) : NEW_LINE print ( out ) NEW_LINE DEDENT for i in range ( index + 1 , len ( str ) + 1 ) : NEW_LINE findCombinations ( str , i , out + " (" + str [ index : i ] + " ) " )
def countDivisibles ( arr, n ) : NEW_LINE INDENT res = 0FOR i IN range ( n ) :FOR j IN range ( n ) :IF i < j AND arr [ i ] % arr [ j ] == 0 OR arr [ j ] % arr [ i ] == 0 :res += 1 NEW_LINE return res NEW_LINE DEDENT
def maxTasks ( high, low, n ):  NEW_LINE INDENT if ( not n ) : return 0  NEW_LINE INDENT INDENT return max( high[n-1] + maxTasks(high, low, n-2 ), low[n-1] + maxTasks(high, low, n-1 ) )  NEW_LINE DEDENT DEDENT  NEW_LINE DEDENT DEDENT D
def printDistinct ( arr, n ):  NEW_LINE INDENT for i in range ( n ): j = 0  NEW_LINE INDENT INDENT while j < i:  NEW_LINE INDENT INDENT if arr [ i ] == arr [ j ]:  NEW_LINE INDENT INDENT j += 1  NEW_LINE INDENT if j == i: print ( arr [ i ], end = "
def findElements ( arr , n ):  NEW_LINE INDENT for i in range ( n ): INDENT count = 0  NEW_LINE INDENT for j in range ( n ): INDENT if arr [ j ] > arr [ i ]: count += 1  NEW_LINE INDENT if count >= 2: print ( arr [ i ] , end = "   " )  NEW_LINE DEDENT DEDENT
def nearestSmallerEqFib ( n ) :  NEW_LINE INDENT f1 = 0 , f2 = 1 , f3 = 1  NEW_LINE WHILE f3 <= n :  NEW_LINE INDENT INDENT f1 = f2  NEW_LINE INDENT f2 = f3  NEW_LINE INDENT f3 = f1 + f2  NEW_LINE DEDENT  NEW_LINE return f2 NEW
def findMinDiff ( arr, n ):  NEW_LINE INDENT diff = float('inf') FOR i IN range(n - 1): FOR j IN range(n, 0, -1): IF abs(arr[i] - arr[j]) < diff: diff = abs(arr[i] - arr[j])  NEW_LINE return diff  NEW_LINE DEDENT
def subArray ( arr, n ):  NEW_LINE INDENT for i in range ( n ):  NEW_LINE INDENT INDENT for j in range ( i, n ):  NEW_LINE INDENT INDENT INDENT for k in range ( i, j + 1 ):  NEW_LINE INDENT INDENT INDENT INDENT print ( arr [ k ], end = " " )  NEW_LINE IN
def distancesum ( x, y, n ): NEW_LINE INDENT sum = 0 NEW_LINE INDENT for i in range ( n ): NEW_LINE INDENT INDENT for j in range ( i + 1, n ): NEW_LINE INDENT INDENT sum += abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ]
def countWays ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE INDENT table [ 0 ] = 1 NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT IND
def maxSubarrayXOR ( arr, n ):  NEW_LINE INDENT ans = - ( 1 << 31 ) if type( arr ) != list else [ - ( 1 << 31 ) ] * nFOR i IN range( n ): curr_xor = 0 FOR j IN range( i, n ): curr_xor ^= arr [ j ] ans [ i ] = max
def isIdentity ( mat, N ):  NEW_LINE INDENT for row in range( N ):  NEW_LINE INDENT INDENT for col in range( N ):  NEW_LINE INDENT INDENT INDENT if row == col and mat [ row ] [ col ] != 1:  NEW_LINE INDENT INDENT INDENT return False  NEW_LINE INDENT INDENT elif row != col and
def insertSorted ( arr , n , key ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 and arr [ i ] > key ) : NEW_LINE arr [ i + 1 ] = arr [ i ] NEW_LINE i -= 1 NEW_LINE arr [ i + 1 ] = key NEW_LINE return n + 1 NEW_LINE 
def solve ( arr , n ) : NEW_LINE INDENT import operator NEW_LINE INDENT arr.sort ( key = operator.itemgetter ( 0 ) ) NEW_LINE INDENT a = 0 NEW_LINE INDENT b = 0 NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT INDENT if i % 2 :
def findSum ( A, B, n ):  NEW_LINE INDENT from collections import defaultdict :  NEW_LINE hash = defaultdict ( int , { i:0 for i in set ( A + B ) } )  NEW_LINE for i in range ( n ): hash [ A [ i ] ] += 1 ; hash [ B [ i ] ] += 1  NEW_LINE sum = 0  NEW_LINE for x in hash.
def maxLen ( arr, n ):  NEW_LINE INDENT max_len = 0  NEW_LINE FOR i IN range ( n ):  NEW_LINE INDENT INDENT curr_sum = 0  NEW_LINE INDENT INDENT FOR j IN range ( i, n ):  NEW_LINE INDENT INDENT INDENT curr_sum += arr [ j ]  NEW_LINE INDENT INDENT IF
def minRadius ( k , x , y , n ): NEW_LINE INDENT dis = [(x[i]**2+y[i]**2)**0.5 for i in range(n)] NEW_LINE INDENT dis.sort() NEW_LINE return dis[k-1] NEW_LINE DEDENT
def generate ( ones , zeroes , str , len ):  NEW_LINE INDENT if len == len ( str ):  NEW_LINE INDENT INDENT print ( str )  NEW_LINE INDENT INDENT INDENT INDENT return  NEW_LINE INDENT generate ( ones + 1 , zeroes , str + "1" , len )  NEW_LINE INDENT generate ( ones , zeroes + 1
def search ( arr, n, x ) :  NEW_LINE INDENT i = 0WHILE i < n:INDENT_INDENT if arr [ i ] == x:RETURN ii += abs ( arr [ i ] - x )DEINDENT NEW_LINE IF __name__ == "__main__":arr = [ 1 , 2 , 3 , 4 , 5 ]n =
def search ( arr , n , x , k ) : NEW_LINE INDENT i = 0 NEW_LINE WHILE i < n : NEW_LINE INDENT INDENT if arr [ i ] == x : NEW_LINE INDENT INDENT INDENT return i NEW_LINE INDENT INDENT i += max ( 1 , abs ( arr [ i ] - x ) /
def countPairsWithDiffK ( arr, n, k ): NEW_LINE INDENT count = 0 NEW_LINE FOR i IN range ( n ): NEW_LINE FOR j IN range ( i + 1, n ): NEW_LINE IF ( arr [ i ] - arr [ j ] == k OR arr [ j ] - arr [ i ] == k ): NEW_LINE count += 1NEW_
def countNegative ( M, n, m ):  NEW_LINE INDENT i, j = 0, m - 1  NEW_LINE count = 0  NEW_LINE while j >= 0 and i < n:  NEW_LINE if M [ i ] [ j ] < 0:  NEW_LINE count += j + 1  NEW_LINE i += 1  NEW_LINE j -= 1  NEW_LINE return count NEW_
def findMinX ( num, rem, k ) : NEW_LINE INDENT x = 1 NEW_LINE INDENT while ( true ) : NEW_LINE INDENT INDENT j NEW_LINE INDENT INDENT for j in range ( k ) : NEW_LINE INDENT INDENT INDENT if ( x % num [ j ] != rem [ j ] ) :
def removeDuplicates ( S ) : NEW_LINE INDENT n = len ( S ) NEW_LINE if ( n < 2 ) return NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE if S [ j ] != S [ i ] : NEW_LINE j += 1 NEW_LINE S [ j ] = S [ i ]
def distributingBalls ( k , n , str ) :  NEW_LINE INDENT a = [ 0 ] * 26 # assuming MAX_CHAR = 26 in Python  NEW_LINE for i in range ( n ) : a [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1  NEW_LINE for i in range ( len ( a ) ) : if a [ i ] > k :
def insertionSortRecursive ( arr , n ):  NEW_LINE INDENT if ( n <= 1 ):  NEW_LINE DEDENT return  NEW_LINE INDENT insertionSortRecursive ( arr , n - 1 )  NEW_LINE DEDENT last = arr [ n - 1 ]j = n - 2 NEW_LINE WHILE j >= 0 AND arr [ j ] > last:
def areEqual ( arr1 , arr2 , n , m ): NEW_LINE INDENT if ( n != m ): return False NEW_LINE arr1.sort() NEW_LINE arr2.sort() NEW_LINE for i in range(n): NEW_LINE if arr1[i] != arr2[i]: return False NEW_LINE return True NEW_LINE DEDENT
def getOddOccurrence ( arr, arr_size ):  NEW_LINE INDENT i = 0  NEW_LINE INDENT count = 0  NEW_LINE INDENT WHILE i < arr_size:  NEW_LINE INDENT INDENT j = 0  NEW_LINE INDENT INDENT while j < arr_size:  NEW_LINE INDENT INDENT INDENT if arr [ i
def checkIsAP ( arr, n ):  NEW_LINE INDENT if ( n == 1 ):  NEW_LINE return True  NEW_LINE else:  NEW_LINE sort ( arr, arr : range ( n ) )  NEW_LINE d = arr [ 1 ] - arr [ 0 ]  NEW_LINE for i in range ( 1, n ):  NEW_LINE if ( arr [ i ] - arr [ i - 1 ] !=
def minOps ( arr , n , k ) : NEW_LINE INDENT import operatormax = max(arr, key=lambda x:x)res = 0FOR i IN range(n):IF ( max - arr[i] ) % k != 0:return - 1res += ( max - arr[i] ) // k NEW_LINE DEDENTreturn res
