def areaSquare(side): NEW_LINE INDENT return side * side NEW_LINE DEDENT
def fun(n): NEW_LINE INDENT return n & (n - 1) NEW_LINE DEDENT
def intersection(n): NEW_LINE INDENT return n * (n - 1) NEW_LINE DEDENT
def hexagonalNum(n): NEW_LINE INDENT return n * (2 * n - 1) NEW_LINE DEDENT
def cassini(n): NEW_LINE INDENT return -1 if n & 1 else 1 NEW_LINE DEDENT
def addOne(x): NEW_LINE INDENT return -(~x) NEW_LINE DEDENT
def mergeTwoHalf(A, n): NEW_LINE INDENT A.sort() NEW_LINE DEDENT
def find_Area(r): NEW_LINE INDENT return (2 * r * r) NEW_LINE DEDENT
def check(n): NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def isEven(n): NEW_LINE INDENT return n % 2 == 0 NEW_LINE DEDENT
def pentagonalNum(n): NEW_LINE INDENT return (3 * n * n - n) // 2 NEW_LINE DEDENT
def circumference(r): NEW_LINE INDENT PI = 3.1415 NEW_LINE cir = 2 * PI * r NEW_LINE return cir NEW_LINE DEDENT
def numberOfSticks(x): NEW_LINE INDENT return (3 * x * (x + 1)) // 2 NEW_LINE DEDENT
def binomialCoeffSum(n): NEW_LINE INDENT return (1 << n) NEW_LINE DEDENT
def largest(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE return arr[n - 1] NEW_LINE DEDENT
def Circumference(a): NEW_LINE INDENT return 4 * a NEW_LINE DEDENT
def rangeGCD(n, m): NEW_LINE INDENT return n if n == m else 1 NEW_LINE DEDENT 
def power(n): NEW_LINE INDENT return 2 if n == 1 else 2 * power(n - 1) NEW_LINE DEDENT
def compute_average(a, b): NEW_LINE INDENT return (a + b) // 2 NEW_LINE DEDENT
def summingSeries(n): NEW_LINE INDENT return int(n**2) NEW_LINE DEDENT
def multiplyWith3Point5(x): NEW_LINE INDENT return (x << 1) + x + (x >> 1) NEW_LINE DEDENT
def isEven(n): NEW_LINE INDENT return (n & 1) == 0 NEW_LINE DEDENT
def factorial(n): NEW_LINE INDENT if n == 0: return 1 NEW_LINE return n * factorial(n - 1) NEW_LINE DEDENT
def slope(x1, y1, x2, y2): NEW_LINE INDENT return (y2 - y1) / (x2 - x1) NEW_LINE DEDENT
def getModulo(n, d): NEW_LINE INDENT return n & (d - 1) NEW_LINE DEDENT
def oppositeSigns(x, y): NEW_LINE INDENT return (x ^ y) < 0 NEW_LINE DEDENT
def height(N): NEW_LINE INDENT return int((N + 1).bit_length()) - 1 NEW_LINE DEDENT
def swapNibbles(x): NEW_LINE INDENT return ((x & 0x0F) << 4 | (x & 0xF0) >> 4) NEW_LINE DEDENT
def factorial(n): NEW_LINE INDENT if n == 0: return 1 NEW_LINE return n * factorial(n - 1) NEW_LINE DEDENT
def countNonEmptySubstr(str): NEW_LINE INDENT return len(str) * (len(str) + 1) // 2 NEW_LINE DEDENT
def nthTerm(n): NEW_LINE INDENT return (n * n) + (n * n * n) NEW_LINE DEDENT
def getRemainder(num, divisor): NEW_LINE INDENT return num % divisor NEW_LINE DEDENT
def findMaximumPieces(n): NEW_LINE INDENT return 1 + n * (n + 1) // 2 NEW_LINE DEDENT
def lis(arr): NEW_LINE INDENT n = len(arr) NEW_LINE max_ref = [1] NEW_LINE def _lis(n): NEW_LINE INDENT if n == 1: NEW_LINE INDENT return 1 NEW_LINE DEDENT max_ending_here = 1 NEW_LINE for i in range(1, n): NEW_LINE INDENT res = _lis(i) NEW_LINE if arr[i-1] < arr[n-1] and res + 1 > max_ending_here: NEW_LINE INDENT max_ending_here = res + 1 NEW_LINE DEDENT DEDENT max_ref[0] = max(max_ref[0], max_ending_here) NEW_LINE return max_ending_here NEW_LINE DEDENT _lis(n) NEW_LINE return max_ref[0] NEW_LINE DEDENT
def gcd(a, b): NEW_LINE INDENT return b if a == 0 else gcd(b % a, a) NEW_LINE DEDENT
def rectCount(n, m): NEW_LINE INDENT return (m * n * (n + 1) * (m + 1)) // 4 NEW_LINE DEDENT
def evenbinomialCoeffSum(n): NEW_LINE INDENT return 1 << (n - 1) NEW_LINE DEDENT
def count_of_ways(n): NEW_LINE INDENT return (n + 1) * (n + 2) // 2 NEW_LINE DEDENT
def isMultipleOf10(n): NEW_LINE INDENT return n % 15 == 0 NEW_LINE DEDENT
def areaOctagon(side): NEW_LINE INDENT return 2 * (1 + 2**0.5) * side * side NEW_LINE DEDENT
def findSum(n): NEW_LINE INDENT return n * (n + 1) * (n + 2) * (3 * n + 1) // 24 NEW_LINE DEDENT
def reverse(str): NEW_LINE INDENT n = len(str) NEW_LINE for i in range(n // 2): NEW_LINE INDENT str[i], str[n - i - 1] = str[n - i - 1], str[i] NEW_LINE DEDENT NEW_LINE DEDENT
def sortit(arr, n): NEW_LINE INDENT for i in range(n): arr[i] = i + 1 NEW_LINE DEDENT
def factorial(n): NEW_LINE INDENT res = 1 NEW_LINE for i in range(2, n+1): NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT
def surface_area_octahedron(side): NEW_LINE INDENT return 2 * (3**0.5) * (side * side) NEW_LINE DEDENT
def Resources(process, need): NEW_LINE INDENT return process * (need - 1) + 1 NEW_LINE DEDENT
def volumeOfEllipsoid(r1, r2, r3): NEW_LINE INDENT return 1.33 * 3.14 * r1 * r2 * r3 NEW_LINE DEDENT
def procal(n): NEW_LINE INDENT return (3.0 * n) / (4.0 * (n * n) - 1) NEW_LINE DEDENT
def vol_of_octahedron(side): NEW_LINE INDENT return (side ** 3) * (math.sqrt(2) / 3) NEW_LINE DEDENT
def countSetBits(n): NEW_LINE INDENT count = 0 NEW_LINE while n > 0: NEW_LINE INDENT n &= n - 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def calculateSum(n): NEW_LINE INDENT return (1 << n) - 1 NEW_LINE DEDENT
def isPowerOfTwo(x): NEW_LINE INDENT return x != 0 and (x & (x - 1)) == 0 NEW_LINE DEDENT
def assignValue(a, b, x): NEW_LINE INDENT return [a, b][x] NEW_LINE DEDENT
def kthSmallest(arr, k): NEW_LINE INDENT arr.sort() NEW_LINE return arr[k - 1] NEW_LINE DEDENT
def lis(arr, n): NEW_LINE INDENT global max_ref NEW_LINE max_ref = 1 NEW_LINE _lis(arr, n) NEW_LINE return max_ref NEW_LINE DEDENT
def sumOfSeries(n): NEW_LINE INDENT return 0.666 * (1 - 1 / (10 ** n)) NEW_LINE DEDENT
def countSetBits(n): NEW_LINE INDENT return 0 if n == 0 else 1 + countSetBits(n & (n - 1)) NEW_LINE DEDENT
def repeat(s, n): NEW_LINE INDENT s1 = s NEW_LINE for i in range(1, n): NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def countSetBits(n): NEW_LINE INDENT return 0 if n == 0 else (n & 1) + countSetBits(n >> 1) NEW_LINE DEDENT
def bin(n): NEW_LINE INDENT if n > 1: bin(n >> 1) NEW_LINE print(f"{n & 1}", end=" ") NEW_LINE DEDENT
def printSubStr(str, low, high): NEW_LINE INDENT print(str[low:high+1]) NEW_LINE DEDENT
def getAbs(n): NEW_LINE INDENT return ((n + (mask := n >> (32 * 8 - 1))) ^ mask) NEW_LINE DEDENT
def maxSquare(b, m): NEW_LINE INDENT return (b // m - 1) * (b // m) // 2 NEW_LINE DEDENT
def getArea(a): NEW_LINE INDENT return (3.14159 * a * a) / 4 NEW_LINE DEDENT
def minSum(A, n): NEW_LINE INDENT return min(A) * (n - 1) NEW_LINE DEDENT
def countStr(n): NEW_LINE INDENT return 1 + (n * 2) + (n * ((n * n) - 1) // 2) NEW_LINE DEDENT
def turnOffK(n, k): NEW_LINE INDENT if k <= 0: return n NEW_LINE return n & ~(1 << (k - 1)) NEW_LINE DEDENT
def yMod(y, x): NEW_LINE INDENT if (math.log(y) / math.log(2)) < x: return y NEW_LINE if x > 63: return y NEW_LINE return y % (1 << int(x)) NEW_LINE DEDENT
def search(arr, x): NEW_LINE INDENT n = len(arr) NEW_LINE for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT return n if n <= 1 else fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def maxTripletSum(arr, n): NEW_LINE INDENT return sum(sorted(arr)[-3:]) NEW_LINE DEDENT
def isNumber(s): NEW_LINE INDENT for i in range(len(s)): NEW_LINE INDENT if not s[i].isdigit(): NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def divisorSum(n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(1, n+1): NEW_LINE INDENT sum += (n // i) * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def addOne(x): NEW_LINE INDENT m = 1 NEW_LINE while (x & m) >= 1: NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT
def findRepeating(arr, n): NEW_LINE INDENT return sum(arr) - (((n - 1) * n) // 2) NEW_LINE DEDENT
def findSum(N, K): NEW_LINE INDENT ans = 0 NEW_LINE for i in range(1, N + 1): NEW_LINE INDENT ans += i % K NEW_LINE DEDENT return ans NEW_LINE DEDENT
def isPrime(n): NEW_LINE INDENT if n <= 1: return False NEW_LINE for i in range(2, n): NEW_LINE INDENT if n % i == 0: return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def isPossible(str, n): NEW_LINE INDENT return str.length() >= n NEW_LINE DEDENT
def getOddOccurrence(ar, ar_size): NEW_LINE INDENT res = 0 NEW_LINE for i in range(ar_size): NEW_LINE INDENT res ^= ar[i] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findArea(a): NEW_LINE INDENT return (5 * (5 + 2 * (5**0.5))**0.5 * a * a) / 4 NEW_LINE DEDENT
def printArray(a, n): NEW_LINE INDENT for i in range(n): print(a[i], end=' ▁ ') NEW_LINE print() NEW_LINE DEDENT
def evenlength(n): NEW_LINE INDENT res = n NEW_LINE for j in range(len(n) - 1, -1, -1): NEW_LINE INDENT res += n[j] NEW_LINE DEDENT return res NEW_LINE DEDENT
def sequence(n): NEW_LINE INDENT if n == 1 or n == 2: return 1 NEW_LINE else: return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1)) NEW_LINE DEDENT
def nextPowerOf2(n): NEW_LINE INDENT if n > 0 and (n & (n - 1)) == 0: return n NEW_LINE p = 1 NEW_LINE while p < n: NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def isPowerOfFour(n): NEW_LINE INDENT return n != 0 and (n & (n - 1)) == 0 and (n & 0xAAAAAAAA) == 0 NEW_LINE DEDENT
def nswp(n): NEW_LINE INDENT if n == 0 or n == 1: return 1 NEW_LINE return 2 * nswp(n - 1) + nswp(n - 2) NEW_LINE DEDENT
def findTrailingZeros(n): NEW_LINE INDENT count = 0 NEW_LINE for i in range(5, n+1, 5): NEW_LINE INDENT while i % 5 == 0: NEW_LINE INDENT count += 1 NEW_LINE i //= 5 NEW_LINE DEDENT NEW_LINE DEDENT return count NEW_LINE DEDENT
def find(n, k): NEW_LINE INDENT return k - 1 if n + 1 >= k else 2 * n + 1 - k NEW_LINE DEDENT
def leonardo(n): NEW_LINE INDENT return 1 if n == 0 or n == 1 else leonardo(n - 1) + leonardo(n - 2) + 1 NEW_LINE DEDENT
def countSquares(a, b): NEW_LINE INDENT return int(math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a)) + 1) NEW_LINE DEDENT
def countPaths(n, m): NEW_LINE INDENT return 1 if n == 0 or m == 0 else countPaths(n - 1, m) + countPaths(n, m - 1) NEW_LINE DEDENT
def nextPowerOf2(n): NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def vol_of_dodecahedron(side): NEW_LINE INDENT return ((15 + 7 * (5 ** 0.5)) / 4) * (side ** 3) NEW_LINE DEDENT
def Largestpower(n, p): NEW_LINE INDENT ans = 0 NEW_LINE while n > 0: NEW_LINE INDENT n //= p NEW_LINE ans += n NEW_LINE DEDENT return ans NEW_LINE DEDENT
def checkValidity(a, b, c): NEW_LINE INDENT return 0 if (a + b <= c or a + c <= b or b + c <= a) else 1 NEW_LINE DEDENT
def PowerOFPINnfactorial(n, p): NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while temp <= n: NEW_LINE INDENT ans += n // temp NEW_LINE temp *= p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find_extra_element_index(arrA, arrB): NEW_LINE INDENT extra_element = sum(arrA) - sum(arrB) NEW_LINE return arrA.index(extra_element) NEW_LINE DEDENT
def getMissingNo(a, n): NEW_LINE INDENT total = (n + 1) * (n + 2) // 2 NEW_LINE for i in range(n): NEW_LINE INDENT total -= a[i] NEW_LINE DEDENT return total NEW_LINE DEDENT
def findLastIndex(str, x): NEW_LINE INDENT index = -1 NEW_LINE for i in range(len(str)): NEW_LINE INDENT if str[i] == x: NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findLastIndex(str, x): NEW_LINE INDENT for i in range(len(str) - 1, -1, -1): NEW_LINE INDENT if str[i] == x: return i NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def getMissingNo(a, n): NEW_LINE INDENT total = 1 NEW_LINE for i in range(2, n + 2): NEW_LINE INDENT total += i NEW_LINE total -= a[i - 2] NEW_LINE DEDENT return total NEW_LINE DEDENT
def cost(a, n): NEW_LINE INDENT min_val = a[0] NEW_LINE for i in range(1, len(a)): NEW_LINE INDENT if a[i] < min_val: NEW_LINE INDENT min_val = a[i] NEW_LINE DEDENT DEDENT return (n - 1) * min_val NEW_LINE DEDENT
def largest(arr): NEW_LINE INDENT max_value = arr[0] NEW_LINE for i in range(1, len(arr)): NEW_LINE INDENT if arr[i] > max_value: NEW_LINE INDENT max_value = arr[i] NEW_LINE DEDENT DEDENT return max_value NEW_LINE DEDENT
def printNos(n): NEW_LINE INDENT if n > 0: NEW_LINE INDENT printNos(n - 1) NEW_LINE print(n, "▁", end='') NEW_LINE DEDENT return NEW_LINE DEDENT
def numberOfPaths(m, n): NEW_LINE INDENT return 1 if m == 1 or n == 1 else numberOfPaths(m - 1, n) + numberOfPaths(m, n - 1) NEW_LINE DEDENT
def maxvolume(s): NEW_LINE INDENT length = s // 3 NEW_LINE s -= length NEW_LINE breadth = s // 2 NEW_LINE height = s - breadth NEW_LINE return length * breadth * height NEW_LINE DEDENT
def findLarger(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE for i in range(n-1, n//2-1, -1): print(arr[i], end=' ▁ ') NEW_LINE DEDENT
def playGame(arr): NEW_LINE INDENT set = set(arr) NEW_LINE return 1 if len(set) % 2 == 0 else 2 NEW_LINE DEDENT
def leftRotate(arr, n, k): NEW_LINE INDENT for i in range(k, k + n): print(arr[i % n], end=" ▁ ") NEW_LINE DEDENT
def horner(poly, n, x): NEW_LINE INDENT result = poly[0] NEW_LINE for i in range(1, n): NEW_LINE INDENT result = result * x + poly[i] NEW_LINE DEDENT return result NEW_LINE DEDENT
def findSum(n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT for j in range(i, n + 1): NEW_LINE INDENT sum += i * j NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def doublefactorial(n): NEW_LINE INDENT res = 1 NEW_LINE for i in range(n, -1, -2): NEW_LINE INDENT if i == 0 or i == 1: NEW_LINE INDENT return res NEW_LINE DEDENT else: NEW_LINE INDENT res *= i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printFun(test): NEW_LINE INDENT if test < 1: NEW_LINE INDENT return NEW_LINE DEDENT else: NEW_LINE INDENT print(f"{test} ▁ ", end='') NEW_LINE printFun(test - 1) NEW_LINE print(f"{test} ▁ ", end='') NEW_LINE return NEW_LINE DEDENT DEDENT
def exponential(n, x): NEW_LINE INDENT sum = 1 NEW_LINE for i in range(n-1, 0, -1): NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def squareRoot(n): NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while x - y > e: NEW_LINE INDENT x = (x + y) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def print_factorial_nums(n): NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n: NEW_LINE INDENT print(fact, "▁", end="") NEW_LINE fact *= x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def divisibleBy20(num): NEW_LINE INDENT lastTwoDigits = int(num[-2:]) NEW_LINE return (lastTwoDigits % 5 == 0) and (lastTwoDigits % 4 == 0) NEW_LINE DEDENT
def floorSqrt(x): NEW_LINE INDENT if x == 0 or x == 1: return x NEW_LINE i, result = 1, 1 NEW_LINE while result <= x: NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def search(arr, n, x): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def modInverse(a, m): NEW_LINE INDENT a = a % m NEW_LINE for x in range(1, m): NEW_LINE INDENT if (a * x) % m == 1: NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def count(s, c): NEW_LINE INDENT res = 0 NEW_LINE for i in range(len(s)): NEW_LINE INDENT if s[i] == c: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def sumOfSeries(n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(1, n+1): NEW_LINE INDENT sum += (2*i - 1) ** 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def nextPowerOf2(n): NEW_LINE INDENT count = 0 NEW_LINE if n > 0 and (n & (n - 1)) == 0: NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0: NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT
def isPower(x, y): NEW_LINE INDENT if x == 1: return y == 1 NEW_LINE pow = 1 NEW_LINE while pow < y: NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return pow == y NEW_LINE DEDENT
def allCharactersSame(s): NEW_LINE INDENT n = len(s) NEW_LINE for i in range(1, n): NEW_LINE INDENT if s[i] != s[0]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def center(x1, x2, y1, y2): NEW_LINE INDENT print(f"{(x1 + x2) / 2} , {chr(9615)} {(y1 + y2) / 2}") NEW_LINE DEDENT
def kthgroupsum(k): NEW_LINE INDENT cur = (k * (k - 1)) + 1 NEW_LINE sum = 0 NEW_LINE while k > 0: NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getSum(n): NEW_LINE INDENT sum = 0 NEW_LINE while n != 0: NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def spiralDiaSum(n): NEW_LINE INDENT if n == 1: return 1 NEW_LINE return (4 * n * n - 6 * n + 6 + spiralDiaSum(n - 2)) NEW_LINE DEDENT
def isDivisible(n): NEW_LINE INDENT while n / 100 > 0: NEW_LINE INDENT last_digit = int(n % 10) NEW_LINE n //= 10 NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return n % 29 == 0 NEW_LINE DEDENT
def countOccurrences(arr, n, x): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT if x == arr[i]: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Right_most_setbit(num): NEW_LINE INDENT INT_SIZE = 32 NEW_LINE for i in range(INT_SIZE): NEW_LINE INDENT if not (num & (1 << i)): NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else: NEW_LINE INDENT break NEW_LINE DEDENT NEW_LINE return pos NEW_LINE DEDENT
def nextPowerOf2(n): NEW_LINE INDENT p = 1 NEW_LINE if n > 0 and (n & (n - 1)) == 0: NEW_LINE INDENT return n NEW_LINE DEDENT while p < n: NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def numberOfPaths(m, n): NEW_LINE INDENT path = 1 NEW_LINE for i in range(n, m + n - 1): NEW_LINE INDENT path *= i NEW_LINE path //= (i - n + 1) NEW_LINE DEDENT return path NEW_LINE DEDENT
def search(arr, n, x): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def isPerfectSquare(n): NEW_LINE INDENT sum, i = 0, 1 NEW_LINE while sum < n: NEW_LINE INDENT sum += i NEW_LINE if sum == n: NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def catalan(n): NEW_LINE INDENT if n <= 1: NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT res += catalan(i) * catalan(n - i - 1) NEW_LINE DEDENT return res NEW_LINE DEDENT
def transpose(A, B): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(len(A[i])): NEW_LINE INDENT B[i][j] = A[j][i] NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def first(str): NEW_LINE INDENT for i in range(len(str)): NEW_LINE INDENT if str[i].isupper(): NEW_LINE INDENT return str[i] NEW_LINE DEDENT DEDENT return '\0' NEW_LINE DEDENT
def rotate(arr): NEW_LINE INDENT x = arr[-1] NEW_LINE for i in range(len(arr) - 1, 0, -1): NEW_LINE INDENT arr[i] = arr[i - 1] NEW_LINE DEDENT arr[0] = x NEW_LINE DEDENT
def evenFib(n): NEW_LINE INDENT if n < 1: return n NEW_LINE if n == 1: return 2 NEW_LINE return (4 * evenFib(n - 1)) + evenFib(n - 2) NEW_LINE DEDENT
def kLargest(arr, k): NEW_LINE INDENT arr.sort(reverse=True) NEW_LINE for i in range(k): print(arr[i], end=' ▁ ') NEW_LINE DEDENT
def compute(a, b): NEW_LINE INDENT AM = (a + b) / 2 NEW_LINE GM = (a * b)**0.5 NEW_LINE HM = (GM * GM) / AM NEW_LINE return HM NEW_LINE DEDENT
def findS(s): NEW_LINE INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s: NEW_LINE INDENT sum += n * n NEW_LINE if sum == s: NEW_LINE INDENT return n NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def isTriangular(num): NEW_LINE INDENT if num < 0: return False NEW_LINE sum = 0 NEW_LINE for n in range(1, num + 1): NEW_LINE INDENT sum += n NEW_LINE if sum == num: return True NEW_LINE if sum > num: break NEW_LINE DEDENT return False NEW_LINE DEDENT
def nextPowerOf2(n): NEW_LINE INDENT n -= 1; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; n += 1; return n NEW_LINE DEDENT
def PowerOFPINnfactorial(n, p): NEW_LINE INDENT ans = 0 NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT count, temp = 0, i NEW_LINE while temp % p == 0: NEW_LINE INDENT count += 1 NEW_LINE temp //= p NEW_LINE DEDENT ans += count NEW_LINE DEDENT return ans NEW_LINE DEDENT
def reverse(str): NEW_LINE INDENT if str is None or len(str) <= 1: NEW_LINE INDENT print(str) NEW_LINE DEDENT else: NEW_LINE INDENT print(str[-1], end='') NEW_LINE reverse(str[:-1]) NEW_LINE DEDENT DEDENT
def isPowerOfFour(n): NEW_LINE INDENT if n == 0: return 0 NEW_LINE while n != 1: NEW_LINE INDENT if n % 4 != 0: return 0 NEW_LINE n = n // 4 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def isPowerOfTwo(n): NEW_LINE INDENT if n == 0: return False NEW_LINE while n != 1: NEW_LINE INDENT if n % 2 != 0: return False NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findMinZero(p): NEW_LINE INDENT first, second, number, next = 1, 1, 2, 1 NEW_LINE while next > 0: NEW_LINE INDENT next = (first + second) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def findExtra(arr1, arr2, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr1[i] != arr2[i]: NEW_LINE INDENT return i NEW_LINE DEDENT NEW_LINE DEDENT return n NEW_LINE DEDENT
def countDigits(a, b): NEW_LINE INDENT return 1 if (a == 0 or b == 0) else int(math.log10(abs(a)) + math.log10(abs(b))) + 1 NEW_LINE DEDENT
def isPower(x, y): NEW_LINE INDENT import math NEW_LINE return int(math.log(y) / math.log(x)) == (math.log(y) / math.log(x)) NEW_LINE DEDENT
def smallest(x, y, z): NEW_LINE INDENT c = 0 NEW_LINE while x != 0 and y != 0 and z != 0: NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT
def findS(s): NEW_LINE INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s: NEW_LINE INDENT sum += n * n * n NEW_LINE if sum == s: NEW_LINE INDENT return n NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def check(str): NEW_LINE INDENT n = len(str) NEW_LINE digitSum = 0 NEW_LINE for i in range(n): NEW_LINE INDENT digitSum += int(str[i]) - int('0') NEW_LINE DEDENT return digitSum % 9 == 0 NEW_LINE DEDENT
def countDigits(a, b): NEW_LINE INDENT count = 0 NEW_LINE p = abs(a * b) NEW_LINE if p == 0: NEW_LINE INDENT return 1 NEW_LINE DEDENT while p > 0: NEW_LINE INDENT count += 1 NEW_LINE p //= 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def answer_query(a, n, l, r): NEW_LINE INDENT count = 0 NEW_LINE for i in range(l, r): NEW_LINE INDENT if a[i] == a[i + 1]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def swap(xp, yp): NEW_LINE INDENT xp[0] = xp[0] ^ yp[0] NEW_LINE yp[0] = xp[0] ^ yp[0] NEW_LINE xp[0] = xp[0] ^ yp[0] NEW_LINE DEDENT
def findFrequency(arr, n, left, right, element): NEW_LINE INDENT count = 0 NEW_LINE for i in range(left - 1, right): NEW_LINE INDENT if arr[i] == element: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def lexsmallest(a, n): NEW_LINE INDENT a.sort() NEW_LINE answer = "" NEW_LINE for i in range(n): NEW_LINE INDENT answer += a[i] NEW_LINE DEDENT return answer NEW_LINE DEDENT
def minSum(n): NEW_LINE INDENT sum = 0 NEW_LINE while n > 0: NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT if sum == 1: NEW_LINE INDENT return 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fib(n): NEW_LINE INDENT if n < 6: return f[n] NEW_LINE fn, t = 5, 5 NEW_LINE while t < n: NEW_LINE INDENT fn = round(fn * PHI) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def check(degree, n): NEW_LINE INDENT deg_sum = sum(degree[:n]) NEW_LINE return 2 * (n - 1) == deg_sum NEW_LINE DEDENT
def squareRootExists(n, p): NEW_LINE INDENT n = n % p NEW_LINE for x in range(2, p): NEW_LINE INDENT if (x * x) % p == n: NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def count(n, x): NEW_LINE INDENT count = 0 NEW_LINE for i in range(1, min(n, x) + 1): NEW_LINE INDENT if x // i <= n and x % i == 0: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def smallest(x, y, z): NEW_LINE INDENT return y if (y // x) != 1 else z if (y // z) != 1 else y NEW_LINE return x if (x // z) != 1 else z NEW_LINE DEDENT
def binomialCoeff(n, k): NEW_LINE INDENT if k == 0 or k == n: return 1 NEW_LINE return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k) NEW_LINE DEDENT
def sumBetweenTwoKth(arr, k1, k2): NEW_LINE INDENT arr.sort() NEW_LINE result = 0 NEW_LINE for i in range(k1, k2 - 1): NEW_LINE INDENT result += arr[i] NEW_LINE DEDENT return result NEW_LINE DEDENT
def decimalToBinary(N): NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while N != 0: NEW_LINE INDENT rem = N % 2 NEW_LINE c = int(pow(10, cnt)) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def isOneFlip(str): NEW_LINE INDENT sum = 0 NEW_LINE n = len(str) NEW_LINE for i in range(n): NEW_LINE INDENT sum += int(str[i]) NEW_LINE DEDENT return (sum == n - 1 or sum == 1) NEW_LINE DEDENT
def recursiveReverse(str, i): NEW_LINE INDENT n = len(str) NEW_LINE if i == n // 2: return NEW_LINE str[i], str[n-i-1] = str[n-i-1], str[i] NEW_LINE recursiveReverse(str, i + 1) NEW_LINE DEDENT
def countNonDecreasing(n): NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range(1, n+1): NEW_LINE INDENT count *= (N + i - 1) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPalindrome(str): NEW_LINE INDENT l, h = 0, len(str) - 1 NEW_LINE while h > l: NEW_LINE INDENT if str[l] != str[h]: return False NEW_LINE l, h = l + 1, h - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countSubStr(str, n): NEW_LINE INDENT m = 0 NEW_LINE for i in range(n): NEW_LINE INDENT if str[i] == '1': NEW_LINE INDENT m += 1 NEW_LINE DEDENT DEDENT return m * (m - 1) // 2 NEW_LINE DEDENT
def findSum(n): NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += (n * (n + 1)) // 2 NEW_LINE sum += (n * (n + 1) * (2 * n + 1)) // 6 NEW_LINE return sum NEW_LINE DEDENT
def decToBinary(n): NEW_LINE INDENT for i in range(31, -1, -1): NEW_LINE INDENT k = n >> i NEW_LINE if k & 1: NEW_LINE INDENT print("1", end="") NEW_LINE DEDENT else: NEW_LINE INDENT print("0", end="") NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def query(s, i, j): NEW_LINE INDENT n = len(s) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if s[i] == s[j]: NEW_LINE INDENT print("Yes") NEW_LINE DEDENT else: NEW_LINE INDENT print("No") NEW_LINE DEDENT NEW_LINE DEDENT
def isDivBy9(n): NEW_LINE INDENT if n == 0 or n == 9: return True NEW_LINE if n < 9: return False NEW_LINE return isDivBy9((n >> 3) - (n & 7)) NEW_LINE DEDENT
def getInvCount(arr, n): NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range(n - 1): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if arr[i] > arr[j]: NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def isDivisible(str, k): NEW_LINE INDENT n = len(str) NEW_LINE c = 0 NEW_LINE for i in range(k): NEW_LINE INDENT if str[n - i - 1] == '0': NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c == k NEW_LINE DEDENT
def printSquares(n): NEW_LINE INDENT square, odd = 0, 1 NEW_LINE for x in range(n): NEW_LINE INDENT print(square, end=' ▁ ') NEW_LINE square += odd NEW_LINE odd += 2 NEW_LINE DEDENT NEW_LINE DEDENT
def breakSum(n): NEW_LINE INDENT return n if n == 0 or n == 1 else max(breakSum(n // 2) + breakSum(n // 3) + breakSum(n // 4), n) NEW_LINE DEDENT
def findRotations(str): NEW_LINE INDENT tmp = str + str NEW_LINE n = len(str) NEW_LINE for i in range(1, n+1): NEW_LINE INDENT substring = tmp[i:n+i] NEW_LINE if str == substring: NEW_LINE INDENT return i NEW_LINE DEDENT NEW_LINE DEDENT return n NEW_LINE DEDENT
def fib(n): NEW_LINE INDENT if lookup[n] == NIL: NEW_LINE INDENT if n <= 1: NEW_LINE INDENT lookup[n] = n NEW_LINE DEDENT else: NEW_LINE INDENT lookup[n] = fib(n - 1) + fib(n - 2) NEW_LINE DEDENT DEDENT return lookup[n] NEW_LINE DEDENT
def selectRandom(x): NEW_LINE INDENT global count, res NEW_LINE count += 1 NEW_LINE if count == 1: NEW_LINE INDENT res = x NEW_LINE DEDENT else: NEW_LINE INDENT from random import randint NEW_LINE i = randint(0, count - 1) NEW_LINE if i == count - 1: NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT NEW_LINE return res NEW_LINE DEDENT
def isOverflow(a, b): NEW_LINE INDENT if a == 0 or b == 0: NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if a == result / b: NEW_LINE INDENT return False NEW_LINE DEDENT else: NEW_LINE INDENT return True NEW_LINE DEDENT NEW_LINE DEDENT
def findNth(n): NEW_LINE INDENT nthElement = 19 + (n - 1) * 9 NEW_LINE outliersCount = int(math.log10(nthElement)) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def remainder(str): NEW_LINE INDENT len = len(str) NEW_LINE rem = 0 NEW_LINE for i in range(len): NEW_LINE INDENT num = rem * 10 + (ord(str[i]) - ord('0')) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def arcLength(diameter, angle): NEW_LINE INDENT pi = 22.0 / 7.0 NEW_LINE if angle >= 360: NEW_LINE INDENT print("Angle cannot be formed") NEW_LINE return 0 NEW_LINE DEDENT else: NEW_LINE INDENT arc = (pi * diameter) * (angle / 360.0) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def countRect(n): NEW_LINE INDENT ans = 0 NEW_LINE for length in range(1, int(n**0.5) + 1): NEW_LINE INDENT for height in range(length, n // length + 1): NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def firstFactorialDivisibleNumber(x): NEW_LINE INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range(1, x): NEW_LINE INDENT fact *= i NEW_LINE if fact % x == 0: NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT
def gcd(a, b): NEW_LINE INDENT if a < b: return gcd(b, a) NEW_LINE if abs(b) < 0.001: return a NEW_LINE else: return gcd(b, a - (a // b) * b) NEW_LINE DEDENT
def isPrime(n, i=2): NEW_LINE INDENT if n <= 2: return n == 2 NEW_LINE if n % i == 0: return False NEW_LINE if i * i > n: return True NEW_LINE return isPrime(n, i + 1) NEW_LINE DEDENT
def countPairs(arr, n): NEW_LINE INDENT ans = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if arr[i] == arr[j]: NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countInRange(arr, x, y): NEW_LINE INDENT return sum(1 for i in arr if x <= i <= y) NEW_LINE DEDENT
def isSymmetric(mat, N): NEW_LINE INDENT for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT if mat[i][j] != mat[j][i]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def countCommon(mat, n): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT if mat[i][i] == mat[i][n - i - 1]: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def first(str, i): NEW_LINE INDENT if i >= len(str): return 0 NEW_LINE if str[i].isupper(): return str[i] NEW_LINE return first(str, i + 1) NEW_LINE DEDENT
def findSum(n): NEW_LINE INDENT multiTerms = n * (n + 1) // 2 NEW_LINE sum = multiTerms NEW_LINE for i in range(2, n + 1): NEW_LINE INDENT multiTerms = multiTerms - (i - 1) NEW_LINE sum = sum + multiTerms * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxProd(n): NEW_LINE INDENT if n == 2 or n == 3: return n - 1 NEW_LINE res = 1 NEW_LINE while n > 4: NEW_LINE INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE DEDENT return n * res NEW_LINE DEDENT
def octalToDecimal(n): NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while temp > 0: NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = temp // 10 NEW_LINE dec_value += last_digit * base NEW_LINE base *= 8 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def minTime(arr, n, m): NEW_LINE INDENT t = 0 NEW_LINE while True: NEW_LINE INDENT items = sum(t // arr[i] for i in range(n)) NEW_LINE if items >= m: return t NEW_LINE t += 1 NEW_LINE DEDENT DEDENT
def printSquares(n): NEW_LINE INDENT square, prev_x = 0, 0 NEW_LINE for x in range(n): NEW_LINE INDENT square += x + prev_x NEW_LINE print(square, "▁", end='') NEW_LINE prev_x = x NEW_LINE DEDENT NEW_LINE DEDENT
def isCornerPresent(str, corner): NEW_LINE INDENT n = len(str) NEW_LINE cl = len(corner) NEW_LINE if n < cl: NEW_LINE INDENT return False NEW_LINE DEDENT return (str[:cl] == corner and str[-cl:] == corner) NEW_LINE DEDENT
def add(A, B, C, N): NEW_LINE INDENT for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT C[i][j] = A[i][j] + B[i][j] NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT
def findStep(n): NEW_LINE INDENT return 1 if n == 0 or n == 1 else 2 if n == 2 else findStep(n - 3) + findStep(n - 2) + findStep(n - 1) NEW_LINE DEDENT
def is_possible_triangle(arr, N): NEW_LINE INDENT if N < 3: return False NEW_LINE arr.sort() NEW_LINE for i in range(N - 2): NEW_LINE INDENT if arr[i] + arr[i + 1] > arr[i + 2]: return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def middleOfThree(a, b, c): NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0: NEW_LINE INDENT return b NEW_LINE DEDENT elif x * z > 0: NEW_LINE INDENT return c NEW_LINE DEDENT else: NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def findRepeating(arr, n): NEW_LINE INDENT s = set() NEW_LINE for i in range(n): NEW_LINE INDENT if arr[i] in s: return arr[i] NEW_LINE s.add(arr[i]) NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def minRevolutions(r, x1, y1, x2, y2): NEW_LINE INDENT return math.ceil(math.sqrt((x1 - x2)**2 + (y1 - y2)**2) / (2 * r)) NEW_LINE DEDENT
def maxArea(a, b, c, d): NEW_LINE INDENT return ((a+b+c+d)/2 - a) * ((a+b+c+d)/2 - b) * ((a+b+c+d)/2 - c) * ((a+b+c+d)/2 - d) ** 0.5 NEW_LINE DEDENT
def checkcircle(r, R, r1, x1, y1): NEW_LINE INDENT return (abs(x1**2 + y1**2)**0.5 - r1 >= R) and (abs(x1**2 + y1**2)**0.5 + r1 <= r) NEW_LINE DEDENT
def isDiagonalMatrix(mat): NEW_LINE INDENT N = len(mat) NEW_LINE for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT if i != j and mat[i][j] != 0: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minValue(A, B, n): NEW_LINE INDENT A.sort() NEW_LINE B.sort() NEW_LINE result = 0 NEW_LINE for i in range(n): NEW_LINE INDENT result += A[i] * B[n - i - 1] NEW_LINE DEDENT return result NEW_LINE DEDENT
def findMod(a, b): NEW_LINE INDENT a = -a if a < 0 else a NEW_LINE b = -b if b < 0 else b NEW_LINE mod = a NEW_LINE while mod >= b: NEW_LINE INDENT mod -= b NEW_LINE DEDENT return -mod if a < 0 else mod NEW_LINE DEDENT
def arraySortedOrNot(arr, n): NEW_LINE INDENT return True if n == 0 or n == 1 else all(arr[i - 1] <= arr[i] for i in range(1, n)) NEW_LINE DEDENT
def multiply(A, B, C): NEW_LINE INDENT for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT C[i][j] = A[i][j] - B[i][j] NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT
def minimumflip(mat, n): NEW_LINE INDENT flip = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i): NEW_LINE INDENT if mat[i][j] != mat[j][i]: NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def sumNodes(l): NEW_LINE INDENT leafNodeCount = 2 ** (l - 1) NEW_LINE sumLastLevel = (leafNodeCount * (leafNodeCount + 1)) / 2 NEW_LINE sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def findPosition(k, n): NEW_LINE INDENT f1, f2 = 0, 1 NEW_LINE i = 2 NEW_LINE while True: NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1, f2 = f2, f3 NEW_LINE if f2 % k == 0: NEW_LINE INDENT return n * i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findIndex(n): NEW_LINE INDENT if n <= 1: return n NEW_LINE a, b, c = 0, 1, 1 NEW_LINE res = 1 NEW_LINE while c < n: NEW_LINE INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumSquare(a, b): NEW_LINE INDENT result, rem = 0, 0 NEW_LINE if a < b: NEW_LINE INDENT a, b = b, a NEW_LINE DEDENT while b > 0: NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def constructArr(arr, pair, n): NEW_LINE INDENT arr[0] = (pair[0] + pair[1] - pair[n-1]) // 2 NEW_LINE for i in range(1, n): NEW_LINE INDENT arr[i] = pair[i-1] - arr[0] NEW_LINE DEDENT NEW_LINE DEDENT
def findMaximum(arr, low, high): NEW_LINE INDENT max = arr[low] NEW_LINE for i in range(low, high + 1): NEW_LINE INDENT if arr[i] > max: NEW_LINE INDENT max = arr[i] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def minimum_cost(a, n): NEW_LINE INDENT mn = float('inf') NEW_LINE sum = 0 NEW_LINE for i in range(n): NEW_LINE INDENT mn = min(a[i], mn) NEW_LINE sum += a[i] NEW_LINE DEDENT return mn * (sum - mn) NEW_LINE DEDENT
def decToBin(n): NEW_LINE INDENT if n == 0: return "0" NEW_LINE bin = "" NEW_LINE while n > 0: NEW_LINE INDENT bin = ('0' if (n & 1) == 0 else '1') + bin NEW_LINE n >>= 1 NEW_LINE DEDENT return bin.strip() NEW_LINE DEDENT
def isInorder(arr, n): NEW_LINE INDENT if n == 0 or n == 1: NEW_LINE INDENT return True NEW_LINE DEDENT for i in range(1, n): NEW_LINE INDENT if arr[i-1] > arr[i]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def shuffle(card, n): NEW_LINE INDENT import random NEW_LINE for i in range(n): NEW_LINE INDENT r = i + random.randint(0, 51 - i) NEW_LINE temp = card[r] NEW_LINE card[r] = card[i] NEW_LINE card[i] = temp NEW_LINE DEDENT NEW_LINE DEDENT
def mirrorImage(a, b, c, x1, y1): NEW_LINE INDENT temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return (x, y) NEW_LINE DEDENT
def numberOfWays(x): NEW_LINE INDENT dp = [0] * (x + 1) NEW_LINE dp[0], dp[1] = 1, 1 NEW_LINE for i in range(2, x + 1): NEW_LINE INDENT dp[i] = dp[i - 1] + (i - 1) * dp[i - 2] NEW_LINE DEDENT return dp[x] NEW_LINE DEDENT
def leonardo(n): NEW_LINE INDENT dp = [1] * (n + 1) NEW_LINE if n > 0: dp[1] = 1 NEW_LINE for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + 1 NEW_LINE return dp[n] NEW_LINE DEDENT
def CountPairs(n): NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while imin <= n: NEW_LINE INDENT imax = n // k NEW_LINE ans += k * (imax - imin + 1) NEW_LINE imin = imax + 1 NEW_LINE k = n // imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lastPosition(n, m, k): NEW_LINE INDENT if m <= n - k + 1: return m + k - 1 NEW_LINE m = m - (n - k + 1) NEW_LINE return n if m % n == 0 else m % n NEW_LINE DEDENT
def kthdigit(a, b, k): NEW_LINE INDENT p = int(a ** b) NEW_LINE count = 0 NEW_LINE while p > 0 and count < k: NEW_LINE INDENT rem = p % 10 NEW_LINE count += 1 NEW_LINE if count == k: NEW_LINE INDENT return rem NEW_LINE DEDENT p = p // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def splitArr(arr, n, k): NEW_LINE INDENT for i in range(k): NEW_LINE INDENT x = arr[0] NEW_LINE for j in range(n-1): NEW_LINE INDENT arr[j] = arr[j+1] NEW_LINE DEDENT arr[n-1] = x NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def rotateMatrix(mat): NEW_LINE INDENT for i in range(len(mat)-1, -1, -1): NEW_LINE INDENT for j in range(len(mat[0])-1, -1, -1): NEW_LINE INDENT print(mat[i][j], end=" ▁ ") NEW_LINE DEDENT print() NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def russianPeasant(a, b): NEW_LINE INDENT res = 0 NEW_LINE while b > 0: NEW_LINE INDENT if b & 1: NEW_LINE INDENT res += a NEW_LINE DEDENT a <<= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def findDigits(n): NEW_LINE INDENT if n < 0: return 0 NEW_LINE if n <= 1: return 1 NEW_LINE digits = 0 NEW_LINE for i in range(2, n + 1): NEW_LINE INDENT digits += math.log10(i) NEW_LINE DEDENT return int(math.floor(digits)) + 1 NEW_LINE DEDENT
def swapDiagonal(matrix): NEW_LINE INDENT N = len(matrix) NEW_LINE for i in range(N): NEW_LINE INDENT temp = matrix[i][i] NEW_LINE matrix[i][i] = matrix[i][N - i - 1] NEW_LINE matrix[i][N - i - 1] = temp NEW_LINE DEDENT NEW_LINE DEDENT
def checkMarkov(m): NEW_LINE INDENT for i in range(len(m)): NEW_LINE INDENT sum = 0 NEW_LINE for j in range(len(m[i])): NEW_LINE INDENT sum += m[i][j] NEW_LINE DEDENT if sum != 1: NEW_LINE INDENT return False NEW_LINE DEDENT NEW_LINE DEDENT return True NEW_LINE DEDENT
def search(arr, n, x): NEW_LINE INDENT i = 0 NEW_LINE while i <= n - 1: NEW_LINE INDENT if arr[i] == x: return i NEW_LINE i += abs(arr[i] - x) NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def findMinSum(a, b, n): NEW_LINE INDENT a.sort() NEW_LINE b.sort() NEW_LINE sum = 0 NEW_LINE for i in range(int(n)): NEW_LINE INDENT sum += abs(a[i] - b[i]) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxPrefix(s, t): NEW_LINE INDENT count = 0 NEW_LINE for i in range(len(t)): NEW_LINE INDENT if count == len(t): break NEW_LINE if t[i] == s[count]: count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def transpose(A): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(i+1, len(A)): NEW_LINE INDENT temp = A[i][j] NEW_LINE A[i][j] = A[j][i] NEW_LINE A[j][i] = temp NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findMinDiff(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE diff = float('inf') NEW_LINE for i in range(n - 1): NEW_LINE INDENT if arr[i + 1] - arr[i] < diff: NEW_LINE INDENT diff = arr[i + 1] - arr[i] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def countSquares(a, b): NEW_LINE INDENT cnt = 0 NEW_LINE for i in range(a, b+1): NEW_LINE INDENT for j in range(1, int(i**0.5)+1): NEW_LINE INDENT if j * j == i: NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def count_of_ways(n): NEW_LINE INDENT count = 0 NEW_LINE for i in range(n + 1): NEW_LINE INDENT for j in range(n + 1): NEW_LINE INDENT for k in range(n + 1): NEW_LINE INDENT if i + j + k == n: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def findHeight(parent, n): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT p, current = i, 1 NEW_LINE while parent[p] != -1: NEW_LINE INDENT current += 1 NEW_LINE p = parent[p] NEW_LINE DEDENT res = max(res, current) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countFriendsPairings(n): NEW_LINE INDENT if n <= 2: NEW_LINE INDENT return n NEW_LINE DEDENT a, b, c = 1, 2, 0 NEW_LINE for i in range(3, n + 1): NEW_LINE INDENT c = b + (i - 1) * a NEW_LINE a, b = b, c NEW_LINE DEDENT return c NEW_LINE DEDENT
def numofsubset(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE count = 1 NEW_LINE for i in range(n - 1): NEW_LINE INDENT if arr[i] + 1 != arr[i + 1]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def print_fibonacci_numbers(n): NEW_LINE INDENT if n < 1: return NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT print(f"{f2} ▁ ", end="") NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT NEW_LINE DEDENT
def exponentiation(base, exp): NEW_LINE INDENT t = 1 NEW_LINE while exp > 0: NEW_LINE INDENT if exp % 2 != 0: NEW_LINE INDENT t = (t * base) % N NEW_LINE DEDENT base = (base * base) % N NEW_LINE exp //= 2 NEW_LINE DEDENT return t % N NEW_LINE DEDENT
def countSolutions(n): NEW_LINE INDENT res = 0 NEW_LINE for x in range(n): NEW_LINE INDENT if x * x >= n: break NEW_LINE for y in range(n): NEW_LINE INDENT if x * x + y * y >= n: break NEW_LINE res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
import random NEW_LINE def randomize(arr, n): NEW_LINE INDENT for i in range(n-1, 0, -1): NEW_LINE INDENT j = random.randint(0, i) NEW_LINE arr[i], arr[j] = arr[j], arr[i] NEW_LINE DEDENT print(arr) NEW_LINE DEDENT
def isDivisibleBy7(num): NEW_LINE INDENT if num < 0: return isDivisibleBy7(-num) NEW_LINE if num == 0 or num == 7: return True NEW_LINE if num < 10: return False NEW_LINE return isDivisibleBy7(num // 10 - 2 * (num % 10)) NEW_LINE DEDENT
def moduloMultiplication(a, b, mod): NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b > 0: NEW_LINE INDENT if b & 1: NEW_LINE INDENT res = (res + a) % mod NEW_LINE DEDENT a = (2 * a) % mod NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def maximizecube(l, b, h): NEW_LINE INDENT side = gcd(l, gcd(b, h)) NEW_LINE num = l // side NEW_LINE num = (num * b // side) NEW_LINE num = (num * h // side) NEW_LINE print(f"{side} ▁ {num}") NEW_LINE DEDENT
def recSearch(arr, l, r, x): NEW_LINE INDENT if r < l: NEW_LINE INDENT return -1 NEW_LINE DEDENT if arr[l] == x: NEW_LINE INDENT return l NEW_LINE DEDENT if arr[r] == x: NEW_LINE INDENT return r NEW_LINE DEDENT return recSearch(arr, l + 1, r - 1, x) NEW_LINE DEDENT
def eulerian(n, m): NEW_LINE INDENT if m >= n or n == 0: return 0 NEW_LINE if m == 0: return 1 NEW_LINE return (n - m) * eulerian(n - 1, m - 1) + (m + 1) * eulerian(n - 1, m) NEW_LINE DEDENT
def minLexRotation(str): NEW_LINE INDENT n = len(str) NEW_LINE arr = [str[i:i+n] for i in range(n)] NEW_LINE arr.sort() NEW_LINE return arr[0] NEW_LINE DEDENT
def isPossible(a, b, n, k): NEW_LINE INDENT a.sort(reverse=True) NEW_LINE b.sort() NEW_LINE for i in range(n): NEW_LINE INDENT if a[i] + b[i] < k: NEW_LINE INDENT return False NEW_LINE DEDENT NEW_LINE DEDENT return True NEW_LINE DEDENT
def maxProduct(arr, n): NEW_LINE INDENT if n < 3: NEW_LINE INDENT return -1 NEW_LINE DEDENT arr.sort() NEW_LINE return max(arr[0] * arr[1] * arr[n-1], arr[n-1] * arr[n-2] * arr[n-3]) NEW_LINE DEDENT
def canMakeAllSame(str): NEW_LINE INDENT zeros, ones = 0, 0 NEW_LINE for ch in str: NEW_LINE INDENT if ch == '0': NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else: NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT return zeros == 1 or ones == 1 NEW_LINE DEDENT
def middleOfThree(a, b, c): NEW_LINE INDENT return b if ((a < b and b < c) or (c < b and b < a)) else a if ((b < a and a < c) or (c < a and a < b)) else c NEW_LINE DEDENT
def binaryToDecimal(n): NEW_LINE INDENT dec_value = 0 NEW_LINE base = 1 NEW_LINE for i in range(len(n)-1, -1, -1): NEW_LINE INDENT if n[i] == '1': NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base *= 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def minXOR(arr): NEW_LINE INDENT min_xor = float('inf') NEW_LINE for i in range(len(arr)): NEW_LINE INDENT for j in range(i + 1, len(arr)): NEW_LINE INDENT min_xor = min(min_xor, arr[i] ^ arr[j]) NEW_LINE DEDENT DEDENT DEDENT return min_xor NEW_LINE DEDENT
def mulmod(a, b, mod): NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while b > 0: NEW_LINE INDENT if b % 2 == 1: NEW_LINE INDENT res = (res + a) % mod NEW_LINE DEDENT a = (a * 2) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def nonFibonacci(n): NEW_LINE INDENT prevPrev, prev, curr = 1, 2, 3 NEW_LINE while n > 0: NEW_LINE INDENT prevPrev, prev = prev, curr NEW_LINE curr = prevPrev + prev NEW_LINE n -= curr - prev - 1 NEW_LINE DEDENT n += curr - prev - 1 NEW_LINE return prev + n NEW_LINE DEDENT
def multiply(x, y): NEW_LINE INDENT if y == 0: return 0 NEW_LINE if y > 0: return x + multiply(x, y - 1) NEW_LINE if y < 0: return -multiply(x, -y) NEW_LINE return -1 NEW_LINE DEDENT
def firstNonRepeating(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT for j in range(n): NEW_LINE INDENT if i != j and arr[i] == arr[j]: NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == n: NEW_LINE INDENT return arr[i] NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def countSubstringWithEqualEnds(s): NEW_LINE INDENT result = 0 NEW_LINE n = len(s) NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i, n): NEW_LINE INDENT if s[i] == s[j]: NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def countNegative(M, n, m): NEW_LINE INDENT count = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(m): NEW_LINE INDENT if M[i][j] < 0: NEW_LINE INDENT count += 1 NEW_LINE DEDENT else: NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countSeq(n): NEW_LINE INDENT nCr, res = 1, 1 NEW_LINE for r in range(1, n + 1): NEW_LINE INDENT nCr = (nCr * (n + 1 - r)) // r NEW_LINE res += nCr * nCr NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPrime(p): NEW_LINE INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range(1, p - 1): NEW_LINE INDENT nextval = (nextval * nextval - 2) % checkNumber NEW_LINE DEDENT return nextval == 0 NEW_LINE DEDENT
def minXOR(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE minXor = float('inf') NEW_LINE val = 0 NEW_LINE for i in range(n - 1): NEW_LINE INDENT val = arr[i] ^ arr[i + 1] NEW_LINE minXor = min(minXor, val) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
def binarySearch(arr, x): NEW_LINE INDENT l, r = 0, len(arr) - 1 NEW_LINE while l <= r: NEW_LINE INDENT m = l + (r - l) // 2 NEW_LINE if arr[m] == x: NEW_LINE INDENT return m NEW_LINE DEDENT if arr[m] < x: NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else: NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def countIntegralSolutions(n): NEW_LINE INDENT result = 0 NEW_LINE for i in range(n + 1): NEW_LINE INDENT for j in range(n - i + 1): NEW_LINE INDENT for k in range(n - i - j + 1): NEW_LINE INDENT if i + j + k == n: NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def power(x, y, p): NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0: NEW_LINE INDENT if y & 1: NEW_LINE INDENT res = (res * x) % p NEW_LINE DEDENT y >>= 1 NEW_LINE x = (x * x) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def minPerimeter(n): NEW_LINE INDENT l = int(n ** 0.5) NEW_LINE sq = l * l NEW_LINE if sq == n: NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else: NEW_LINE INDENT row = n // l NEW_LINE perimeter = 2 * (l + row) NEW_LINE if n % l != 0: NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT
def numberOfPaths(m, n): NEW_LINE INDENT dp = [1] + [0] * (n - 1) NEW_LINE for i in range(m): NEW_LINE INDENT for j in range(1, n): NEW_LINE INDENT dp[j] += dp[j - 1] NEW_LINE DEDENT NEW_LINE DEDENT return dp[n - 1] NEW_LINE DEDENT
def isPowerOfFour(n): NEW_LINE INDENT count = 0 NEW_LINE x = n & (n - 1) NEW_LINE if n > 0 and x == 0: NEW_LINE INDENT while n > 1: NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 if (count % 2 == 0) else 0 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def subArray(n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT for j in range(i, n): NEW_LINE INDENT for k in range(i, j + 1): NEW_LINE INDENT print(arr[k], end=" ▁ ") NEW_LINE DEDENT NEW_LINE DEDENT NEW_LINE DEDENT NEW_LINE DEDENT
def countDivisibles(arr, n): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def findCombinations(str, index, out): NEW_LINE INDENT if index == len(str): NEW_LINE INDENT print(out) NEW_LINE DEDENT for i in range(index, len(str)): NEW_LINE INDENT findCombinations(str, i + 1, out + " ( " + str[index:i + 1] + " ) ") NEW_LINE DEDENT NEW_LINE DEDENT
def decToBinary(n): NEW_LINE INDENT binaryNum = [0] * 32 NEW_LINE i = 0 NEW_LINE while n > 0: NEW_LINE INDENT binaryNum[i] = n % 2 NEW_LINE n //= 2 NEW_LINE i += 1 NEW_LINE DEDENT for j in range(i - 1, -1, -1): NEW_LINE INDENT print(binaryNum[j], end='') NEW_LINE DEDENT NEW_LINE DEDENT
def printDistinct(arr): NEW_LINE INDENT set = set() NEW_LINE for i in arr: NEW_LINE INDENT if i not in set: NEW_LINE INDENT set.add(i) NEW_LINE print(i, end=' ▁ ') NEW_LINE DEDENT DEDENT NEW_LINE DEDENT DEDENT
def nearestSmallerEqFib(n): NEW_LINE INDENT if n == 0 or n == 1: return n NEW_LINE f1, f2, f3 = 0, 1, 1 NEW_LINE while f3 <= n: NEW_LINE INDENT f1, f2 = f2, f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return f2 NEW_LINE DEDENT
def maxTasks(high, low, n): NEW_LINE INDENT return 0 if n <= 0 else max(high[n-1] + maxTasks(high, low, n-2), low[n-1] + maxTasks(high, low, n-1)) NEW_LINE DEDENT
def sequence(n): NEW_LINE INDENT f = [0, 1, 1] + [0] * (n - 2) NEW_LINE for i in range(3, n + 1): NEW_LINE INDENT f[i] = f[f[i - 1]] + f[i - f[i - 1]] NEW_LINE DEDENT return f[n] NEW_LINE DEDENT
def maxGameByWinner(N): NEW_LINE INDENT dp = [0] * (N + 1) NEW_LINE dp[0], dp[1] = 1, 2 NEW_LINE i = 2 NEW_LINE while True: NEW_LINE INDENT dp[i] = dp[i - 1] + dp[i - 2] NEW_LINE if dp[i] > N: NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i - 2 NEW_LINE DEDENT
def abFree(s): NEW_LINE INDENT b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range(len(s)): NEW_LINE INDENT if s[len(s) - i - 1] == 'a': NEW_LINE INDENT res += b_count NEW_LINE b_count *= 2 NEW_LINE DEDENT else: NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printDistinct(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT for j in range(i): NEW_LINE INDENT if arr[i] == arr[j]: NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == j: NEW_LINE INDENT print(arr[i], end=" ▁ ") NEW_LINE DEDENT DEDENT DEDENT
def findElements(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT count = 0 NEW_LINE for j in range(n): NEW_LINE INDENT if arr[j] > arr[i]: count += 1 NEW_LINE DEDENT if count >= 2: print(arr[i], "▁", end=" ") NEW_LINE DEDENT NEW_LINE DEDENT
def isIdentity(mat, N): NEW_LINE INDENT for row in range(N): NEW_LINE INDENT for col in range(N): NEW_LINE INDENT if (row == col and mat[row][col] != 1) or (row != col and mat[row][col] != 0): NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def insertSorted(arr, n, key, capacity): NEW_LINE INDENT if n >= capacity: return n NEW_LINE for i in range(n-1, -1, -1): NEW_LINE INDENT if arr[i] > key: arr[i + 1] = arr[i] NEW_LINE else: break NEW_LINE DEDENT arr[i + 1] = key NEW_LINE return n + 1 NEW_LINE DEDENT
def solve(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE a, b = 0, 0 NEW_LINE for i in range(n): NEW_LINE INDENT if i % 2 != 0: NEW_LINE INDENT a = a * 10 + arr[i] NEW_LINE DEDENT else: NEW_LINE INDENT b = b * 10 + arr[i] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def findMinX(num, rem, k): NEW_LINE INDENT x = 1 NEW_LINE while True: NEW_LINE INDENT for j in range(k): NEW_LINE INDENT if x % num[j] != rem[j]: NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == k: NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT
def countNegative(M, n, m): NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n: NEW_LINE INDENT if M[i][j] < 0: NEW_LINE INDENT count += j + 1 NEW_LINE i += 1 NEW_LINE DEDENT else: NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def to_upper(in_arr): NEW_LINE INDENT for i in range(len(in_arr)): NEW_LINE INDENT if 'a' <= in_arr[i] <= 'z': NEW_LINE INDENT in_arr[i] = chr(ord(in_arr[i]) - ord('a') + ord('A')) NEW_LINE DEDENT DEDENT DEDENT return ''.join(in_arr) NEW_LINE DEDENT
def countPairsWithDiffK(arr, n, k): NEW_LINE INDENT count = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if abs(arr[i] - arr[j]) == k: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def checkIsAP(arr, n): NEW_LINE INDENT if n == 1: return True NEW_LINE arr.sort() NEW_LINE d = arr[1] - arr[0] NEW_LINE for i in range(2, n): NEW_LINE INDENT if arr[i] - arr[i - 1] != d: return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def insertionSortRecursive(arr, n): NEW_LINE INDENT if n <= 1: NEW_LINE INDENT return NEW_LINE DEDENT insertionSortRecursive(arr, n-1) NEW_LINE last = arr[n-1] NEW_LINE j = n - 2 NEW_LINE while j >= 0 and arr[j] > last: NEW_LINE INDENT arr[j+1] = arr[j] NEW_LINE j -= 1 NEW_LINE DEDENT arr[j+1] = last NEW_LINE DEDENT
