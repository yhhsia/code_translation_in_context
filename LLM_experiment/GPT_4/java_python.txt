def areaSquare(side): INDENT return side * side NEW_LINE DEDENT
def fun(n): INDENT return n & (n - 1) NEWLINE DEDENT
def intersection(n): INDENT return n * (n - 1) NEW_LINE DEDENT
def hexagonalNum(n): INDENT return n * (2 * n - 1) NEW_LINE DEDENT
def cassini(n): INDENT return -1 if n & 1 else 1 NEW_LINE DEDENT
def addOne(x): INDENT return -(~x) NEW_LINE DEDENT
def mergeTwoHalf(A, n):INDENT A.sort()NEW_LINE DEDENT
def find_Area(r): INDENT return 2 * r * r NEW_LINE DEDENT
def check(n): INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def isEven(n): INDENT return n % 2 == 0 NEW_LINE DEDENT
def pentagonal_num(n): INDENT return (3 * n * n - n) // 2 NEW_LINE DEDENT 
def circumference(r): INDENT PI = 3.1415 NEW_LINE cir = 2 * PI * r NEW_LINE return cir NEW_LINE DEDENT
def numberOfSticks(x): INDENT return (3 * x * (x + 1)) // 2 NEW_LINE DEDENT
def binomialCoeffSum(n): INDENT return 1 << n NEW_LINE DEDENT
def largest(arr, n): INDENT return sorted(arr)[n-1] DEDENT NEW_LINE DEDENT
def Circumference(a): INDENT return 4 * a NEW_LINE DEDENT
def rangeGCD(n, m): INDENT return n if n == m else 1 NEW_LINE DEDENT
def power(n): INDENT if n == 1: return 2 NEW_LINE return 2 * power(n - 1) NEW_LINE DEDENT
def compute_average(a, b): INDENT return (a + b) // 2 NEW_LINE DEDENT
def summingSeries(n): INDENT return int(n**2) NEW_LINE DEDENT
def multiplyWith3Point5(x): INDENT return (x << 1) + x + (x >> 1) NEW_LINE DEDENT
def isEven(n): INDENT if (n & 1) == 0: return True NEW_LINE else: return False DEDENT NEW_LINE DEDENT
def factorial(n): NEW_LINE INDENT if n == 0: return 1 NEW_LINE return n * factorial(n - 1) NEW_LINE DEDENT
def slope(x1, y1, x2, y2): INDENT return (y2 - y1) / (x2 - x1) NEW_LINE DEDENT
def getModulo(n, d): NEW_LINE INDENT return n & (d - 1) NEW_LINE DEDENT
def oppositeSigns(x, y): INDENT return (x ^ y) < 0 NEW_LINE DEDENT
def height(N): INDENT return int((N + 1).bit_length()) - 1 DEDENT NEW_LINE DEDENT
def swapNibbles(x): INDENT return ((x & 0x0F) << 4 | (x & 0xF0) >> 4) NEWLINE DEDENT
def factorial(n): INDENT if n == 0: return 1 NEW_LINE return n * factorial(n - 1) DEDENT NEWLINE DEDENT
def countNonEmptySubstr(str): INDENT n = len(str) NEW_LINE return n * (n + 1) // 2 NEW_LINE DEDENT
def nthTerm(n): INDENT return (n * n) + (n * n * n) NEW_LINE DEDENT 
def getRemainder(num, divisor): INDENT return num - divisor * (num // divisor) NEW_LINE DEDENT
def findMaximumPieces(n): INDENT return 1 + n * (n + 1) // 2 NEWLINE DEDENT
max_ref = 1 NEW_LINE def lis(arr): NEW_LINE INDENT global max_ref NEW_LINE _lis(arr, len(arr)) NEW_LINE return max_ref NEW_LINE DEDENT 
def gcd(a, b): INDENT if a == 0: return b NEW_LINE return gcd(b % a, a) DEDENT NEW_LINE DEDENT
def rectCount(n, m): NEW_LINE INDENT return (m * n * (n + 1) * (m + 1)) // 4 NEW_LINE DEDENT
def evenbinomialCoeffSum(n): INDENT return (1 << (n - 1)) NEWLINE DEDENT
def count_of_ways(n): INDENT count = 0 NEW_LINE count = (n + 1) * (n + 2) // 2 NEW_LINE return count NEWLINE DEDENT
def isMultipleOf10(n): INDENT if n % 15 == 0: return True NEW_LINE return False DEDENT
def areaOctagon(side): INDENT return 2 * (1 + math.sqrt(2)) * side * side NEW_LINE DEDENT
def findSum(n): INDENT return n * (n + 1) * (n + 2) * (3 * n + 1) // 24 NEW_LINE DEDENT
def reverse(str): INDENT n = len(str) NEW_LINE for i in range(n // 2): INDENT swap(str, i, n - i - 1) DEDENT NEWLINE DEDENT
def sortit(arr, n): INDENT for i in range(n): INDENT arr[i] = i + 1 NEW_LINE DEDENT DEDENT
def factorial(n): INDENT res, i = 1, 2 NEW_LINE while i <= n: INDENT res *= i NEW_LINE i += 1 DEDENT return res NEW_LINE DEDENT
def surface_area_octahedron(side): INDENT return 2 * (3**0.5) * (side * side) NEW_LINE DEDENT
def Resources(process, need): INDENT minResources = process * (need - 1) + 1 NEW_LINE return minResources DEDENT
def volume_of_ellipsoid(r1, r2, r3): NEW_LINE INDENT pi = 3.14 NEW_LINE return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT
def procal(n): INDENT return (3.0 * n) / (4.0 * (n * n) - 1) NEW_LINE DEDENT
def vol_of_octahedron(side): INDENT return (side ** 3) * (math.sqrt(2) / 3) NEW_LINE DEDENT
def countSetBits(n): INDENT count = 0 NEW_LINE while n > 0: INDENT n &= (n - 1) NEW_LINE count += 1 DEDENT NEW_LINE return count DEDENT
def calculateSum(n): INDENT return (1 << n) - 1 NEWLINE DEDENT
def isPowerOfTwo(x): INDENT return x != 0 and (x & (x - 1)) == 0 NEW_LINE DEDENT
def assignValue(a, b, x): INDENT return [a, b][x] NEW_LINE DEDENT
def kthSmallest(arr, k): INDENT arr.sort() NEW_LINE return arr[k-1] NEW_LINE DEDENT
def lis(arr, n): INDENT global max_ref NEW_LINE max_ref = 1 NEW_LINE _lis(arr, n) NEW_LINE return max_ref NEW_LINE DEDENT
def sumOfSeries(n): INDENT return 0.666 * (1 - 1 / 10**n) NEW_LINE DEDENT
def countSetBits(n): NEW_LINE INDENT if n == 0: return 0 NEW_LINE else: return 1 + countSetBits(n & (n - 1)) NEWLINE DEDENT
def repeat(s, n): INDENT s1 = s NEW_LINE for i in range(1, n): INDENT s += s1 DEDENT NEW_LINE return s DEDENT
def countSetBits(n): INDENT if n == 0: return 0 NEW_LINE else: return (n & 1) + countSetBits(n >> 1) NEW_LINE DEDENT
def bin(n): INDENT if n > 1: INDENT bin(n >> 1) DEDENT print(f"{n & 1}", end=" ") DEDENT NEW_LINE DEDENT
def printSubStr(str, low, high): INDENT print(str[low:high+1]) NEWLINE DEDENT 
def getAbs(n): INDENT mask = n >> (32 * 8 - 1); return (n + mask) ^ mask NEWLINE DEDENT
def maxSquare(b, m): INDENT return (b // m - 1) * (b // m) // 2 NEW_LINE DEDENT
def getArea(a): INDENT return (3.14159 * a * a) / 4 NEW_LINE DEDENT
def minSum(A, n): INDENT return min(A) * (n - 1) NEW_LINE DEDENT 
def countStr(n): INDENT return 1 + (n * 2) + (n * ((n * n) - 1) / 2) NEW_LINE DEDENT
def turnOffK(n, k): INDENT if k <= 0: return n NEW_LINE return n & ~(1 << (k - 1)) DEDENT
def yMod(y, x): INDENT if (math.log(y) / math.log(2)) < x: return y NEW_LINE if x > 63: return y NEW_LINE return y % (1 << int(x)) NEW_LINE DEDENT
def search(arr, x): INDENT n = len(arr) NEW_LINE for i in range(n): INDENT if arr[i] == x: return i DEDENT NEW_LINE return -1 DEDENT
def fib(n): INDENT if n <= 1: return n NEW_LINE return fib(n - 1) + fib(n - 2) NEW_LINE DEDENT
def maxTripletSum(arr): INDENT return sum(sorted(arr)[-3:]) NEW_LINE DEDENT
def isNumber(s): NEW_LINE INDENT for i in range(len(s)): NEW_LINE INDENT if not s[i].isdigit(): return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def divisorSum(n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT sum += (n // i) * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def addOne(x): INDENT m = 1 NEW_LINE while (x & m) >= 1: INDENT x = x ^ m NEW_LINE m <<= 1 DEDENT x = x ^ m NEW_LINE return x NEWLINE DEDENT
def findRepeating(arr, n): INDENT sum = 0 NEW_LINE for i in range(n): INDENT sum += arr[i] DEDENT NEW_LINE return sum - ((n - 1) * n) // 2 DEDENT
def findSum(N, K): INDENT ans = 0 NEW_LINE for i in range(1, N + 1): INDENT ans += i % K DEDENT NEW_LINE return ans DEDENT
def isPrime(n): INDENT if n <= 1: return False NEW_LINE for i in range(2, n): INDENT if n % i == 0: return False DEDENT NEW_LINE return True DEDENT
def isPossible(str, n): INDENT len = len(str) NEW_LINE if len >= n: return True NEW_LINE return False NEW_LINE DEDENT
def getOddOccurrence(ar, ar_size): NEW_LINE INDENT res = 0 NEW_LINE for i in range(ar_size): NEW_LINE INDENT res ^= ar[i] NEW_LINE DEDENT return res NEW_LINE DEDENT
def findArea(a): NEW_LINE INDENT area = (5 * (5 + 2 * (5**0.5))**0.5) * a * a / 4 NEW_LINE return area NEW_LINE DEDENT
def printArray(a, n): INDENT for i in range(n): INDENT print(a[i], end=" ▁ ") DEDENT print() DEDENT NEW_LINE DEDENT
def evenlength(n): INDENT res = n NEW_LINE for j in range(len(n) - 1, -1, -1): INDENT res += n[j] DEDENT NEW_LINE return res DEDENT
def sequence(n): INDENT if n == 1 or n == 2: INDENT return 1 DEDENT else: INDENT return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1)) DEDENT NEW_LINE DEDENT
def nextPowerOf2(n): INDENT p = 1 NEW_LINE if n > 0 and (n & (n - 1)) == 0: INDENT return n DEDENT while p < n: INDENT p <<= 1 DEDENT return p NEW_LINE DEDENT
def isPowerOfFour(n: int) -> bool: NEW_LINE INDENT return n != 0 and (n & (n - 1)) == 0 and (n & 0xAAAAAAAA) == 0 NEWLINE DEDENT
def nswp(n): INDENT if n == 0 or n == 1: return 1 NEW_LINE return 2 * nswp(n - 1) + nswp(n - 2) DEDENT
def findTrailingZeros(n): INDENT count = 0 NEW_LINE for i in range(5, n+1, 5): INDENT count += n // i DEDENT return count NEWLINE DEDENT
def find(n, k): INDENT if n + 1 >= k: return k - 1 NEW_LINE else: return 2 * n + 1 - k NEW_LINE DEDENT
def leonardo(n): NEW_LINE INDENT if n == 0 or n == 1: return 1 NEW_LINE return leonardo(n - 1) + leonardo(n - 2) + 1 NEW_LINE DEDENT
def countSquares(a, b): INDENT return int(math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a)) + 1) NEW_LINE DEDENT
def countPaths(n, m): INDENT if n == 0 or m == 0: return 1 NEW_LINE return countPaths(n - 1, m) + countPaths(n, m - 1) NEWLINE DEDENT
def nextPowerOf2(n): INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEWLINE DEDENT
def vol_of_dodecahedron(side): INDENT return ((15 + (7 * (5 ** 0.5))) / 4) * (side ** 3) NEW_LINE DEDENT
def Largestpower(n, p): INDENT ans = 0 NEW_LINE while n > 0: INDENT n //= p NEW_LINE ans += n DEDENT NEW_LINE return ans DEDENT
def checkValidity(a, b, c): INDENT if a + b <= c or a + c <= b or b + c <= a: INDENT return 0 NEW_LINE DEDENT else: INDENT return 1 NEW_LINE DEDENT DEDENT
def PowerOFPINnfactorial(n, p): NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while temp <= n: NEW_LINE INDENT ans += n // temp NEW_LINE temp *= p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find_extra_element_index(arrA, arrB): INDENT extra_element = sum(arrA) - sum(arrB) NEW_LINE return arrA.index(extra_element) NEW_LINE DEDENT
def getMissingNo(a, n): INDENT total = (n + 1) * (n + 2) // 2 NEW_LINE for i in range(n): INDENT total -= a[i] DEDENT NEW_LINE return total DEDENT
def findLastIndex(str, x): NEW_LINE INDENT index = -1 NEW_LINE for i in range(len(str)): NEW_LINE INDENT if str[i] == x: NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findLastIndex(str, x): INDENT for i in range(len(str) - 1, -1, -1): INDENT if str[i] == x: return i NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def getMissingNo(a, n): INDENT total = 1 NEW_LINE for i in range(2, n + 2): INDENT total += i NEW_LINE total -= a[i - 2] DEDENT NEW_LINE return total DEDENT
def cost(a, n): INDENT min = a[0] NEW_LINE for i in range(1, len(a)): INDENT if a[i] < min: INDENT min = a[i] DEDENT DEDENT return (n - 1) * min DEDENT NEW_LINE DEDENT
def largest(): INDENT i = 1; max = arr[0]; NEW_LINE while i < len(arr): INDENT if arr[i] > max: INDENT max = arr[i] DEDENT i += 1 DEDENT return max NEW_LINE DEDENT
def printNos(n): NEW_LINE INDENT if n > 0: NEW_LINE INDENT printNos(n - 1) NEW_LINE print(n, end=' ▁ ') NEW_LINE DEDENT return NEW_LINE DEDENT 
def numberOfPaths(m, n): NEW_LINE INDENT if m == 1 or n == 1: return 1 NEW_LINE return numberOfPaths(m - 1, n) + numberOfPaths(m, n - 1) NEW_LINE DEDENT
def maxvolume(s): INDENT length = s // 3 NEW_LINE s -= length NEW_LINE breadth = s // 2 NEW_LINE height = s - breadth NEW_LINE return length * breadth * height NEWLINE DEDENT
def findLarger(arr, n): INDENT arr.sort() NEW_LINE for i in range(n-1, n//2-1, -1): INDENT print(arr[i], end=" ▁ ") NEW_LINE DEDENT DEDENT
def playGame(arr): INDENT set = set(arr) NEW_LINE return 1 if len(set) % 2 == 0 else 2 NEW_LINE DEDENT
def leftRotate(arr, n, k): NEW_LINE INDENT for i in range(k, k + n): NEW_LINE INDENT print(arr[i % n], end=" ▁ ") NEW_LINE DEDENT DEDENT
def horner(poly, n, x): NEW_LINE INDENT result = poly[0] NEW_LINE for i in range(1, n): NEW_LINE INDENT result = result * x + poly[i] NEW_LINE DEDENT return result NEW_LINE DEDENT
def findSum(n): INDENT sum = 0 NEW_LINE for i in range(1, n+1): INDENT for j in range(i, n+1): INDENT sum += i * j DEDENT DEDENT return sum NEW_LINE DEDENT
def doublefactorial(n): INDENT res = 1 NEW_LINE for i in range(n, -1, -2): INDENT if i == 0 or i == 1: return res NEW_LINE else: res *= i DEDENT NEW_LINE return res DEDENT
def printFun(test): INDENT if test < 1: return NEW_LINE print(f"{test} ▁ ", end='') NEW_LINE printFun(test - 1) NEW_LINE print(f"{test} ▁ ", end='') NEW_LINE return DEDENT
def exponential(n, x): INDENT sum = 1 NEW_LINE for i in range(n - 1, 0, -1): INDENT sum = 1 + x * sum / i DEDENT NEW_LINE return sum DEDENT
def squareRoot(n): INDENT x = n NEW_LINE y = 1 NEW_LINE e = 0.000001 NEW_LINE while x - y > e: INDENT x = (x + y) / 2 NEW_LINE y = n / x DEDENT NEW_LINE return x DEDENT
def printFactorialNums(n): INDENT fact = 1; x = 2 NEW_LINE while fact <= n: INDENT print(fact, end=' ▁ ') NEW_LINE fact *= x NEW_LINE x += 1 DEDENT NEWLINE DEDENT
def divisibleBy20(num): INDENT lastTwoDigits = int(num[-2:]) NEW_LINE return (lastTwoDigits % 5 == 0) and (lastTwoDigits % 4 == 0) NEW_LINE DEDENT
def floorSqrt(x): NEW_LINE INDENT if x == 0 or x == 1: return x NEW_LINE i, result = 1, 1 NEW_LINE while result <= x: NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def search(arr, n, x): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def modInverse(a, m): INDENT a = a % m NEW_LINE for x in range(1, m): INDENT if (a * x) % m == 1: return x NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def count(s, c): INDENT res = 0 NEW_LINE for i in range(len(s)): INDENT if s[i] == c: INDENT res += 1 DEDENT DEDENT return res NEW_LINE DEDENT
def sumOfSeries(n): INDENT sum = 0 NEW_LINE for i in range(1, n+1): INDENT sum += (2*i - 1) * (2*i - 1) DEDENT NEW_LINE return sum DEDENT
def nextPowerOf2(n): INDENT if n > 0 and (n & (n - 1)) == 0: return n NEW_LINE count = 0 NEW_LINE while n != 0: INDENT n >>= 1 NEW_LINE count += 1 DEDENT NEW_LINE return 1 << count DEDENT
def isPower(x, y): NEW_LINE INDENT if x == 1: return y == 1 NEW_LINE pow = 1 NEW_LINE while pow < y: pow *= x NEW_LINE return pow == y NEW_LINE DEDENT
def allCharactersSame(s): INDENT n = len(s) NEW_LINE for i in range(1, n): INDENT if s[i] != s[0]: INDENT return False DEDENT NEW_LINE return True DEDENT NEW_LINE DEDENT
def center(x1, x2, y1, y2): INDENT print(((x1 + x2) / 2), ',', ((y1 + y2) / 2)) NEW_LINE DEDENT
def kthgroupsum(k): NEW_LINE INDENT cur = (k * (k - 1)) + 1 NEW_LINE sum = 0 NEW_LINE while k > 0: NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getSum(n): INDENT sum = 0 NEW_LINE while n != 0: INDENT sum = sum + n % 10 NEW_LINE n = n // 10 DEDENT NEW_LINE return sum DEDENT
def spiralDiaSum(n): INDENT if n == 1: return 1 NEW_LINE return (4 * n * n - 6 * n + 6 + spiralDiaSum(n - 2)) DEDENT NEW_LINE DEDENT
def isDivisible(n): INDENT while n / 100 > 0: INDENT last_digit = int(n % 10) NEW_LINE n //= 10 NEW_LINE n += last_digit * 3 DEDENT NEW_LINE return n % 29 == 0 DEDENT
def countOccurrences(arr, n, x): INDENT res = 0 NEW_LINE for i in range(n): INDENT if x == arr[i]: INDENT res += 1 DEDENT DEDENT return res NEW_LINE DEDENT
def Right_most_setbit(num): INDENT pos = 1 NEW_LINE for i in range(32): INDENT if (num & (1 << i)) == 0: INDENT pos += 1 DEDENT else: INDENT break DEDENT DEDENT return pos NEW_LINE DEDENT
def nextPowerOf2(n): INDENT if n > 0 and (n & (n - 1)) == 0: return n NEW_LINE p = 1 NEW_LINE while p < n: INDENT p <<= 1 DEDENT NEW_LINE return p DEDENT
def numberOfPaths(m, n): INDENT path = 1 NEW_LINE for i in range(n, m + n - 1): INDENT path *= i NEW_LINE path /= (i - n + 1) DEDENT NEW_LINE return path DEDENT
def search(arr, n, x): INDENT for i in range(n): INDENT if arr[i] == x: INDENT return i DEDENT DEDENT return -1 DEDENT NEWLINE DEDENT
def isPerfectSquare(n): INDENT for sum, i in ((0, 1),): INDENT while sum < n: INDENT sum += i NEW_LINE i += 2 NEW_LINE if sum == n: INDENT return True DEDENT DEDENT DEDENT return False DEDENT NEWLINE DEDENT
def catalan(n): INDENT res = 0 NEW_LINE if n <= 1: INDENT return 1 DEDENT for i in range(n): INDENT res += catalan(i) * catalan(n - i - 1) DEDENT return res NEW_LINE DEDENT
def transpose(A, B): INDENT for i in range(N): NEW_LINE for j in range(N): NEW_LINE B[i][j] = A[j][i] NEW_LINE DEDENT NEW_LINE DEDENT
def first(str): NEW_LINE INDENT for i in range(len(str)): NEW_LINE INDENT if str[i].isupper(): NEW_LINE INDENT return str[i] NEW_LINE DEDENT DEDENT return '\0' NEW_LINE DEDENT
def rotate(): NEW_LINE INDENT x = arr[-1] NEW_LINE for i in range(len(arr) - 1, 0, -1): NEW_LINE INDENT arr[i] = arr[i - 1] NEW_LINE DEDENT arr[0] = x NEW_LINE DEDENT
def evenFib(n): NEW_LINE INDENT if n < 1: return n NEW_LINE if n == 1: return 2 NEW_LINE return (4 * evenFib(n - 1)) + evenFib(n - 2) NEW_LINE DEDENT
def kLargest(arr, k): INDENT arr.sort(reverse=True) NEW_LINE for i in range(k): INDENT print(arr[i], end=" ▁ ") DEDENT NEW_LINE DEDENT
def compute(a, b): INDENT AM, GM, HM = (a + b) / 2, (a * b)**0.5, ((a * b)**0.5)**2 / ((a + b) / 2) NEW_LINE return HM NEW_LINE DEDENT
def findS(s): INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s: INDENT sum += n * n NEW_LINE if sum == s: INDENT return n DEDENT n += 1 DEDENT return -1 DEDENT NEWLINE DEDENT
def isTriangular(num): INDENT if num < 0: return False NEW_LINE sum = 0 NEW_LINE for n in range(1, num+1): INDENT sum += n NEW_LINE if sum == num: return True NEW_LINE if sum > num: break DEDENT NEW_LINE return False DEDENT
def nextPowerOf2(n): INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def PowerOFPINnfactorial(n, p): INDENT ans = 0 NEW_LINE for i in range(1, n + 1): INDENT count, temp = 0, i NEW_LINE while temp % p == 0: INDENT count += 1 NEW_LINE temp //= p DEDENT DEDENT ans += count NEW_LINE return ans DEDENT NEWLINE DEDENT
def reverse(str): NEW_LINE INDENT if str == None or len(str) <= 1: NEW_LINE INDENT print(str) NEW_LINE DEDENT else: NEW_LINE INDENT print(str[-1], end='') NEW_LINE reverse(str[:-1]) NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def isPowerOfFour(n): INDENT if n == 0: return 0 NEW_LINE while n != 1: INDENT if n % 4 != 0: return 0 NEW_LINE n = n // 4 DEDENT NEW_LINE return 1 DEDENT
def isPowerOfTwo(n): INDENT if n == 0: INDENT return False DEDENT while n != 1: INDENT if n % 2 != 0: INDENT return False DEDENT n = n // 2 DEDENT return True NEWLINE DEDENT
def findMinZero(p): INDENT first, second, number, next = 1, 1, 2, 1 NEW_LINE while next > 0: INDENT next = (first + second) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def findExtra(arr1, arr2, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr1[i] != arr2[i]: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def countDigits(a, b): NEW_LINE INDENT if a == 0 or b == 0: return 1 NEW_LINE return int(math.floor(math.log10(abs(a)) + math.log10(abs(b)))) + 1 NEW_LINE DEDENT
def isPower(x, y): INDENT res1 = int(math.log(y) / math.log(x)) NEW_LINE res2 = math.log(y) / math.log(x) NEW_LINE return res1 == res2 NEW_LINE DEDENT
def smallest(x, y, z): INDENT c = 0 NEW_LINE while x != 0 and y != 0 and z != 0: INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 DEDENT return c NEWLINE DEDENT
def findS(s): INDENT sum = 0 NEW_LINE for n in range(1, s+1): INDENT sum += n ** 3 NEW_LINE if sum == s: INDENT return n DEDENT DEDENT return -1 DEDENT NEW_LINE DEDENT
def check(str): INDENT n = len(str) NEW_LINE digitSum = 0 NEW_LINE for i in range(n): INDENT digitSum += int(str[i]) - int('0') DEDENT NEW_LINE return digitSum % 9 == 0 DEDENT
def countDigits(a, b): INDENT count = 0 NEW_LINE p = abs(a * b) NEW_LINE if p == 0: return 1 NEW_LINE while p > 0: INDENT count += 1 NEW_LINE p //= 10 DEDENT NEW_LINE return count DEDENT
def answer_query(a, n, l, r): INDENT count = 0 NEW_LINE for i in range(l, r): INDENT if a[i] == a[i + 1]: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT
def swap(xp, yp): INDENT xp[0] = xp[0] ^ yp[0] NEW_LINE yp[0] = xp[0] ^ yp[0] NEW_LINE xp[0] = xp[0] ^ yp[0] NEW_LINE DEDENT
def findFrequency(arr, n, left, right, element): INDENT count = 0 NEW_LINE for i in range(left - 1, right): INDENT if arr[i] == element: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT
def lexsmallest(a, n): INDENT a.sort() NEW_LINE answer = "" NEW_LINE for i in range(n): INDENT answer += a[i] DEDENT NEW_LINE return answer DEDENT
def minSum(n): INDENT sum = 0 NEW_LINE while n > 0: INDENT sum += n % 10 NEW_LINE n //= 10 DEDENT NEW_LINE if sum == 1: INDENT return 10 DEDENT NEW_LINE return sum DEDENT NEW_LINE DEDENT 
def fib(n): NEW_LINE INDENT if n < 6: return f[n] NEW_LINE t = 5 NEW_LINE fn = 5 NEW_LINE while t < n: NEW_LINE INDENT fn = round(fn * PHI) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def check(degree, n): INDENT deg_sum = 0 NEW_LINE for i in range(n): INDENT deg_sum += degree[i] DEDENT return 2 * (n - 1) == deg_sum DEDENT NEW_LINE DEDENT
def squareRootExists(n, p): INDENT n = n % p NEW_LINE for x in range(2, p): INDENT if (x * x) % p == n: INDENT return True DEDENT DEDENT return False NEW_LINE DEDENT
def count(n, x): INDENT count = 0 NEW_LINE for i in range(1, min(n, x) + 1): INDENT if x // i <= n and x % i == 0: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT
def smallest(x, y, z): INDENT if (y // x) != 1: return y if (y // z) != 1 else z NEW_LINE return x if (x // z) != 1 else z NEW_LINE DEDENT
def binomialCoeff(n, k): NEW_LINE INDENT if k == 0 or k == n: return 1 NEW_LINE return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k) NEW_LINE DEDENT
def sumBetweenTwoKth(arr, k1, k2): INDENT arr.sort() NEW_LINE result = 0 NEW_LINE for i in range(k1, k2 - 1): INDENT result += arr[i] DEDENT NEW_LINE return result DEDENT
def decimalToBinary(N): INDENT B_Number = 0; cnt = 0 NEW_LINE while N != 0: INDENT rem = N % 2; c = int(10 ** cnt) NEW_LINE B_Number += rem * c; N //= 2; cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def isOneFlip(s): NEW_LINE INDENT sum = 0 NEW_LINE n = len(s) NEW_LINE for i in range(n): NEW_LINE INDENT sum += int(s[i]) - int('0') NEW_LINE DEDENT return sum == n - 1 or sum == 1 NEW_LINE DEDENT
def recursiveReverse(str, i): INDENT n = len(str) NEW_LINE if i == n // 2: INDENT return DEDENT swap(str, i, n - i - 1) NEW_LINE recursiveReverse(str, i + 1) NEWLINE DEDENT
def countNonDecreasing(n): INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range(1, n+1): INDENT count *= (N + i - 1) NEW_LINE count /= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def isPalindrome(str): INDENT l, h = 0, len(str) - 1 NEW_LINE while h > l: INDENT if str[l] != str[h]: INDENT return False NEW_LINE l += 1; h -= 1 DEDENT DEDENT return True DEDENT
def countSubStr(str, n): INDENT m = 0 NEW_LINE for i in range(n): INDENT if str[i] == '1': INDENT m += 1 DEDENT DEDENT return m * (m - 1) // 2 DEDENT NEW_LINE DEDENT
def findSum(n): INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += (n * (n + 1)) // 2 NEW_LINE sum += (n * (n + 1) * (2 * n + 1)) // 6 NEW_LINE return sum DEDENT NEWLINE DEDENT
def decToBinary(n): INDENT for i in range(31, -1, -1): INDENT k = n >> i; if (k & 1) > 0: INDENT print("1", end="") DEDENT else: INDENT print("0", end="") DEDENT DEDENT NEW_LINE DEDENT
def query(s, i, j): INDENT n = len(s) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE if s[i] == s[j]: INDENT print("Yes") DEDENT else: INDENT print("No") DEDENT DEDENT NEW_LINE DEDENT
def isDivBy9(n): NEW_LINE INDENT if n == 0 or n == 9: return True NEW_LINE if n < 9: return False NEW_LINE return isDivBy9((n >> 3) - (n & 7)) NEW_LINE DEDENT
def getInvCount(n): INDENT inv_count = 0 NEW_LINE for i in range(n - 1): INDENT for j in range(i + 1, n): INDENT if arr[i] > arr[j]: INDENT inv_count += 1 DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def isDivisible(str, k): NEW_LINE INDENT n = len(str) NEW_LINE c = 0 NEW_LINE for i in range(k): NEW_LINE INDENT if str[n - i - 1] == '0': c += 1 NEW_LINE DEDENT return c == k NEW_LINE DEDENT
def printSquares(n): INDENT square, odd = 0, 1 NEW_LINE for x in range(n): INDENT print(square, end=' ▁ ') NEW_LINE square += odd NEW_LINE odd += 2 DEDENT NEWLINE DEDENT
def breakSum(n): NEW_LINE INDENT if n == 0 or n == 1: return n NEW_LINE return max(breakSum(n // 2) + breakSum(n // 3) + breakSum(n // 4), n) NEW_LINE DEDENT
def findRotations(str): INDENT tmp = str + str NEW_LINE n = len(str) NEW_LINE for i in range(1, n + 1): INDENT substring = tmp[i:i + n] NEW_LINE if str == substring: return i NEW_LINE DEDENT return n NEW_LINE DEDENT
def fib(n): INDENT if lookup[n] == NIL: INDENT if n <= 1: INDENT lookup[n] = n DEDENT else: INDENT lookup[n] = fib(n - 1) + fib(n - 2) DEDENT DEDENT return lookup[n] DEDENT NEW_LINE DEDENT
def selectRandom(x): INDENT global count, res NEW_LINE count += 1 NEW_LINE if count == 1: INDENT res = x DEDENT else: INDENT r = random.Random() NEW_LINE i = r.randint(0, count - 1) NEW_LINE if i == count - 1: INDENT res = x DEDENT DEDENT return res NEW_LINE DEDENT
def isOverflow(a: int, b: int) -> bool: INDENT if a == 0 or b == 0: return False NEW_LINE result = a * b NEW_LINE if a == result // b: return False NEW_LINE else: return True NEW_LINE DEDENT
def findNth(n): INDENT nthElement = 19 + (n - 1) * 9 NEW_LINE outliersCount = int(math.log10(nthElement)) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def remainder(str): INDENT len = len(str) NEW_LINE num, rem = 0, 0 NEW_LINE for i in range(len): INDENT num = rem * 10 + (int(str[i]) - 0) NEW_LINE rem = num % 11 DEDENT NEW_LINE return rem DEDENT
def arcLength(diameter, angle): INDENT double pi = 22.0 / 7.0 NEW_LINE if angle >= 360: INDENT print("Angle cannot be formed") NEW_LINE return 0 NEW_LINE DEDENT else: INDENT arc = (pi * diameter) * (angle / 360.0) NEW_LINE return arc NEW_LINE DEDENT DEDENT
def countRect(n): INDENT ans = 0 NEW_LINE for length in range(1, int(n**0.5) + 1): INDENT for height in range(length, n//length + 1): INDENT ans += 1 DEDENT DEDENT return ans NEW_LINE DEDENT
def firstFactorialDivisibleNumber(x): INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range(1, x): INDENT fact *= i NEW_LINE if fact % x == 0: INDENT break DEDENT DEDENT return i NEW_LINE DEDENT
def gcd(a, b): NEW_LINE INDENT if a < b: return gcd(b, a) NEW_LINE if abs(b) < 0.001: return a NEW_LINE else: return gcd(b, a - (a // b) * b) NEW_LINE DEDENT DEDENT
def isPrime(n, i=2): NEW_LINE INDENT if n <= 2: return n == 2 NEW_LINE if n % i == 0: return False NEW_LINE if i * i > n: return True NEW_LINE return isPrime(n, i + 1) NEW_LINE DEDENT
def countPairs(arr, n): INDENT ans = 0 NEW_LINE for i in range(n): INDENT for j in range(i + 1, n): INDENT if arr[i] == arr[j]: INDENT ans += 1 DEDENT DEDENT DEDENT NEW_LINE return ans DEDENT
def countInRange(arr, n, x, y): INDENT count = 0 NEW_LINE for i in range(n): INDENT if x <= arr[i] <= y: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT
def isSymmetric(mat, N): INDENT for i in range(N): INDENT for j in range(N): INDENT if mat[i][j] != mat[j][i]: INDENT return False DEDENT DEDENT DEDENT return True DEDENT NEW_LINE DEDENT
def countCommon(mat, n): INDENT res = 0 NEW_LINE for i in range(n): INDENT if mat[i][i] == mat[i][n-i-1]: INDENT res += 1 DEDENT DEDENT return res NEW_LINE DEDENT
def first(str, i): NEW_LINE INDENT if str[i] == '\0': return 0 NEW_LINE if str[i].isupper(): return str[i] NEW_LINE return first(str, i + 1) NEW_LINE DEDENT
def findSum(n): INDENT multiTerms = n * (n + 1) // 2 NEW_LINE sum = multiTerms NEW_LINE for i in range(2, n + 1): INDENT multiTerms = multiTerms - (i - 1) NEW_LINE sum += multiTerms * i DEDENT NEW_LINE return sum DEDENT
def maxProd(n): INDENT if n == 2 or n == 3: return n - 1 NEW_LINE res = 1 NEW_LINE while n > 4: INDENT n -= 3 NEW_LINE res *= 3 DEDENT NEW_LINE return n * res DEDENT
def octalToDecimal(n): NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while temp > 0: NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = temp // 10 NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 8 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def minTime(arr, n, m): INDENT t = 0 NEW_LINE while True: INDENT items = 0 NEW_LINE for i in range(n): INDENT items += t // arr[i] DEDENT if items >= m: return t NEW_LINE t += 1 DEDENT DEDENT NEW_LINE DEDENT
def printSquares(n): INDENT square, prev_x = 0, 0 NEW_LINE for x in range(n): INDENT square = (square + x + prev_x) NEW_LINE print(square, end=' ▁ ') NEW_LINE prev_x = x DEDENT DEDENT NEW_LINE
def isCornerPresent(str, corner): NEW_LINE INDENT n = len(str) NEW_LINE cl = len(corner) NEW_LINE if n < cl: return False NEW_LINE return str[:cl] == corner and str[-cl:] == corner NEW_LINE DEDENT
def add(A, B, C): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(len(A[0])): NEW_LINE INDENT C[i][j] = A[i][j] + B[i][j] NEW_LINE DEDENT DEDENT DEDENT
def findStep(n): INDENT if n == 1 or n == 0: return 1 INDENT elif n == 2: return 2 INDENT else: return findStep(n - 3) + findStep(n - 2) + findStep(n - 1) NEW_LINE DEDENT DEDENT DEDENT
def isPossibleTriangle(arr, N): INDENT if N < 3: return False NEW_LINE arr.sort() NEW_LINE for i in range(N - 2): INDENT if arr[i] + arr[i + 1] > arr[i + 2]: return True DEDENT NEW_LINE return False DEDENT
def middleOfThree(a, b, c): INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0: INDENT return b DEDENT elif x * z > 0: INDENT return c DEDENT else: INDENT return a DEDENT DEDENT NEWLINE DEDENT
def findRepeating(arr, n): INDENT s = set() NEW_LINE for i in range(n): INDENT if arr[i] in s: return arr[i] NEW_LINE s.add(arr[i]) DEDENT NEW_LINE return -1 DEDENT
def minRevolutions(r, x1, y1, x2, y2): INDENT d = ((x1 - x2)**2 + (y1 - y2)**2)**0.5 NEW_LINE return (d / (2 * r)).__ceil__() DEDENT
def maxArea(a, b, c, d): INDENT semiperimeter = (a + b + c + d) / 2 NEW_LINE return (semiperimeter - a) * (semiperimeter - b) * (semiperimeter - c) * (semiperimeter - d)) ** 0.5 NEW_LINE DEDENT
import math NEW_LINE def checkcircle(r, R, r1, x1, y1): INDENT dis = int(math.sqrt(x1**2 + y1**2)) NEW_LINE return dis - r1 >= R and dis + r1 <= r NEW_LINE DEDENT
def isDiagonalMatrix(mat): NEW_LINE INDENT for i in range(len(mat)): NEW_LINE INDENT for j in range(len(mat)): NEW_LINE INDENT if i != j and mat[i][j] != 0: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minValue(A, B, n): INDENT A.sort() NEW_LINE B.sort() NEW_LINE result = 0 NEW_LINE for i in range(n): INDENT result += A[i] * B[n - i - 1] DEDENT NEW_LINE return result DEDENT
def findMod(a, b): INDENT if a < 0: a = -a NEW_LINE if b < 0: b = -b NEW_LINE mod = a NEW_LINE while mod >= b: mod = mod - b NEW_LINE if a < 0: return -mod NEW_LINE return mod NEW_LINE DEDENT
def arraySortedOrNot(arr, n): NEW_LINE INDENT if n == 0 or n == 1: NEW_LINE INDENT return True NEW_LINE DEDENT for i in range(1, n): NEW_LINE INDENT if arr[i - 1] > arr[i]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def multiply(A, B, C): NEW_LINE INDENT for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT C[i][j] = A[i][j] - B[i][j] NEW_LINE DEDENT DEDENT DEDENT
def minimumflip(mat, n): INDENT flip = 0 NEW_LINE for i in range(n): INDENT for j in range(i): INDENT if mat[i][j] != mat[j][i]: INDENT flip += 1 DEDENT DEDENT DEDENT NEW_LINE return flip NEW_LINE DEDENT
def sumNodes(l): INDENT leafNodeCount = 2 ** (l - 1) NEW_LINE sumLastLevel = (leafNodeCount * (leafNodeCount + 1)) / 2 NEW_LINE sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def findPosition(k, n): INDENT f1, f2, f3 = 0, 1, 0 NEW_LINE i = 2 NEW_LINE while True: INDENT f3 = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = f3 NEW_LINE if f2 % k == 0: INDENT return n * i DEDENT NEW_LINE i += 1 DEDENT NEW_LINE return 0 DEDENT
def findIndex(n): INDENT if n <= 1: return n NEW_LINE a, b, c = 0, 1, 1 NEW_LINE res = 1 NEW_LINE while c < n: INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT
def minimumSquare(a, b): INDENT result, rem = 0, 0 NEW_LINE if a < b: INDENT a, b = b, a DEDENT while b > 0: INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a, b = b, rem DEDENT return result NEW_LINE DEDENT
def constructArr(arr, pair, n): NEW_LINE INDENT arr[0] = (pair[0] + pair[1] - pair[n-1]) // 2 NEW_LINE for i in range(1, n): NEW_LINE INDENT arr[i] = pair[i-1] - arr[0] NEW_LINE DEDENT NEWLINE DEDENT
def findMaximum(arr, low, high): INDENT max = arr[low] NEW_LINE for i in range(low, high + 1): INDENT if arr[i] > max: INDENT max = arr[i] DEDENT DEDENT return max NEW_LINE DEDENT
def minimum_cost(a, n): INDENT mn = float('inf') NEW_LINE sum = 0 NEW_LINE for i in range(n): INDENT mn = min(a[i], mn) NEW_LINE sum += a[i] DEDENT NEW_LINE return mn * (sum - mn) DEDENT
def decToBin(n): NEW_LINE INDENT if n == 0: return "0" NEW_LINE bin = "" NEW_LINE while n > 0: NEW_LINE INDENT bin = ('0' if (n & 1) == 0 else '1') + bin NEW_LINE n >>= 1 NEW_LINE DEDENT return bin.strip() NEW_LINE DEDENT
def isInorder(arr, n): NEW_LINE INDENT if n == 0 or n == 1: NEW_LINE INDENT return True NEW_LINE DEDENT for i in range(1, n): NEW_LINE INDENT if arr[i - 1] > arr[i]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
import random NEW_LINE def shuffle(card, n): INDENT for i in range(n): INDENT r = i + random.randint(0, 51 - i) NEW_LINE temp = card[r] NEW_LINE card[r] = card[i] NEW_LINE card[i] = temp DEDENT NEW_LINE DEDENT
def mirrorImage(a, b, c, x1, y1): INDENT temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return (x, y) NEW_LINE DEDENT
def numberOfWays(x): INDENT dp = [0] * (x + 1) NEW_LINE dp[0] = dp[1] = 1 NEW_LINE for i in range(2, x + 1): INDENT dp[i] = dp[i - 1] + (i - 1) * dp[i - 2] DEDENT NEW_LINE return dp[x] DEDENT
def leonardo(n): NEW_LINE INDENT dp = [0] * (n + 1) NEW_LINE dp[0] = dp[1] = 1 NEW_LINE for i in range(2, n + 1): NEW_LINE INDENT dp[i] = dp[i - 1] + dp[i - 2] + 1 NEW_LINE DEDENT return dp[n] NEW_LINE DEDENT
def CountPairs(n): INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while imin <= n: INDENT imax = n // k NEW_LINE ans += k * (imax - imin + 1) NEW_LINE imin = imax + 1 NEW_LINE k = n // imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lastPosition(n, m, k): NEW_LINE INDENT if m <= n - k + 1: NEW_LINE INDENT return m + k - 1 NEW_LINE DEDENT m = m - (n - k + 1) NEW_LINE return n if m % n == 0 else m % n NEW_LINE DEDENT
def kthdigit(a, b, k): INDENT p = int(a ** b) NEW_LINE count = 0 NEW_LINE while p > 0 and count < k: INDENT rem = p % 10 NEW_LINE count += 1 NEW_LINE if count == k: return rem NEW_LINE p = p // 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def splitArr(arr, n, k): INDENT for i in range(k): INDENT x = arr[0] NEW_LINE for j in range(n - 1): INDENT arr[j] = arr[j + 1] DEDENT arr[n - 1] = x DEDENT DEDENT NEW_LINE DEDENT
def rotateMatrix(mat): NEW_LINE INDENT for i in range(len(mat)-1, -1, -1): NEW_LINE INDENT for j in range(len(mat[i])-1, -1, -1): NEW_LINE INDENT print(mat[i][j], end=' ▁ ') NEW_LINE DEDENT print() NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def russianPeasant(a, b): NEW_LINE INDENT res = 0 NEW_LINE while b > 0: NEW_LINE INDENT if b & 1: NEW_LINE INDENT res += a NEW_LINE DEDENT a <<= 1 NEW_LINE b >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def findDigits(n): INDENT if n < 0: return 0 NEW_LINE if n <= 1: return 1 NEW_LINE digits = 0 NEW_LINE for i in range(2, n+1): INDENT digits += math.log10(i) DEDENT NEW_LINE return int(math.floor(digits)) + 1 DEDENT
def swapDiagonal(matrix): NEW_LINE INDENT for i in range(len(matrix)): NEW_LINE INDENT temp = matrix[i][i] NEW_LINE matrix[i][i] = matrix[i][len(matrix)-i-1] NEW_LINE matrix[i][len(matrix)-i-1] = temp NEW_LINE DEDENT DEDENT NEWLINE DEDENT
def checkMarkov(m): INDENT for i in range(len(m)): INDENT sum = 0 NEW_LINE for j in range(len(m[i])): INDENT sum += m[i][j] DEDENT if sum != 1: INDENT return False DEDENT DEDENT return True DEDENT
def search(arr, n, x): INDENT i = 0 NEW_LINE while i <= n - 1: INDENT if arr[i] == x: return i NEW_LINE i += abs(arr[i] - x) DEDENT NEW_LINE return -1 DEDENT
def findMinSum(a, b, n): NEW_LINE INDENT a.sort() NEW_LINE b.sort() NEW_LINE sum = 0 NEW_LINE for i in range(int(n)): NEW_LINE INDENT sum += abs(a[i] - b[i]) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxPrefix(s, t): INDENT count = 0 NEW_LINE for i in range(len(t)): INDENT if count == len(t): INDENT break DEDENT if t[i] == s[count]: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT 
def transpose(A): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(i+1, len(A)): NEW_LINE INDENT temp = A[i][j] NEW_LINE A[i][j] = A[j][i] NEW_LINE A[j][i] = temp NEW_LINE DEDENT DEDENT NEWLINE DEDENT
def findMinDiff(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE diff = float('inf') NEW_LINE for i in range(n - 1): NEW_LINE INDENT if (arr[i + 1] - arr[i]) < diff: NEW_LINE INDENT diff = arr[i + 1] - arr[i] NEW_LINE DEDENT NEW_LINE DEDENT return diff NEW_LINE DEDENT
def countSquares(a, b): NEW_LINE INDENT cnt = 0 NEW_LINE for i in range(a, b + 1): NEW_LINE INDENT for j in range(1, int(i**0.5) + 1): NEW_LINE INDENT if j * j == i: NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT 
def count_of_ways(n): INDENT count = 0 NEW_LINE for i in range(int(n) + 1): INDENT for j in range(int(n) + 1): INDENT for k in range(int(n) + 1): INDENT if i + j + k == n: INDENT count += 1 DEDENT DEDENT DEDENT DEDENT return count DEDENT NEW_LINE DEDENT
def findHeight(parent, n): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT p, current = i, 1 NEW_LINE while parent[p] != -1: NEW_LINE INDENT current += 1 NEW_LINE p = parent[p] NEW_LINE DEDENT res = max(res, current) NEW_LINE DEDENT return res NEW_LINE DEDENT
def countFriendsPairings(n): INDENT a, b, c = 1, 2, 0 NEW_LINE if n <= 2: INDENT return n DEDENT NEW_LINE for i in range(3, n + 1): INDENT c = b + (i - 1) * a NEW_LINE a = b NEW_LINE b = c DEDENT NEW_LINE return c DEDENT NEWLINE DEDENT
def numofsubset(arr, n): INDENT arr.sort() NEW_LINE count = 1 NEW_LINE for i in range(n-1): INDENT if arr[i] + 1 != arr[i+1]: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT
def printFibonacciNumbers(n): INDENT if n < 1: return NEW_LINE f1, f2 = 0, 1 NEW_LINE for i in range(1, n + 1): INDENT print(f2, end=' ▁ ') NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT
def exponentiation(base, exp): INDENT long t = 1 while exp > 0: INDENT if exp % 2 != 0: INDENT t = (t * base) % N DEDENT base = (base * base) % N exp //= 2 DEDENT return t % N DEDENT NEW_LINE DEDENT
def countSolutions(n): INDENT res = 0 NEW_LINE for x in range(n): INDENT for y in range(n): INDENT if x*x + y*y < n: INDENT res += 1 DEDENT DEDENT DEDENT NEW_LINE return res DEDENT
def randomize(arr, n): INDENT import random NEW_LINE for i in range(n-1, 0, -1): INDENT j = random.randint(0, i) NEW_LINE temp = arr[i] NEW_LINE arr[i] = arr[j] NEW_LINE arr[j] = temp DEDENT NEW_LINE print(arr) DEDENT
def isDivisibleBy7(num): NEW_LINE INDENT if num < 0: return isDivisibleBy7(-num) NEW_LINE if num == 0 or num == 7: return True NEW_LINE if num < 10: return False NEW_LINE return isDivisibleBy7(num // 10 - 2 * (num % 10)) NEW_LINE DEDENT
def moduloMultiplication(a, b, mod): INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b > 0: INDENT if b & 1: INDENT res = (res + a) % mod DEDENT a = (2 * a) % mod NEW_LINE b >>= 1 DEDENT return res DEDENT NEWLINE DEDENT
def maximizecube(l, b, h): INDENT side = math.gcd(l, math.gcd(b, h)); num = l // side; num *= b // side; num *= h // side; print(f"{side} ▁ {num}") DEDENT NEWLINE DEDENT
def rec_search(arr, l, r, x): NEW_LINE INDENT if r < l: NEW_LINE INDENT return -1 NEW_LINE DEDENT if arr[l] == x: NEW_LINE INDENT return l NEW_LINE DEDENT if arr[r] == x: NEW_LINE INDENT return r NEW_LINE DEDENT return rec_search(arr, l + 1, r - 1, x) NEW_LINE DEDENT
def eulerian(n, m): INDENT if m >= n or n == 0: return 0 NEW_LINE if m == 0: return 1 NEW_LINE return (n - m) * eulerian(n - 1, m - 1) + (m + 1) * eulerian(n - 1, m) NEW_LINE DEDENT
def minLexRotation(str): NEW_LINE INDENT n = len(str) NEW_LINE arr = [str[i:i+n] for i in range(n)] NEW_LINE arr.sort() NEW_LINE return arr[0] NEW_LINE DEDENT
def isPossible(a, b, n, k): INDENT a.sort(reverse=True) NEW_LINE b.sort() NEW_LINE for i in range(n): INDENT if a[i] + b[i] < k: INDENT return False DEDENT DEDENT return True DEDENT NEW_LINE DEDENT
def maxProduct(arr, n): INDENT if n < 3: INDENT return -1 DEDENT arr.sort() NEW_LINE return max(arr[0] * arr[1] * arr[n-1], arr[n-1] * arr[n-2] * arr[n-3]) DEDENT NEW_LINE DEDENT
def canMakeAllSame(str): INDENT zeros, ones = 0, 0 NEW_LINE for i in range(len(str)): INDENT ch = str[i] NEW_LINE if ch == '0': INDENT zeros += 1 DEDENT else: INDENT ones += 1 DEDENT DEDENT return zeros == 1 or ones == 1 NEW_LINE DEDENT
def middleOfThree(a, b, c): NEW_LINE INDENT if (a < b and b < c) or (c < b and b < a): return b NEW_LINE elif (b < a and a < c) or (c < a and a < b): return a NEW_LINE else: return c NEW_LINE DEDENT
def binaryToDecimal(n: str) -> int: NEW_LINE INDENT dec_value, base = 0, 1 NEW_LINE for i in range(len(n)-1, -1, -1): NEW_LINE INDENT if n[i] == '1': NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base *= 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def minXOR(arr, n): INDENT min_xor = float('inf') NEW_LINE for i in range(n): INDENT for j in range(i + 1, n): INDENT min_xor = min(min_xor, arr[i] ^ arr[j]) DEDENT DEDENT DEDENT return min_xor DEDENT
def mulmod(a, b, mod): NEW_LINE INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b > 0: NEW_LINE INDENT if b % 2 == 1: NEW_LINE INDENT res = (res + a) % mod NEW_LINE DEDENT a = (a * 2) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def nonFibonacci(n): INDENT prevPrev, prev, curr = 1, 2, 3 NEW_LINE while n > 0: INDENT prevPrev = prev; prev = curr; curr = prevPrev + prev; n -= (curr - prev - 1) DEDENT NEW_LINE return prev + n DEDENT
def multiply(x, y): INDENT if y == 0: return 0 NEW_LINE if y > 0: return x + multiply(x, y - 1) NEW_LINE if y < 0: return -multiply(x, -y) NEW_LINE return -1 NEW_LINE DEDENT
def firstNonRepeating(arr, n): INDENT for i in range(n): INDENT j = 0 INDENT while j < n: INDENT if i != j and arr[i] == arr[j]: break NEW_LINE j += 1 DEDENT if j == n: return arr[i] DEDENT DEDENT return -1 NEW_LINE DEDENT
def countSubstringWithEqualEnds(s): INDENT result = 0 NEW_LINE n = len(s) NEW_LINE for i in range(n): INDENT for j in range(i, n): INDENT if s[i] == s[j]: INDENT result += 1 DEDENT DEDENT DEDENT NEW_LINE return result DEDENT
def countNegative(M, n, m): INDENT count = 0 NEW_LINE for i in range(n): INDENT for j in range(m): INDENT if M[i][j] < 0: INDENT count += 1 DEDENT else: INDENT break DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countSeq(n): INDENT int nCr = 1, res = 1 NEW_LINE for r in range(1, n+1): INDENT nCr = (nCr * (n + 1 - r)) // r NEW_LINE res += nCr * nCr DEDENT NEW_LINE return res DEDENT
def isPrime(p): INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range(1, p - 1): INDENT nextval = (nextval * nextval - 2) % checkNumber DEDENT NEW_LINE return nextval == 0 DEDENT
def minXOR(arr): NEW_LINE INDENT arr.sort() NEW_LINE minXor = float('inf') NEW_LINE val = 0 NEW_LINE for i in range(len(arr) - 1): NEW_LINE INDENT val = arr[i] ^ arr[i + 1] NEW_LINE minXor = min(minXor, val) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
def binarySearch(arr, x): INDENT l, r = 0, len(arr) - 1 NEW_LINE while l <= r: INDENT m = l + (r - l) // 2 NEW_LINE if arr[m] == x: return m NEW_LINE if arr[m] < x: l = m + 1 NEW_LINE else: r = m - 1 NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def count_integral_solutions(n): NEW_LINE INDENT result = 0 NEW_LINE for i in range(n + 1): NEW_LINE INDENT for j in range(n + 1 - i): NEW_LINE INDENT for k in range(n + 1 - i - j): NEW_LINE INDENT if i + j + k == n: NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def power(x, y, p): INDENT res = 1 INDENT x = x % p NEW_LINE while y > 0: INDENT if y & 1 == 1: INDENT res = (res * x) % p DEDENT y = y >> 1 INDENT x = (x * x) % p DEDENT DEDENT return res DEDENT
def minPerimeter(n): INDENT l = int(n**0.5) NEW_LINE sq = l * l NEW_LINE if sq == n: INDENT return l * 4 DEDENT else: INDENT row = n // l NEW_LINE perimeter = 2 * (l + row) NEW_LINE if n % l != 0: INDENT perimeter += 2 DEDENT return perimeter DEDENT DEDENT NEWLINE DEDENT
def numberOfPaths(m, n): NEW_LINE INDENT dp = [1] + [0] * (n - 1) NEW_LINE for i in range(m): NEW_LINE INDENT for j in range(1, n): NEW_LINE INDENT dp[j] += dp[j - 1] NEW_LINE DEDENT DEDENT return dp[n - 1] NEW_LINE DEDENT
def isPowerOfFour(n): INDENT NEW_LINE count = 0 NEW_LINE x = n & (n - 1) NEW_LINE if n > 0 and x == 0: INDENT NEW_LINE while n > 1: INDENT NEW_LINE n >>= 1 NEW_LINE count += 1 DEDENT NEW_LINE return 1 if count % 2 == 0 else 0 DEDENT NEW_LINE return 0 DEDENT NEW_LINE DEDENT
def subArray(n): INDENT for i in range(n): INDENT for j in range(i, n): INDENT for k in range(i, j + 1): INDENT print(arr[k], end=" ▁ ") DEDENT NEW_LINE DEDENT NEW_LINE DEDENT NEW_LINE DEDENT
def countDivisibles(arr, n): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def findCombinations(str, index, out): NEW_LINE INDENT if index == len(str): print(out) NEW_LINE for i in range(index, len(str)): findCombinations(str, i + 1, out + " (" + str[index:i+1] + ") ") NEW_LINE DEDENT
def decToBinary(n): INDENT binaryNum = [0] * 32 NEW_LINE i = 0 NEW_LINE while n > 0: INDENT binaryNum[i] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 DEDENT NEW_LINE for j in range(i - 1, -1, -1): INDENT print(binaryNum[j], end='') DEDENT NEW_LINE DEDENT
def printDistinct(arr): INDENT set = set() NEW_LINE for i in arr: INDENT if i not in set: INDENT set.add(i) NEW_LINE print(i, end=' ▁ ') DEDENT DEDENT NEW_LINE DEDENT
def nearestSmallerEqFib(n): INDENT if n == 0 or n == 1: return n NEW_LINE f1, f2, f3 = 0, 1, 1 NEW_LINE while f3 <= n: INDENT f1, f2, f3 = f2, f3, f1 + f2 DEDENT return f2 DEDENT NEW_LINE DEDENT
def maxTasks(high, low, n): INDENT if n <= 0: return 0 NEW_LINE return max(high[n-1] + maxTasks(high, low, n-2), low[n-1] + maxTasks(high, low, n-1)) NEW_LINE DEDENT
def sequence(n): INDENT f = [0] * (n + 1) NEW_LINE f[0] = 0 NEW_LINE f[1] = 1 NEW_LINE f[2] = 1 NEW_LINE for i in range(3, n + 1): INDENT f[i] = f[f[i - 1]] + f[i - f[i - 1]] DEDENT NEW_LINE return f[n] DEDENT
def maxGameByWinner(N): INDENT dp = [0] * N NEW_LINE dp[0] = 1 NEW_LINE dp[1] = 2 NEW_LINE i = 2 NEW_LINE while True: INDENT dp[i] = dp[i - 1] + dp[i - 2] NEW_LINE if dp[i] > N: INDENT break DEDENT i += 1 DEDENT return i - 2 NEWLINE DEDENT
def abFree(s: str) -> int: NEW_LINE INDENT b_count = 0 NEW_LINE res = 0 NEW_LINE for i in range(len(s)): NEW_LINE INDENT if s[-i-1] == 'a': NEW_LINE INDENT res += b_count NEW_LINE b_count *= 2 NEW_LINE DEDENT else: NEW_LINE INDENT b_count += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def printDistinct(arr, n): INDENT for i in range(n): INDENT j = 0 NEW_LINE while j < i and arr[i] != arr[j]: INDENT j += 1 DEDENT NEW_LINE if i == j: INDENT print(arr[i], end=' ▁ ') DEDENT DEDENT DEDENT NEW_LINE
def findElements(arr, n): INDENT for i in range(n): INDENT count = 0 NEW_LINE for j in range(n): INDENT if arr[j] > arr[i]: INDENT count += 1 DEDENT DEDENT if count >= 2: INDENT print(arr[i], end=' ▁ ') DEDENT DEDENT DEDENT NEW_LINE DEDENT
def isIdentity(mat, N): INDENT for row in range(N): INDENT for col in range(N): INDENT if row == col and mat[row][col] != 1: INDENT return False DEDENT elif row != col and mat[row][col] != 0: INDENT return False DEDENT DEDENT DEDENT return True DEDENT NEW_LINE DEDENT
def insertSorted(arr, n, key, capacity): INDENT if n >= capacity: INDENT return n DEDENT i = n - 1 NEW_LINE while i >= 0 and arr[i] > key: INDENT arr[i + 1] = arr[i] NEW_LINE i -= 1 DEDENT arr[i + 1] = key NEW_LINE return n + 1 DEDENT
def solve(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE a, b = 0, 0 NEW_LINE for i in range(n): NEW_LINE INDENT if i % 2 != 0: NEW_LINE INDENT a = a * 10 + arr[i] NEW_LINE DEDENT else: NEW_LINE INDENT b = b * 10 + arr[i] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def findMinX(num, rem, k): INDENT x = 1 NEW_LINE while True: INDENT j = 0 NEW_LINE for j in range(k): INDENT if x % num[j] != rem[j]: INDENT break DEDENT DEDENT if j == k: INDENT return x DEDENT x += 1 DEDENT DEDENT NEW_LINE DEDENT
def countNegative(M, n, m): INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n: INDENT if M[i][j] < 0: INDENT count += j + 1 NEW_LINE i += 1 DEDENT else: INDENT j -= 1 DEDENT DEDENT return count NEWLINE DEDENT
def to_upper(in_chars): INDENT for i in range(len(in_chars)): INDENT if 'a' <= in_chars[i] <= 'z': INDENT in_chars[i] = chr(ord(in_chars[i]) - ord('a') + ord('A')) DEDENT DEDENT return ''.join(in_chars) NEWLINE DEDENT
def count_pairs_with_diff_k(arr, k): INDENT count = 0 NEW_LINE for i in range(len(arr)): INDENT for j in range(i + 1, len(arr)): INDENT if abs(arr[i] - arr[j]) == k: INDENT count += 1 DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def checkIsAP(arr, n): INDENT if n == 1: return True NEW_LINE arr.sort() NEW_LINE d = arr[1] - arr[0] NEW_LINE for i in range(2, n): INDENT if arr[i] - arr[i - 1] != d: return False DEDENT NEW_LINE return True DEDENT
def insertionSortRecursive(arr, n): NEW_LINE INDENT if n <= 1: return NEW_LINE insertionSortRecursive(arr, n - 1) NEW_LINE last = arr[n - 1] NEW_LINE j = n - 2 NEW_LINE while j >= 0 and arr[j] > last: NEW_LINE INDENT arr[j + 1] = arr[j] NEW_LINE j -= 1 NEW_LINE DEDENT arr[j + 1] = last NEW_LINE DEDENT
