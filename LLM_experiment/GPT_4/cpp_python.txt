def areaSquare(side): NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT
def intersection(n): INDENT return n * (n - 1) NEW_LINE DEDENT 
def fun(n): NEW_LINE INDENT return n & (n - 1) NEW_LINE DEDENT
def cassini(n): INDENT return -1 if n & 1 else 1 NEW_LINE DEDENT
def hexagonalNum(n): INDENT return n * (2 * n - 1) NEW_LINE DEDENT 
def addOne(x): return -(~x) NEW_LINE  DEDENT 
def circumference(r): NEW_LINE INDENT cir = 2 * 3.141592653589793 * r NEW_LINE return cir NEW_LINE DEDENT
def find_Area(r): return 2 * r * r NEW_LINE DEDENT 
def check(n): INDENT return 1162261467 % n == 0 NEW_LINE DEDENT
def mergeTwoHalf(A, n): INDENT A.sort() NEW_LINE DEDENT 
def isEven(n): INDENT return n % 2 == 0 NEW_LINE DEDENT 
def largest(arr, n): INDENT return max(arr[:n]) NEW_LINE DEDENT
def height(N): NEW_LINE INDENT return ceil(log2(N + 1)) - 1 NEW_LINE DEDENT
def numberOfSticks(x): NEW_LINE INDENT return (3 * x * (x + 1)) // 2 NEW_LINE DEDENT
def summingSeries(n): INDENT return n ** 2 NEW_LINE DEDENT 
def pentagonalNum(n): INDENT return (3 * n * n - n) // 2 NEW_LINE DEDENT
def isEven(n): INDENT return not (n & 1) NEW_LINE DEDENT
def binomialCoeffSum(n): NEW_LINE INDENT return (1 << n) NEW_LINE DEDENT
def rangeGCD(n, m): INDENT return n if n == m else 1 NEW_LINE DEDENT 
def power(n): INDENT if n == 1: return 2 NEW_LINE return 2 * power(n - 1) NEW_LINE DEDENT
def compute_average(a, b): NEW_LINE INDENT return (a + b) // 2 NEW_LINE DEDENT
def Circumference(a): NEW_LINE INDENT return 4 * a NEW_LINE DEDENT
def multiplyWith3Point5(x): NEW_LINE INDENT return (x << 1) + x + (x >> 1) NEW_LINE DEDENT
def slope(x1, y1, x2, y2): INDENT return (y2 - y1) / (x2 - x1) NEW_LINE DEDENT
def factorial(n): INDENT if n == 0: return 1 NEW_LINE return n * factorial(n - 1) NEW_LINE DEDENT
def oppositeSigns(x, y): INDENT return (x ^ y) < 0 NEW_LINE DEDENT
def swapNibbles(x): INDENT return ((x & 0x0F) << 4 | (x & 0xF0) >> 4) NEW_LINE DEDENT
def countNonEmptySubstr(str): NEW_LINE INDENT n = len(str) NEW_LINE return n * (n + 1) // 2 NEW_LINE DEDENT
def getModulo(n, d): NEW_LINE INDENT return n & (d - 1) NEW_LINE DEDENT
def nthTerm(n): INDENT return (n * n) + (n * n * n) DEDENT NEW_LINE DEDENT 
def isMultipleOf10(n): INDENT return n % 15 == 0 NEW_LINE DEDENT
def factorial(n): NEW_LINE INDENT if n == 0: return 1 NEW_LINE return n * factorial(n - 1) NEW_LINE DEDENT
def count_of_ways(n): NEW_LINE INDENT count = (n + 1) * (n + 2) // 2 NEW_LINE return count NEW_LINE DEDENT
def gcd(a, b): NEW_LINE INDENT if a == 0: return b NEW_LINE return gcd(b % a, a) NEW_LINE DEDENT
def rectCount(n, m): NEW_LINE INDENT return (m * n * (n + 1) * (m + 1)) // 4 NEW_LINE DEDENT
def volumeOfEllipsoid(r1, r2, r3): NEW_LINE INDENT pi = 3.14 NEW_LINE return 1.33 * pi * r1 * r2 * r3 NEW_LINE DEDENT
def getRemainder(num, divisor): INDENT return num - divisor * (num // divisor) NEW_LINE DEDENT
def findMaximumPieces(n): NEW_LINE INDENT return 1 + n * (n + 1) // 2 NEW_LINE DEDENT
def evenbinomialCoeffSum(n): INDENT return (1 << (n - 1)) NEW_LINE DEDENT
def lis(arr, n): NEW_LINE INDENT max = 1 NEW_LINE _lis(arr, n, max) NEW_LINE return max NEW_LINE DEDENT
def areaOctagon(side): NEW_LINE INDENT return 2 * (1 + sqrt(2)) * side * side NEW_LINE DEDENT
def surface_area_octahedron(side): NEW_LINE INDENT return 2 * (3**0.5) * (side * side) NEW_LINE DEDENT
def sortit(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT arr[i] = i + 1 NEW_LINE DEDENT DEDENT
def findSum(n): INDENT return n * (n + 1) * (n + 2) * (3 * n + 1) // 24 NEW_LINE DEDENT 
def vol_of_octahedron(side): NEW_LINE INDENT return (side * side * side) * (sqrt(2) / 3) NEW_LINE DEDENT
def Resources(process, need): INDENT return process * (need - 1) + 1 NEW_LINE DEDENT
def procal(n): INDENT return (3.0 * n) / (4.0 * (n * n) - 1) NEW_LINE DEDENT
def cost(a): NEW_LINE INDENT return (len(a) - 1) * min(a) NEW_LINE DEDENT
def isPowerOfTwo(x): INDENT return x and not (x & (x - 1)) NEW_LINE DEDENT
def factorial(n): NEW_LINE INDENT res = 1 NEW_LINE for i in range(2, n+1): NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT 
def findRepeating(arr, n): NEW_LINE INDENT return sum(arr) - ((n - 1) * n // 2) NEW_LINE DEDENT
def reverse(str): NEW_LINE INDENT n = len(str) NEW_LINE for i in range(n // 2): NEW_LINE INDENT str[i], str[n - i - 1] = str[n - i - 1], str[i] NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def assignValue(a, b, x): NEW_LINE INDENT arr = [a, b] NEW_LINE return arr[int(x)] NEW_LINE DEDENT
def countSetBits(n): INDENT count = 0 NEW_LINE while n: INDENT n &= (n - 1) NEW_LINE count += 1 DEDENT NEW_LINE return count DEDENT NEW_LINE DEDENT
def bin(n): NEW_LINE INDENT if n > 1: bin(n >> 1) NEW_LINE print(n & 1, end=' ') NEW_LINE DEDENT
def sumOfSeries(n): NEW_LINE INDENT return 0.666 * (1 - 1 / pow(10, n)) NEW_LINE DEDENT
def calculateSum(n): NEW_LINE INDENT sum = 1 << n NEW_LINE return sum - 1 NEW_LINE DEDENT
def countSetBits(n): NEW_LINE INDENT if n == 0: return 0 NEW_LINE else: return (n & 1) + countSetBits(n >> 1) NEW_LINE DEDENT
def countSetBits(n): NEW_LINE INDENT if n == 0: return 0 NEW_LINE else: return 1 + countSetBits(n & (n - 1)) NEW_LINE DEDENT 
def kthSmallest(arr, n, k): NEW_LINE INDENT arr.sort() NEW_LINE return arr[k-1] NEW_LINE DEDENT
def lis(arr, n): INDENT max = 1 NEW_LINE _lis(arr, n, max) NEW_LINE return max NEW_LINE DEDENT
def getArea(a): INDENT return (3.141592653589793 * a * a) / 4.0 NEW_LINE DEDENT 
def repeat(s: str, n: int) -> str: NEW_LINE INDENT s1 = s NEW_LINE for i in range(1, n): NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def yMod(y, x): INDENT NEW_LINE if log2(y) < x: return y NEW_LINE if x > 63: return y NEW_LINE return y % (1 << x) NEW_LINE DEDENT
def minSum(A): NEW_LINE INDENT return min(A) * (len(A) - 1) NEW_LINE DEDENT 
def reverse(str): NEW_LINE INDENT if len(str) == 0: NEW_LINE INDENT return NEW_LINE DEDENT reverse(str[1:]) NEW_LINE print(str[0], end='') NEW_LINE DEDENT
def addOne(x): INDENT m = 1 NEW_LINE while x & m: INDENT x = x ^ m NEW_LINE m <<= 1 DEDENT x = x ^ m NEW_LINE return x DEDENT
def search(arr, n, x): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def maxSquare(b, m): INDENT return (b // m - 1) * (b // m) // 2 NEW_LINE DEDENT
def isNumber(s): NEW_LINE INDENT for i in range(len(s)): NEW_LINE INDENT if not s[i].isdigit(): NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printArray(a, n): INDENT for i in range(n): INDENT print(a[i], end=' ▁ ') DEDENT print() DEDENT NEW_LINE DEDENT
def findArea(a): INDENT return (5 * (5 + 2 * (5 ** 0.5)) ** 0.5 * a * a) / 4 NEW_LINE DEDENT
def printSubStr(str, low, high): NEW_LINE INDENT for i in range(low, high + 1): NEW_LINE INDENT print(str[i], end='') NEW_LINE DEDENT DEDENT
def getAbs(n): INDENT return (n + (mask := n >> (n.bit_length() - 1))) ^ mask NEW_LINE DEDENT 
def countStr(n): INDENT return 1 + (n * 2) + (n * ((n * n) - 1) // 2) NEW_LINE DEDENT
def turnOffK(n, k): NEW_LINE INDENT if k <= 0: return n NEW_LINE return n & ~(1 << (k - 1)) NEW_LINE DEDENT
def fib(n): INDENT if n <= 1: return n NEW_LINE return fib(n - 1) + fib(n - 2) NEW_LINE DEDENT
def getOddOccurrence(ar, ar_size): NEW_LINE INDENT res = 0 NEW_LINE for i in range(ar_size): NEW_LINE INDENT res ^= ar[i] NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSquares(a, b): NEW_LINE INDENT return int(math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a)) + 1) NEW_LINE DEDENT
def divisorSum(n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT sum += (n // i) * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def maxTripletSum(arr): INDENT return sum(sorted(arr)[-3:]) NEW_LINE DEDENT
def evenlength(n): INDENT return n + n[::-1] DEDENT NEW_LINE DEDENT
def findSum(N, K): INDENT ans = 0 NEW_LINE for i in range(1, N + 1): INDENT ans += i % K DEDENT NEW_LINE return ans DEDENT 
def isPrime(n): NEW_LINE INDENT if n <= 1: return False NEW_LINE for i in range(2, n): NEW_LINE INDENT if n % i == 0: return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def isPossible(str, n): NEW_LINE INDENT len = len(str) NEW_LINE if len >= n: return True NEW_LINE return False NEW_LINE DEDENT
def printFun(test): NEW_LINE INDENT if test < 1: return NEW_LINE else: NEW_LINE INDENT print(test, "▁", end=" ") NEW_LINE printFun(test - 1) NEW_LINE print(test, "▁", end=" ") NEW_LINE return NEW_LINE DEDENT DEDENT
def sequence(n): NEW_LINE INDENT if n == 1 or n == 2: return 1 NEW_LINE else: return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1)) NEW_LINE DEDENT
def nextPowerOf2(n): INDENT if n and not (n & (n - 1)): return n NEW_LINE p = 1 NEW_LINE while p < n: INDENT p <<= 1 DEDENT NEW_LINE return p DEDENT
def leonardo(n): NEW_LINE INDENT if n == 0 or n == 1: return 1 NEW_LINE return leonardo(n - 1) + leonardo(n - 2) + 1 NEW_LINE DEDENT
def nextPowerOf2(n): NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
import math NEW_LINE def vol_of_dodecahedron(side): INDENT return ((15 + 7 * math.sqrt(5)) / 4) * side ** 3 NEW_LINE DEDENT
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; } NEW_LINE def PowerOFPINnfactorial(n, p): NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while temp <= n: NEW_LINE INDENT ans += n // temp NEW_LINE temp *= p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find(n, k): NEW_LINE INDENT if n + 1 >= k: return k - 1 NEW_LINE else: return 2 * n + 1 - k NEW_LINE DEDENT 
def isPowerOfFour(n: int) -> bool: NEW_LINE INDENT return n != 0 and (n & (n - 1)) == 0 and not (n & 0xAAAAAAAA) NEW_LINE DEDENT 
def nswp(n): NEW_LINE INDENT if n == 0 or n == 1: return 1 NEW_LINE return 2 * nswp(n - 1) + nswp(n - 2) NEW_LINE DEDENT
def findTrailingZeros(n): NEW_LINE INDENT count = 0 NEW_LINE i = 5 NEW_LINE while n / i >= 1: NEW_LINE INDENT count += n // i NEW_LINE i *= 5 NEW_LINE DEDENT return count NEW_LINE DEDENT
def getMissingNo(a, n): NEW_LINE INDENT total = (n + 1) * (n + 2) // 2 NEW_LINE for i in range(n): NEW_LINE INDENT total -= a[i] DEDENT NEW_LINE return total NEW_LINE DEDENT
def countPaths(n, m): NEW_LINE INDENT if n == 0 or m == 0: return 1 NEW_LINE return countPaths(n - 1, m) + countPaths(n, m - 1) NEW_LINE DEDENT
def largestPower(n, p): INDENT x = 0 NEW_LINE while n: INDENT n //= p NEW_LINE x += n DEDENT NEW_LINE return x DEDENT NEW_LINE 
def checkValidity(a, b, c): INDENT if a + b <= c or a + c <= b or b + c <= a: return False NEW_LINE else: return True NEW_LINE DEDENT
def leftRotate(arr, n, k): NEW_LINE INDENT for i in range(k, k + n): NEW_LINE INDENT print(arr[i % n], end=' ▁ ') NEW_LINE DEDENT NEW_LINE DEDENT
def findLastIndex(str, x): NEW_LINE INDENT index = -1 NEW_LINE for i in range(len(str)): NEW_LINE INDENT if str[i] == x: index = i NEW_LINE DEDENT return index NEW_LINE DEDENT 
def PowerOFPINnfactorial(n, p): NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while temp <= n: NEW_LINE INDENT ans += n // temp NEW_LINE temp *= p NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLastIndex(str, x): NEW_LINE INDENT for i in range(len(str) - 1, -1, -1): NEW_LINE INDENT if str[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def printNos(n): NEW_LINE INDENT if n > 0: NEW_LINE INDENT printNos(n - 1) NEW_LINE print(n, end=' ▁ ') NEW_LINE DEDENT return NEW_LINE DEDENT
def findLarger(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE for i in range(n-1, n//2-1, -1): NEW_LINE INDENT print(arr[i], end=' ▁ ') NEW_LINE DEDENT NEW_LINE DEDENT
def swap(xp, yp): NEW_LINE INDENT xp[0] = xp[0] ^ yp[0] NEW_LINE yp[0] = xp[0] ^ yp[0] NEW_LINE xp[0] = xp[0] ^ yp[0] NEW_LINE DEDENT
def printFactorialNums(n): NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n: NEW_LINE INDENT print(fact, end=' ▁ ') NEW_LINE fact *= x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT
def getMissingNo(a, n): INDENT total = 1 NEW_LINE for i in range(2, n + 2): INDENT total += i NEW_LINE total -= a[i - 2] DEDENT NEW_LINE return total DEDENT NEW_LINE DEDENT
def numberOfPaths(m, n): INDENT if m == 1 or n == 1: return 1 NEW_LINE return numberOfPaths(m - 1, n) + numberOfPaths(m, n - 1) NEW_LINE DEDENT 
def count(s, c): INDENT res = 0 NEW_LINE for i in range(len(s)): INDENT if s[i] == c: INDENT res += 1 DEDENT DEDENT return res NEW_LINE DEDENT
def maxvolume(s): INDENT length = s // 3 NEW_LINE s -= length NEW_LINE breadth = s // 2 NEW_LINE height = s - breadth NEW_LINE return length * breadth * height NEW_LINE DEDENT
def horner(poly, n, x): NEW_LINE INDENT result = poly[0] NEW_LINE for i in range(1, n): NEW_LINE INDENT result = result * x + poly[i] NEW_LINE DEDENT return result NEW_LINE DEDENT
def countDigits(a, b): NEW_LINE INDENT if a == 0 or b == 0: return 1 NEW_LINE return int((log10(abs(a)) + log10(abs(b))) + 1) NEW_LINE DEDENT
def allCharactersSame(s): NEW_LINE INDENT n = len(s) NEW_LINE for i in range(1, n): NEW_LINE INDENT if s[i] != s[0]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isPower(x, y): NEW_LINE INDENT res1 = int(log(y) / log(x)) NEW_LINE res2 = log(y) / log(x) NEW_LINE return res1 == res2 NEW_LINE DEDENT 
def modInverse(a, m): NEW_LINE INDENT a = a % m NEW_LINE for x in range(1, m): NEW_LINE INDENT if (a * x) % m == 1: NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT
def doublefactorial(n): NEW_LINE INDENT res = 1 NEW_LINE for i in range(n, 0, -2): NEW_LINE INDENT if i == 0 or i == 1: NEW_LINE INDENT return res NEW_LINE DEDENT else: NEW_LINE INDENT res *= i NEW_LINE DEDENT DEDENT NEW_LINE DEDENT 
def center(x1, x2, y1, y2): NEW_LINE INDENT print((x1 + x2) / 2, ',', (y1 + y2) / 2) NEW_LINE DEDENT 
def exponential(n, x): NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range(n-1, 0, -1): NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def largest(arr, n): INDENT max = arr[0] NEW_LINE for i in range(1, n): INDENT if arr[i] > max: INDENT max = arr[i] DEDENT DEDENT return max NEW_LINE DEDENT 
def nextPowerOf2(n): INDENT if n and not (n & (n - 1)): return n NEW_LINE count = 0 NEW_LINE while n != 0: INDENT n >>= 1 NEW_LINE count += 1 DEDENT return 1 << count DEDENT
def floorSqrt(x): NEW_LINE INDENT if x == 0 or x == 1: return x NEW_LINE i, result = 1, 1 NEW_LINE while result <= x: NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT
def search(arr, n, x): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT 
def isPower(x, y): NEW_LINE INDENT if x == 1: return y == 1 NEW_LINE pow = 1 NEW_LINE while pow < y: NEW_LINE INDENT pow *= x NEW_LINE DEDENT return pow == y NEW_LINE DEDENT 
def kthgroupsum(k): NEW_LINE INDENT cur = (k * (k - 1)) + 1 NEW_LINE sum = 0 NEW_LINE while k > 0: NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k -= 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sumOfSeries(n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT sum += (2 * i - 1) * (2 * i - 1) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def divisibleBy20(num): NEW_LINE INDENT lastTwoDigits = int(num[-2:]) NEW_LINE return (lastTwoDigits % 5 == 0) and (lastTwoDigits % 4 == 0) NEW_LINE DEDENT
def squareRoot(n): INDENT float x = n NEW_LINE float y = 1 NEW_LINE float e = 0.000001 NEW_LINE while x - y > e: INDENT x = (x + y) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT
def findSum(n): INDENT sum = 0 NEW_LINE for i in range(1, n + 1): INDENT for j in range(i, n + 1): INDENT sum += i * j DEDENT DEDENT return sum DEDENT NEW_LINE DEDENT
def playGame(arr, n): NEW_LINE INDENT hash = set() NEW_LINE for i in range(n): NEW_LINE INDENT hash.add(arr[i]) NEW_LINE DEDENT return 1 if len(hash) % 2 == 0 else 2 NEW_LINE DEDENT
def isDivisible(n: int) -> bool: NEW_LINE INDENT while n // 100: NEW_LINE INDENT last_digit = n % 10 NEW_LINE n //= 10 NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return n % 29 == 0 NEW_LINE DEDENT
def first(str): NEW_LINE INDENT for i in range(len(str)): NEW_LINE INDENT if str[i].isupper(): NEW_LINE INDENT return str[i] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def find_extra_element_index(arrA, arrB, n, m): NEW_LINE INDENT extra_element = sum(arrA) - sum(arrB) NEW_LINE return arrA.index(extra_element) NEW_LINE DEDENT 
def spiralDiaSum(n): NEW_LINE INDENT if n == 1: return 1 NEW_LINE return (4 * n * n - 6 * n + 6 + spiralDiaSum(n - 2)) NEW_LINE DEDENT
def decToBinary(n): NEW_LINE INDENT for i in range(31, -1, -1): NEW_LINE INDENT k = n >> i NEW_LINE if k & 1: NEW_LINE INDENT print("1", end="") NEW_LINE DEDENT else: NEW_LINE INDENT print("0", end="") NEW_LINE DEDENT DEDENT NEW_LINE DEDENT 
def search(arr, n, x): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def Right_most_setbit(num): NEW_LINE INDENT pos = 1 NEW_LINE for i in range(32): NEW_LINE INDENT if not num & (1 << i): NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else: NEW_LINE INDENT break NEW_LINE DEDENT NEW_LINE return pos NEW_LINE DEDENT
def smallest(x, y, z): NEW_LINE INDENT c = 0 NEW_LINE while x and y and z: NEW_LINE INDENT x -= 1 NEW_LINE y -= 1 NEW_LINE z -= 1 NEW_LINE c += 1 NEW_LINE DEDENT return c NEW_LINE DEDENT 
def countOccurrences(arr, n, x): INDENT res = 0 NEW_LINE for i in range(n): INDENT if x == arr[i]: INDENT res += 1 DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def getSum(self, n): INDENT sum = 0 NEW_LINE while n != 0: INDENT sum = sum + n % 10 NEW_LINE n = n // 10 DEDENT return sum NEW_LINE DEDENT 
def nextPowerOf2(n): NEW_LINE INDENT p = 1 NEW_LINE if n and not (n & (n - 1)): NEW_LINE INDENT return n NEW_LINE DEDENT while p < n: NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT
def numberOfPaths(m, n): INDENT path = 1 NEW_LINE for i in range(n, m + n - 1): INDENT path *= i NEW_LINE path /= (i - n + 1) DEDENT NEW_LINE return path DEDENT
def nextPowerOf2(n): INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT
def singleNumber(a, n): INDENT return (3 * sum(set(a)) - sum(a)) // 2 NEW_LINE DEDENT
def compute(a, b): NEW_LINE INDENT AM = (a + b) / 2 NEW_LINE GM = (a * b) ** 0.5 NEW_LINE HM = (GM * GM) / AM NEW_LINE return HM NEW_LINE DEDENT
def isPerfectSquare(n): NEW_LINE INDENT sum, i = 0, 1 NEW_LINE while sum < n: NEW_LINE INDENT sum += i NEW_LINE i += 2 NEW_LINE if sum == n: NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def sumBetweenTwoKth(arr, k1, k2): NEW_LINE INDENT arr.sort() NEW_LINE return sum(arr[k1:k2-1]) NEW_LINE DEDENT 
def kLargest(arr, n, k): NEW_LINE INDENT arr.sort(reverse=True) NEW_LINE for i in range(k): NEW_LINE INDENT print(arr[i], end=" ▁ ") NEW_LINE DEDENT NEW_LINE DEDENT
def findMinZero(p): INDENT first, second, number, next = 1, 1, 2, 1 NEW_LINE while next: INDENT next = (first + second) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number += 1 NEW_LINE DEDENT return number NEW_LINE DEDENT
def catalan(n: int) -> int: NEW_LINE INDENT if n <= 1: return 1 NEW_LINE res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT res += catalan(i) * catalan(n - i - 1) DEDENT NEW_LINE return res NEW_LINE DEDENT
def findS(s): INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s: INDENT sum += n * n NEW_LINE if sum == s: INDENT return n DEDENT n += 1 DEDENT return -1 DEDENT NEW_LINE DEDENT
def evenFib(n): NEW_LINE INDENT if n < 1: return n NEW_LINE if n == 1: return 2 NEW_LINE return (4 * evenFib(n - 1)) + evenFib(n - 2) NEW_LINE DEDENT
def isTriangular(num): NEW_LINE INDENT if num < 0: return False NEW_LINE sum = 0 NEW_LINE for n in range(1, num+1): NEW_LINE INDENT sum += n NEW_LINE if sum == num: return True NEW_LINE if sum > num: break NEW_LINE DEDENT return False NEW_LINE DEDENT
def check(str): NEW_LINE INDENT n = len(str) NEW_LINE digitSum = 0 NEW_LINE for i in range(n): NEW_LINE INDENT digitSum += int(str[i]) - ord('0') DEDENT NEW_LINE return digitSum % 9 == 0 NEW_LINE DEDENT
def transpose(A, B): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(len(A[0])): NEW_LINE INDENT B[i][j] = A[j][i] NEW_LINE DEDENT DEDENT DEDENT DEDENT
def fib(n): NEW_LINE INDENT if n < 6: return f[n] NEW_LINE t, fn = 5, 5 NEW_LINE while t < n: NEW_LINE INDENT fn = round(fn * PHI) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT
def isPowerOfTwo(n): NEW_LINE INDENT if n == 0: return False NEW_LINE while n != 1: NEW_LINE INDENT if n % 2 != 0: return False NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def countDigits(a, b): INDENT count = 0 NEW_LINE p = abs(a * b) NEW_LINE if p == 0: INDENT return 1 DEDENT while p > 0: INDENT count += 1 NEW_LINE p //= 10 DEDENT return count NEW_LINE DEDENT
def findExtra(arr1, arr2, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT if arr1[i] != arr2[i]: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def reverseStr(str): INDENT n = len(str) NEW_LINE i, j = 0, n - 1 NEW_LINE while i < j: INDENT str[i], str[j] = str[j], str[i] NEW_LINE i += 1 NEW_LINE j -= 1 DEDENT DEDENT NEW_LINE 
def rotate(arr, n): NEW_LINE INDENT x = arr[n - 1] NEW_LINE for i in range(n - 1, 0, -1): NEW_LINE INDENT arr[i] = arr[i - 1] NEW_LINE DEDENT arr[0] = x NEW_LINE DEDENT
def findS(s): INDENT sum = 0 NEW_LINE n = 1 NEW_LINE while sum < s: INDENT sum += n * n * n NEW_LINE if sum == s: INDENT return n DEDENT n += 1 DEDENT return -1 DEDENT NEW_LINE DEDENT
def isPowerOfFour(n): NEW_LINE INDENT if n == 0: return False NEW_LINE while n != 1: NEW_LINE INDENT if n % 4 != 0: return False NEW_LINE n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT
def answer_query(a, n, l, r): NEW_LINE INDENT count = 0 NEW_LINE for i in range(l, r): NEW_LINE INDENT if a[i] == a[i+1]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findFrequency(arr, n, left, right, element): INDENT count = 0 NEW_LINE for i in range(left - 1, right): INDENT if arr[i] == element: INDENT count += 1 DEDENT DEDENT return count NEW_LINE DEDENT
def query(s, i, j): NEW_LINE INDENT n = len(s) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print("Yes") if s[i] == s[j] else print("No") NEW_LINE DEDENT
def smallest(x, y, z): NEW_LINE INDENT if not (y // x): NEW_LINE INDENT return y if not (y // z) else z NEW_LINE DEDENT return x if not (x // z) else z NEW_LINE DEDENT
def check(degree, n): NEW_LINE INDENT deg_sum = sum(degree) NEW_LINE return 2 * (n - 1) == deg_sum NEW_LINE DEDENT 
def isPalindrome(str): INDENT l = 0 NEW_LINE h = len(str) - 1 NEW_LINE while h > l: INDENT if str[l] != str[h]: INDENT return False DEDENT l += 1 NEW_LINE h -= 1 DEDENT DEDENT return True NEW_LINE DEDENT
def printSquares(n): NEW_LINE INDENT square, odd = 0, 1 NEW_LINE for x in range(n): NEW_LINE INDENT print(square, end=' ▁ ') NEW_LINE square += odd NEW_LINE odd += 2 NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def minSum(n): INDENT sum = 0 NEW_LINE while n > 0: INDENT sum += n % 10 NEW_LINE n //= 10 DEDENT NEW_LINE if sum == 1: INDENT return 10 DEDENT NEW_LINE return sum DEDENT NEW_LINE DEDENT
def isOneFlip(str): INDENT NEW_LINE sum = 0 NEW_LINE n = len(str) NEW_LINE for i in range(n): INDENT NEW_LINE sum += int(str[i]) - int('0') DEDENT NEW_LINE return sum == n - 1 or sum == 1 DEDENT NEW_LINE DEDENT
def squareRootExists(n, p): NEW_LINE INDENT n = n % p NEW_LINE for x in range(2, p): NEW_LINE INDENT if (x * x) % p == n: NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def count(n, x): NEW_LINE INDENT count = 0 NEW_LINE for i in range(1, min(n, x) + 1): NEW_LINE INDENT if x // i <= n and x % i == 0: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def binomialCoeff(n, k): NEW_LINE INDENT if k == 0 or k == n: return 1 NEW_LINE return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k) NEW_LINE DEDENT
def swapDiagonal(matrix): NEW_LINE INDENT for i in range(len(matrix)): NEW_LINE INDENT matrix[i][i], matrix[i][len(matrix)-i-1] = matrix[i][len(matrix)-i-1], matrix[i][i] NEW_LINE DEDENT NEW_LINE DEDENT 
def arcLength(diameter, angle): NEW_LINE INDENT pi = 22.0 / 7.0 NEW_LINE if angle >= 360: NEW_LINE INDENT print("Angle cannot be formed") NEW_LINE return 0 NEW_LINE DEDENT else: NEW_LINE INDENT arc = (pi * diameter) * (angle / 360) NEW_LINE return arc NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def breakSum(n): NEW_LINE INDENT if n == 0 or n == 1: return n NEW_LINE return max(breakSum(n // 2) + breakSum(n // 3) + breakSum(n // 4), n) NEW_LINE DEDENT
def isDivBy9(n): NEW_LINE INDENT if n == 0 or n == 9: return True NEW_LINE if n < 9: return False NEW_LINE return isDivBy9((n >> 3) - (n & 7)) NEW_LINE DEDENT
def isDivisible(str, k): NEW_LINE INDENT n = len(str) NEW_LINE c = 0 NEW_LINE for i in range(k): NEW_LINE INDENT if str[n - i - 1] == '0': NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c == k NEW_LINE DEDENT
def findSum(n): NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += (n * (n + 1)) // 2 NEW_LINE sum += (n * (n + 1) * (2 * n + 1)) // 6 NEW_LINE return sum NEW_LINE DEDENT
def findNth(n): NEW_LINE INDENT nthElement = 19 + (n - 1) * 9 NEW_LINE outliersCount = int(log10(nthElement)) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT
def decimalToBinary(N): NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while N != 0: NEW_LINE INDENT rem = N % 2 NEW_LINE c = 10 ** cnt NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT
def first(str, i=0): NEW_LINE INDENT if str[i:i+1] == '': return 0 NEW_LINE if str[i].isupper(): return str[i] NEW_LINE return first(str, i+1) NEW_LINE DEDENT
def lexSmallest(a: list, n: int) -> str: NEW_LINE INDENT a.sort() NEW_LINE answer = "" NEW_LINE for i in range(n): NEW_LINE INDENT answer += a[i] NEW_LINE DEDENT return answer NEW_LINE DEDENT 
def countSubStr(str): INDENT m = 0 NEW_LINE for i in range(len(str)): INDENT if str[i] == '1': INDENT m += 1 DEDENT DEDENT return m * (m - 1) // 2 NEW_LINE DEDENT
def remainder(str): NEW_LINE INDENT len = len(str) NEW_LINE num, rem = 0, 0 NEW_LINE for i in range(len): NEW_LINE INDENT num = rem * 10 + (ord(str[i]) - ord('0')) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT
def findRotations(str): NEW_LINE INDENT tmp = str + str NEW_LINE n = len(str) NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT substring = tmp[i:i + n] NEW_LINE if str == substring: NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
import random NEW_LINE def randomize(arr, n): INDENT for i in range(n-1, 0, -1): INDENT j = random.randint(0, i) NEW_LINE arr[i], arr[j] = arr[j], arr[i] DEDENT NEW_LINE DEDENT
def gcd(a, b): NEW_LINE INDENT if a < b: return gcd(b, a) NEW_LINE if abs(b) < 0.001: return a NEW_LINE else: return gcd(b, a - (a // b) * b) NEW_LINE DEDENT
def countNonDecreasing(n): NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range(1, n + 1): NEW_LINE INDENT count *= (N + i - 1) NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def countRect(n): INDENT ans = 0 NEW_LINE for length in range(1, int(n**0.5) + 1): INDENT for height in range(length, n // length + 1): INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def canMakeAllSame(str): INDENT zeros, ones = 0, 0 NEW_LINE for ch in str: INDENT zeros += 1 if ch == '0' else ones += 1 DEDENT return zeros == 1 or ones == 1 NEW_LINE DEDENT
def fib(n): INDENT if lookup[n] == NIL: INDENT if n <= 1: INDENT lookup[n] = n DEDENT else: INDENT lookup[n] = fib(n - 1) + fib(n - 2) DEDENT DEDENT return lookup[n] DEDENT NEW_LINE DEDENT
import random NEW_LINE def selectRandom(x): NEW_LINE INDENT global res, count NEW_LINE count += 1 NEW_LINE if count == 1: NEW_LINE INDENT res = x NEW_LINE DEDENT else: NEW_LINE INDENT i = random.randint(0, count - 1) NEW_LINE if i == count - 1: NEW_LINE INDENT res = x NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def transpose(A): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(i + 1, len(A)): NEW_LINE INDENT A[i][j], A[j][i] = A[j][i], A[i][j] NEW_LINE DEDENT DEDENT DEDENT
def printSquares(n): NEW_LINE INDENT square, prev_x = 0, 0 NEW_LINE for x in range(n): NEW_LINE INDENT square += x + prev_x NEW_LINE print(square, end=" ▁ ") NEW_LINE prev_x = x NEW_LINE DEDENT NEW_LINE DEDENT
def firstFactorialDivisibleNumber(x): INDENT i = 1 NEW_LINE fact = 1 NEW_LINE for i in range(1, x): INDENT fact *= i NEW_LINE if fact % x == 0: INDENT break DEDENT DEDENT return i NEW_LINE DEDENT
def getInvCount(arr, n): NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range(n-1): NEW_LINE INDENT for j in range(i+1, n): NEW_LINE INDENT if arr[i] > arr[j]: NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT
def countPairs(arr, n): NEW_LINE INDENT ans=0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i+1, n): NEW_LINE INDENT if arr[i] == arr[j]: NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def recursiveReverse(str, i=0): NEW_LINE INDENT n = len(str) NEW_LINE if i == n // 2: return NEW_LINE str[i], str[n-i-1] = str[n-i-1], str[i] NEW_LINE recursiveReverse(str, i+1) NEW_LINE DEDENT 
def countInRange(arr, n, x, y): NEW_LINE INDENT count = 0 NEW_LINE for i in range(n): NEW_LINE INDENT if x <= arr[i] <= y: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def isOverflow(a: int, b: int) -> bool: NEW_LINE INDENT if a == 0 or b == 0: return False NEW_LINE result = a * b NEW_LINE if a == result / b: return False NEW_LINE else: return True NEW_LINE DEDENT
def checkcircle(r, R, r1, x1, y1): NEW_LINE INDENT dis = (x1**2 + y1**2)**0.5 NEW_LINE return dis - r1 >= R and dis + r1 <= r NEW_LINE DEDENT
def octalToDecimal(n): INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while temp: INDENT last_digit = temp % 10 NEW_LINE temp = temp // 10 NEW_LINE dec_value += last_digit * base NEW_LINE base *= 8 DEDENT NEW_LINE return dec_value DEDENT
def isSymmetric(mat, N): NEW_LINE INDENT for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT if mat[i][j] != mat[j][i]: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
import random NEW_LINE def shuffle(card, n): INDENT random.seed() NEW_LINE for i in range(n): INDENT r = i + random.randint(0, 51 - i) NEW_LINE card[i], card[r] = card[r], card[i] DEDENT NEW_LINE DEDENT
def minRevolutions(r, x1, y1, x2, y2): NEW_LINE INDENT d = ( (x1 - x2)**2 + (y1 - y2)**2 )**0.5 NEW_LINE return ceil(d / (2 * r)) NEW_LINE DEDENT 
def countCommon(mat, n): INDENT res = 0 NEW_LINE for i in range(n): INDENT if mat[i][i] == mat[i][n-i-1]: INDENT res += 1 DEDENT DEDENT return res NEW_LINE DEDENT
def isPrime(n, i=2): NEW_LINE INDENT if n <= 2: return n == 2 NEW_LINE if n % i == 0: return False NEW_LINE if i * i > n: return True NEW_LINE return isPrime(n, i + 1) NEW_LINE DEDENT
def maxProd(n): NEW_LINE INDENT if n == 2 or n == 3: return n - 1 NEW_LINE res = 1 NEW_LINE while n > 4: NEW_LINE INDENT n -= 3 NEW_LINE res *= 3 NEW_LINE DEDENT return n * res NEW_LINE DEDENT 
def minTime(arr, n, m): NEW_LINE INDENT t = 0 NEW_LINE while True: NEW_LINE INDENT items = sum(t // arr[i] for i in range(n)) NEW_LINE if items >= m: NEW_LINE INDENT return t NEW_LINE DEDENT t += 1 NEW_LINE DEDENT NEW_LINE DEDENT
def isPossibleTriangle(arr, N): INDENT if N < 3: return False NEW_LINE arr.sort() NEW_LINE for i in range(N - 2): INDENT if arr[i] + arr[i+1] > arr[i+2]: return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def middleOfThree(a, b, c): NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0: NEW_LINE INDENT return b NEW_LINE DEDENT elif x * z > 0: NEW_LINE INDENT return c NEW_LINE DEDENT else: NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT 
def findRepeating(arr, n): NEW_LINE INDENT s = set() NEW_LINE for i in range(n): NEW_LINE INDENT if arr[i] in s: NEW_LINE INDENT return arr[i] NEW_LINE DEDENT s.add(arr[i]) NEW_LINE DEDENT return -1 NEW_LINE DEDENT 
def maxArea(a, b, c, d): NEW_LINE INDENT semiperimeter = (a + b + c + d) / 2 NEW_LINE return (semiperimeter - a) * (semiperimeter - b) * (semiperimeter - c) * (semiperimeter - d) ** 0.5 NEW_LINE DEDENT
def findDigits(n): NEW_LINE INDENT if n < 0: return 0 NEW_LINE if n <= 1: return 1 NEW_LINE digits = 0 NEW_LINE for i in range(2, n+1): NEW_LINE INDENT digits += log10(i) NEW_LINE DEDENT return int(floor(digits) + 1) NEW_LINE DEDENT
def isInorder(arr: list, n: int) -> bool: NEW_LINE INDENT if n == 0 or n == 1: return True NEW_LINE for i in range(1, n): NEW_LINE INDENT if arr[i - 1] > arr[i]: return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def isMajority(a, n): NEW_LINE INDENT mp = {} NEW_LINE for i in range(n): NEW_LINE INDENT mp[a[i]] = mp.get(a[i], 0) + 1 NEW_LINE DEDENT for x in mp.items(): NEW_LINE INDENT if x[1] >= n / 2: NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def findStep(n): NEW_LINE INDENT if n == 1 or n == 0: return 1 NEW_LINE elif n == 2: return 2 NEW_LINE else: return findStep(n - 3) + findStep(n - 2) + findStep(n - 1) NEW_LINE DEDENT
def findPosition(k, n): NEW_LINE INDENT f1, f2, f3 = 0, 1, 0 NEW_LINE for i in range(2, MAX+1): NEW_LINE INDENT f3 = f1 + f2 NEW_LINE f1, f2 = f2, f3 NEW_LINE if f2 % k == 0: NEW_LINE INDENT return n * i NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def minimum_cost(a, n): NEW_LINE INDENT mn = float('inf') NEW_LINE sum = 0 NEW_LINE for i in range(n): NEW_LINE INDENT mn = min(a[i], mn) NEW_LINE sum += a[i] NEW_LINE DEDENT return mn * (sum - mn) NEW_LINE DEDENT 
def kthdigit(a, b, k): INDENT p = int(pow(a, b)) NEW_LINE count = 0 NEW_LINE while p > 0 and count < k: INDENT rem = p % 10 NEW_LINE count += 1 NEW_LINE if count == k: return rem NEW_LINE p = p // 10 DEDENT NEW_LINE return 0 DEDENT NEW_LINE
def numberOfWays(x): NEW_LINE INDENT dp = [0] * (x + 1) NEW_LINE dp[0], dp[1] = 1, 1 NEW_LINE for i in range(2, x + 1): NEW_LINE INDENT dp[i] = dp[i - 1] + (i - 1) * dp[i - 2] NEW_LINE DEDENT return dp[x] NEW_LINE DEDENT
def sumNodes(l): NEW_LINE INDENT leafNodeCount = 2 ** (l - 1) NEW_LINE sumLastLevel = (leafNodeCount * (leafNodeCount + 1)) // 2 NEW_LINE sum = sumLastLevel * l NEW_LINE return sum NEW_LINE DEDENT
def leonardo(n): NEW_LINE INDENT dp = [1] * (n + 1) NEW_LINE dp[0] = dp[1] = 1 NEW_LINE for i in range(2, n + 1): NEW_LINE INDENT dp[i] = dp[i - 1] + dp[i - 2] + 1 NEW_LINE DEDENT return dp[n] NEW_LINE DEDENT
def add(A, B, C): NEW_LINE INDENT for i in range(N): NEW_LINE INDENT for j in range(N): NEW_LINE INDENT C[i][j] = A[i][j] + B[i][j] NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def arraySortedOrNot(arr, n): NEW_LINE INDENT if n == 0 or n == 1: return True NEW_LINE for i in range(1, n): NEW_LINE INDENT if arr[i - 1] > arr[i]: return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findSum(n): NEW_LINE INDENT multiTerms = n * (n + 1) // 2 NEW_LINE sum = multiTerms NEW_LINE for i in range(2, n + 1): NEW_LINE INDENT multiTerms -= (i - 1) NEW_LINE sum += multiTerms * i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isCornerPresent(str, corner): NEW_LINE INDENT n = len(str) NEW_LINE cl = len(corner) NEW_LINE if n < cl: NEW_LINE INDENT return False NEW_LINE DEDENT return str[:cl] == corner and str[-cl:] == corner NEW_LINE DEDENT
def isDiagonalMatrix(mat): NEW_LINE INDENT for i in range(len(mat)): NEW_LINE INDENT for j in range(len(mat)): NEW_LINE INDENT if i != j and mat[i][j] != 0: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def minimumflip(mat, n): INDENT flip = 0 NEW_LINE for i in range(n): INDENT for j in range(i): INDENT if mat[i][j] != mat[j][i]: INDENT flip += 1 DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT
def findIndex(n): INDENT if n <= 1: return n NEW_LINE a, b, c = 0, 1, 1 NEW_LINE res = 1 NEW_LINE while c < n: INDENT c = a + b NEW_LINE res += 1 NEW_LINE a = b NEW_LINE b = c DEDENT return res NEW_LINE DEDENT
def constructArr(arr, pair, n): NEW_LINE INDENT arr[0] = (pair[0] + pair[1] - pair[n-1]) // 2 NEW_LINE for i in range(1, n): NEW_LINE INDENT arr[i] = pair[i - 1] - arr[0] NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def checkMarkov(m): NEW_LINE INDENT for i in range(len(m)): NEW_LINE INDENT sum = 0 NEW_LINE for j in range(len(m[i])): NEW_LINE INDENT sum += m[i][j] DEDENT NEW_LINE if sum != 1: NEW_LINE INDENT return False DEDENT DEDENT NEW_LINE return True NEW_LINE DEDENT
def findMod(a, b): NEW_LINE INDENT mod = -a if a < 0 else a NEW_LINE b = -b if b < 0 else b NEW_LINE while mod >= b: NEW_LINE INDENT mod -= b NEW_LINE DEDENT return -mod if a < 0 else mod NEW_LINE DEDENT
def recursiveReverse(str): NEW_LINE INDENT st = [] NEW_LINE for i in range(len(str)): NEW_LINE INDENT st.append(str[i]) NEW_LINE DEDENT for i in range(len(str)): NEW_LINE INDENT str[i] = st.pop() NEW_LINE DEDENT DEDENT NEW_LINE
def multiply(A, B, C): NEW_LINE INDENT for i in range(len(A)): NEW_LINE INDENT for j in range(len(A[0])): NEW_LINE INDENT C[i][j] = A[i][j] - B[i][j] NEW_LINE DEDENT DEDENT DEDENT
def minValue(A, B, n): NEW_LINE INDENT A.sort() NEW_LINE B.sort() NEW_LINE result = 0 NEW_LINE for i in range(n): NEW_LINE INDENT result += A[i] * B[n - i - 1] NEW_LINE DEDENT return result NEW_LINE DEDENT
def decToBin(n): NEW_LINE INDENT if n == 0: return "0" NEW_LINE bin = "" NEW_LINE while n > 0: NEW_LINE INDENT bin = ('0' if (n & 1) == 0 else '1') + bin NEW_LINE n >>= 1 NEW_LINE DEDENT return bin.strip() NEW_LINE DEDENT 
def rotateMatrix(mat): NEW_LINE INDENT for i in range(N-1, -1, -1): NEW_LINE INDENT for j in range(N-1, -1, -1): NEW_LINE INDENT print(f"{mat[i][j]} ", end="") NEW_LINE DEDENT print() NEW_LINE DEDENT NEW_LINE DEDENT 
def russianPeasant(a: int, b: int) -> int: INDENT res = 0 NEW_LINE while b > 0: INDENT if b & 1: INDENT res += a DEDENT a <<= 1 NEW_LINE b >>= 1 DEDENT return res NEW_LINE DEDENT
def splitArr(arr, n, k): NEW_LINE INDENT for i in range(k): NEW_LINE INDENT x = arr[0] NEW_LINE for j in range(n-1): NEW_LINE INDENT arr[j] = arr[j+1] DEDENT arr[n-1] = x DEDENT DEDENT DEDENT NEW_LINE DEDENT
def CountPairs(n): INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while imin <= n: INDENT imax = n // k NEW_LINE ans += k * (imax - imin + 1) NEW_LINE imin = imax + 1 NEW_LINE k = n // imin NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lastPosition(n, m, k): INDENT if m <= n - k + 1: INDENT return m + k - 1 DEDENT m = m - (n - k + 1) NEW_LINE return n if m % n == 0 else m % n DEDENT
def minimumSquare(a, b): NEW_LINE INDENT result, rem = 0, 0 NEW_LINE if a < b: NEW_LINE INDENT a, b = b, a NEW_LINE DEDENT while b > 0: NEW_LINE INDENT result += a // b NEW_LINE rem = a % b NEW_LINE a, b = b, rem NEW_LINE DEDENT return result NEW_LINE DEDENT
def printFibonacciNumbers(n): NEW_LINE INDENT f1, f2 = 0, 1 NEW_LINE if n < 1: NEW_LINE INDENT return NEW_LINE DEDENT for i in range(1, n + 1): NEW_LINE INDENT print(f2, end=' ▁ ') NEW_LINE next = f1 + f2 NEW_LINE f1, f2 = f2, next NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def minLexRotation(str): NEW_LINE INDENT n = len(str) NEW_LINE arr = [str + str[i:i+n] for i in range(n)] NEW_LINE arr.sort() NEW_LINE return arr[0] NEW_LINE DEDENT
def search(arr, n, x): NEW_LINE INDENT i = 0 NEW_LINE while i <= n - 1: NEW_LINE INDENT if arr[i] == x: NEW_LINE INDENT return i NEW_LINE DEDENT i += abs(arr[i] - x) NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def findHeight(parent, n): INDENT res = 0 NEW_LINE for i in range(n): INDENT p, current = i, 1 NEW_LINE while parent[p] != -1: INDENT current += 1 NEW_LINE p = parent[p] DEDENT res = max(res, current) DEDENT return res DEDENT NEW_LINE DEDENT
def maxPrefix(s, t): NEW_LINE INDENT count = 0 NEW_LINE for i in range(len(t)): NEW_LINE INDENT if count == len(s): NEW_LINE INDENT break NEW_LINE DEDENT if t[i] == s[count]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findMaximum(arr, low, high): INDENT max = arr[low] NEW_LINE for i in range(low + 1, high + 1): INDENT if arr[i] > max: INDENT max = arr[i] DEDENT else: INDENT break DEDENT DEDENT return max NEW_LINE DEDENT
def findSum(str): NEW_LINE INDENT temp = "" NEW_LINE sum = 0 NEW_LINE for ch in str: NEW_LINE INDENT if ch.isdigit(): NEW_LINE INDENT temp += ch NEW_LINE DEDENT else: NEW_LINE INDENT sum += int(temp) if temp else 0 NEW_LINE temp = "" NEW_LINE DEDENT DEDENT return sum + int(temp) if temp else 0 NEW_LINE DEDENT
def mirrorImage(a, b, c, x1, y1): INDENT temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b) NEW_LINE x = temp * a + x1 NEW_LINE y = temp * b + y1 NEW_LINE return (x, y) NEW_LINE DEDENT
def moduloMultiplication(a: int, b: int, mod: int) -> int: INDENT res = 0 NEW_LINE a %= mod NEW_LINE while b: INDENT if b & 1: INDENT res = (res + a) % mod DEDENT a = (2 * a) % mod NEW_LINE b >>= 1 DEDENT return res DEDENT NEW_LINE DEDENT
def subset(arr): NEW_LINE INDENT mp = {} NEW_LINE for i in arr: NEW_LINE INDENT mp[i] = mp.get(i, 0) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in mp.values(): NEW_LINE INDENT res = max(res, x) NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMinDiff(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE diff = float('inf') NEW_LINE for i in range(n-1): NEW_LINE INDENT if arr[i+1] - arr[i] < diff: NEW_LINE INDENT diff = arr[i+1] - arr[i] NEW_LINE DEDENT NEW_LINE DEDENT return diff NEW_LINE DEDENT
def countSquares(a, b): INDENT NEW_LINE count = 0 NEW_LINE for i in range(a, b + 1): NEW_LINE INDENT for j in range(1, int(i**0.5) + 1): NEW_LINE INDENT if j * j == i: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def count_of_ways(n): NEW_LINE INDENT count = 0 NEW_LINE for i in range(n + 1): NEW_LINE INDENT for j in range(n + 1): NEW_LINE INDENT for k in range(n + 1): NEW_LINE INDENT if i + j + k == n: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countFriendsPairings(n): NEW_LINE INDENT a, b, c = 1, 2, 0 NEW_LINE if n <= 2: NEW_LINE INDENT return n NEW_LINE DEDENT for i in range(3, n + 1): NEW_LINE INDENT c = b + (i - 1) * a NEW_LINE a, b = b, c NEW_LINE DEDENT return c NEW_LINE DEDENT
def exponentiation(base, exp): INDENT t = 1 NEW_LINE while exp > 0: INDENT if exp % 2 != 0: INDENT t = (t * base) % N DEDENT base = (base * base) % N NEW_LINE exp //= 2 DEDENT return t % N NEW_LINE DEDENT
def countSolutions(n): NEW_LINE INDENT res = 0 NEW_LINE for x in range(n): NEW_LINE INDENT for y in range(n): NEW_LINE INDENT if x*x + y*y < n: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def maximizecube(l, b, h): INDENT side = math.gcd(l, math.gcd(b, h)) NEW_LINE num = l // side NEW_LINE num = (num * b) // side NEW_LINE num = (num * h) // side NEW_LINE print(side, '▁', num) NEW_LINE DEDENT 
def minXOR(arr, n): NEW_LINE INDENT min_xor = float('inf') NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT min_xor = min(min_xor, arr[i] ^ arr[j]) NEW_LINE DEDENT DEDENT DEDENT return min_xor NEW_LINE DEDENT
def maxProduct(arr): NEW_LINE INDENT if len(arr) < 3: return -1 NEW_LINE arr.sort() NEW_LINE return max(arr[0] * arr[1] * arr[-1], arr[-1] * arr[-2] * arr[-3]) NEW_LINE DEDENT
def isDivisibleBy7(num): NEW_LINE INDENT if num < 0: return isDivisibleBy7(-num) NEW_LINE if num == 0 or num == 7: return 1 NEW_LINE if num < 10: return 0 NEW_LINE return isDivisibleBy7(num // 10 - 2 * (num % 10)) NEW_LINE DEDENT
def eulerian(n, m): NEW_LINE INDENT if m >= n or n == 0: return 0 NEW_LINE if m == 0: return 1 NEW_LINE return (n - m) * eulerian(n - 1, m - 1) + (m + 1) * eulerian(n - 1, m) NEW_LINE DEDENT
def recSearch(arr, l, r, x): INDENT if r < l: return -1 NEW_LINE if arr[l] == x: return l NEW_LINE if arr[r] == x: return r NEW_LINE return recSearch(arr, l + 1, r - 1, x) NEW_LINE DEDENT
def numofsubset(arr): NEW_LINE INDENT arr.sort() NEW_LINE count = 1 NEW_LINE for i in range(len(arr) - 1): NEW_LINE INDENT if arr[i] + 1 != arr[i + 1]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def binaryToDecimal(n): NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE len = len(num) NEW_LINE for i in range(len - 1, -1, -1): NEW_LINE INDENT if num[i] == '1': NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base *= 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def countSubstringWithEqualEnds(s): NEW_LINE INDENT result = 0 NEW_LINE n = len(s) NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i, n): NEW_LINE INDENT if s[i] == s[j]: NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def binarySearch(arr, l, r, x): NEW_LINE INDENT while l <= r: NEW_LINE INDENT m = l + (r - l) // 2 NEW_LINE if arr[m] == x: return m NEW_LINE if arr[m] < x: l = m + 1 NEW_LINE else: r = m - 1 NEW_LINE DEDENT return -1 NEW_LINE DEDENT
def decToBinary(n): NEW_LINE INDENT binaryNum = [0] * 32 NEW_LINE i = 0 NEW_LINE while n > 0: NEW_LINE INDENT binaryNum[i] = n % 2 NEW_LINE n = n // 2 NEW_LINE i += 1 NEW_LINE DEDENT for j in range(i - 1, -1, -1): NEW_LINE INDENT print(binaryNum[j], end='') NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def mulmod(a, b, mod): NEW_LINE INDENT res = 0 NEW_LINE a = a % mod NEW_LINE while b > 0: NEW_LINE INDENT if b % 2 == 1: NEW_LINE INDENT res = (res + a) % mod NEW_LINE DEDENT a = (a * 2) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT
def firstNonRepeating(arr, n): INDENT from collections import Counter NEW_LINE mp = Counter(arr) NEW_LINE for i in range(n): INDENT if mp[arr[i]] == 1: INDENT return arr[i] NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def middleOfThree(a, b, c): NEW_LINE INDENT if (a < b and b < c) or (c < b and b < a): return b NEW_LINE elif (b < a and a < c) or (c < a and a < b): return a NEW_LINE else: return c NEW_LINE DEDENT
class Solution: NEW_LINE INDENT def multiply(self, x, y): NEW_LINE INDENT if y == 0: NEW_LINE INDENT return 0 NEW_LINE DEDENT if y > 0: NEW_LINE INDENT return x + self.multiply(x, y - 1) NEW_LINE DEDENT if y < 0: NEW_LINE INDENT return -self.multiply(x, -y) NEW_LINE DEDENT NEW_LINE DEDENT DEDENT
def to_upper(in_string): NEW_LINE INDENT for i in range(len(in_string)): NEW_LINE INDENT if 'a' <= in_string[i] <= 'z': NEW_LINE INDENT in_string = in_string[:i] + chr(ord(in_string[i]) - ord('a') + ord('A')) + in_string[i+1:] NEW_LINE DEDENT DEDENT DEDENT return in_string NEW_LINE DEDENT
def findMinSum(a, b, n): NEW_LINE INDENT a.sort() NEW_LINE b.sort() NEW_LINE sum = 0 NEW_LINE for i in range(n): NEW_LINE INDENT sum += abs(a[i] - b[i]) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkCount(arr, n, k): NEW_LINE INDENT hash = {} NEW_LINE for i in range(n): NEW_LINE INDENT hash[arr[i]] = hash.get(arr[i], 0) + 1 NEW_LINE DEDENT for x, count in hash.items(): NEW_LINE INDENT if count > 2 * k: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def nonFibonacci(n): INDENT prevPrev, prev, curr = 1, 2, 3 NEW_LINE while n > 0: INDENT prevPrev, prev = prev, curr NEW_LINE curr = prevPrev + prev NEW_LINE n -= (curr - prev - 1) DEDENT NEW_LINE n += (curr - prev - 1) NEW_LINE return prev + n NEW_LINE DEDENT
def minXOR(arr): NEW_LINE INDENT arr.sort() NEW_LINE minXor, val = float('inf'), 0 NEW_LINE for i in range(len(arr) - 1): NEW_LINE INDENT val = arr[i] ^ arr[i + 1] NEW_LINE minXor = min(minXor, val) NEW_LINE DEDENT return minXor NEW_LINE DEDENT
def isPowerOfFour(n): NEW_LINE INDENT count = 0 NEW_LINE if n and not(n & (n - 1)): NEW_LINE INDENT while n > 1: NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return count % 2 == 0 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def firstNonRepeating(arr, n): INDENT for i in range(n): INDENT j = 0 INDENT for j in range(n): INDENT if i != j and arr[i] == arr[j]: INDENT break NEW_LINE DEDENT if j == n: INDENT return arr[i] NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def power(x, y, p): NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0: NEW_LINE INDENT if y & 1: NEW_LINE INDENT res = (res * x) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = (x * x) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPossible(a, b, n, k): NEW_LINE INDENT a.sort() NEW_LINE b.sort(reverse=True) NEW_LINE for i in range(n): NEW_LINE INDENT if a[i] + b[i] < k: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def printDistinct(arr, n): NEW_LINE INDENT s = set() NEW_LINE for i in range(n): NEW_LINE INDENT if arr[i] not in s: NEW_LINE INDENT s.add(arr[i]) NEW_LINE print(arr[i], end=' ▁ ') NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT
def countSeq(n): INDENT res, nCr = 1, 1 NEW_LINE for r in range(1, n+1): INDENT nCr = (nCr * (n + 1 - r)) // r NEW_LINE res += nCr * nCr DEDENT NEW_LINE return res DEDENT
def countNegative(M, n, m): INDENT count = 0 NEW_LINE for i in range(n): INDENT for j in range(m): INDENT if M[i][j] < 0: INDENT count += 1 DEDENT else: INDENT break DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def isPrime(p): NEW_LINE INDENT checkNumber = pow(2, p) - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range(1, p - 1): NEW_LINE INDENT nextval = (nextval * nextval - 2) % checkNumber NEW_LINE DEDENT return nextval == 0 NEW_LINE DEDENT
def minPerimeter(n): NEW_LINE INDENT l = int(n**0.5) NEW_LINE sq = l * l NEW_LINE if sq == n: NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else: NEW_LINE INDENT row = n // l NEW_LINE perimeter = 2 * (l + row) NEW_LINE if n % l != 0: NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT
def sequence(n): NEW_LINE INDENT f = [0] * (n + 1) NEW_LINE f[0], f[1], f[2] = 0, 1, 1 NEW_LINE for i in range(3, n + 1): NEW_LINE INDENT f[i] = f[f[i - 1]] + f[i - f[i - 1]] NEW_LINE DEDENT return f[n] NEW_LINE DEDENT
def countIntegralSolutions(n): INDENT result = 0 NEW_LINE for i in range(n+1): INDENT for j in range(n+1-i): INDENT for k in range(n+1-i-j): INDENT if i+j+k == n: INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def maxGameByWinner(N): INDENT dp = [0] * (N + 1) NEW_LINE dp[0], dp[1] = 1, 2 NEW_LINE i = 2 NEW_LINE while True: INDENT dp[i] = dp[i - 1] + dp[i - 2] NEW_LINE if dp[i] > N: INDENT break DEDENT NEW_LINE i += 1 DEDENT NEW_LINE return i - 2 NEW_LINE DEDENT
def numberOfPaths(m, n): NEW_LINE INDENT dp = [1] * n NEW_LINE for i in range(m): NEW_LINE INDENT for j in range(1, n): NEW_LINE INDENT dp[j] += dp[j - 1] NEW_LINE DEDENT DEDENT return dp[n - 1] NEW_LINE DEDENT
def minOperation(arr, n): NEW_LINE INDENT hash = {} NEW_LINE for i in range(n): NEW_LINE INDENT hash[arr[i]] = hash.get(arr[i], 0) + 1 NEW_LINE DEDENT max_count = 0 NEW_LINE for key, value in hash.items(): NEW_LINE INDENT if max_count < value: NEW_LINE INDENT max_count = value NEW_LINE DEDENT DEDENT return n - max_count NEW_LINE DEDENT
def bubbleSort(arr): NEW_LINE INDENT n = len(arr) NEW_LINE for i in range(n-1): NEW_LINE INDENT for j in range(n-i-1): NEW_LINE INDENT if arr[j] > arr[j+1]: NEW_LINE INDENT arr[j], arr[j+1] = arr[j+1], arr[j] NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT
def findCombinations(str, index, out): NEW_LINE INDENT if index == len(str): NEW_LINE INDENT print(out) NEW_LINE DEDENT for i in range(index, len(str)): NEW_LINE INDENT findCombinations(str, i + 1, out + " ( " + str[index:i + 1] + " ) ") NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def countDivisibles(arr, n): NEW_LINE INDENT res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if arr[i] % arr[j] == 0 or arr[j] % arr[i] == 0: NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def maxTasks(high, low, n): NEW_LINE INDENT if n <= 0: return 0 NEW_LINE return max(high[n-1] + maxTasks(high, low, n-2), low[n-1] + maxTasks(high, low, n-1)) NEW_LINE DEDENT
def printDistinct(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT j = 0 NEW_LINE while j < i and arr[i] != arr[j]: NEW_LINE INDENT j += 1 NEW_LINE DEDENT if i == j: NEW_LINE INDENT print(arr[i], end=' ▁ ') NEW_LINE DEDENT DEDENT NEW_LINE DEDENT
def findElements(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT count = 0 NEW_LINE for j in range(n): NEW_LINE INDENT if arr[j] > arr[i]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count >= 2: NEW_LINE INDENT print(arr[i], end=" ▁ ") NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT
def nearestSmallerEqFib(n): INDENT if n == 0 or n == 1: return n NEW_LINE f1, f2, f3 = 0, 1, 1 NEW_LINE while f3 <= n: INDENT f1, f2 = f2, f3 NEW_LINE f3 = f1 + f2 DEDENT NEW_LINE return f2 NEW_LINE DEDENT
def findMinDiff(arr, n): NEW_LINE INDENT diff = float('inf') NEW_LINE for i in range(n - 1): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT if abs(arr[i] - arr[j]) < diff: NEW_LINE INDENT diff = abs(arr[i] - arr[j]) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT
def subArray(arr, n): NEW_LINE INDENT for i in range(n): NEW_LINE INDENT for j in range(i, n): NEW_LINE INDENT for k in range(i, j + 1): NEW_LINE INDENT print(arr[k], end=' ▁ ') NEW_LINE DEDENT print() NEW_LINE DEDENT DEDENT DEDENT NEW_LINE DEDENT 
def distancesum(x, y, n): NEW_LINE INDENT sum = 0 NEW_LINE for i in range(n): NEW_LINE INDENT for j in range(i + 1, n): NEW_LINE INDENT sum += (abs(x[i] - x[j]) + abs(y[i] - y[j])) NEW_LINE DEDENT NEW_LINE DEDENT NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def countWays(n): INDENT table = [0] * (n + 1) NEW_LINE table[0] = 1 NEW_LINE for i in range(1, n): INDENT for j in range(i, n + 1): INDENT table[j] += table[j - i] DEDENT DEDENT return table[n] DEDENT NEW_LINE DEDENT
def maxSubarrayXOR(arr, n): NEW_LINE INDENT ans = float('-inf') NEW_LINE for i in range(n): NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range(i, n): NEW_LINE INDENT curr_xor = curr_xor ^ arr[j] NEW_LINE ans = max(ans, curr_xor) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isIdentity(mat, N): NEW_LINE INDENT for row in range(N): NEW_LINE INDENT for col in range(N): NEW_LINE INDENT if row == col and mat[row][col] != 1: NEW_LINE INDENT return False NEW_LINE DEDENT elif row != col and mat[row][col] != 0: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def insertSorted(arr, n, key, capacity): NEW_LINE INDENT if n >= capacity: return n NEW_LINE i = n - 1 NEW_LINE while i >= 0 and arr[i] > key: NEW_LINE INDENT arr[i + 1] = arr[i] NEW_LINE i -= 1 DEDENT arr[i + 1] = key NEW_LINE return n + 1 NEW_LINE DEDENT
def solve(arr, n): NEW_LINE INDENT arr.sort() NEW_LINE a, b = 0, 0 NEW_LINE for i in range(n): NEW_LINE INDENT if i & 1: NEW_LINE INDENT a = a * 10 + arr[i] NEW_LINE DEDENT else: NEW_LINE INDENT b = b * 10 + arr[i] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def findSum(A, B, n): INDENT NEW_LINE hash = {} NEW_LINE for i in range(n): INDENT NEW_LINE hash[A[i]] = hash.get(A[i], 0) + 1 NEW_LINE hash[B[i]] = hash.get(B[i], 0) + 1 DEDENT NEW_LINE sum = 0 NEW_LINE for x in hash.items(): INDENT NEW_LINE if x[1] == 1: INDENT NEW_LINE sum += x[0] DEDENT DEDENT NEW_LINE return sum DEDENT NEW_LINE DEDENT
def maxLen(arr, n): NEW_LINE INDENT max_len = 0 NEW_LINE for i in range(n): NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range(i, n): NEW_LINE INDENT curr_sum += arr[j] NEW_LINE if curr_sum == 0: NEW_LINE INDENT max_len = max(max_len, j - i + 1) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT
def minRadius(k, x, y, n): NEW_LINE INDENT dis = [x[i] * x[i] + y[i] * y[i] for i in range(n)] NEW_LINE dis.sort() NEW_LINE return dis[k - 1] NEW_LINE DEDENT
def generate(ones, zeroes, str, len): NEW_LINE INDENT if len == len(str): NEW_LINE INDENT print(str, end=" ▁ ▁ ") NEW_LINE return NEW_LINE DEDENT generate(ones + 1, zeroes, str + "1", len) NEW_LINE if ones > zeroes: NEW_LINE INDENT generate(ones, zeroes + 1, str + "0", len) NEW_LINE DEDENT DEDENT NEW_LINE DEDENT 
def search(arr, n, x): INDENT while i < n: INDENT if arr[i] == x: return i DEDENT i += abs(arr[i] - x) DEDENT print("number is not present!") return -1 NEW_LINE DEDENT
def search(arr, n, x, k): INDENT NEW_LINE i = 0 NEW_LINE while i < n: INDENT NEW_LINE if arr[i] == x: NEW_LINE INDENT return i DEDENT NEW_LINE i += max(1, abs(arr[i] - x) // k) DEDENT NEW_LINE print("number is not present!") NEW_LINE return -1 DEDENT NEW_LINE DEDENT
def countPairsWithDiffK(arr, n, k): INDENT count = 0 NEW_LINE for i in range(n): INDENT for j in range(i + 1, n): INDENT if abs(arr[i] - arr[j]) == k: INDENT count += 1 DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def countNegative(M, n, m): INDENT count = 0 NEW_LINE i = 0 NEW_LINE j = m - 1 NEW_LINE while j >= 0 and i < n: INDENT if M[i][j] < 0: INDENT count += j + 1 NEW_LINE i += 1 DEDENT else: INDENT j -= 1 DEDENT DEDENT return count NEW_LINE DEDENT
def findMinX(num, rem, k): NEW_LINE INDENT x = 1 NEW_LINE while True: NEW_LINE INDENT for j in range(k): NEW_LINE INDENT if x % num[j] != rem[j]: NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == k: NEW_LINE INDENT return x NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT
def removeDuplicates(S): NEW_LINE INDENT n = len(S) NEW_LINE if n < 2: return NEW_LINE j = 0 NEW_LINE for i in range(1, n): NEW_LINE INDENT if S[j] != S[i]: NEW_LINE INDENT j += 1 NEW_LINE S[j] = S[i] NEW_LINE DEDENT DEDENT j += 1 NEW_LINE S[j] = '\0' NEW_LINE DEDENT
def distributingBalls(k, n, str): NEW_LINE INDENT a = [0] * 26 NEW_LINE for i in range(n): NEW_LINE INDENT a[ord(str[i]) - ord('a')] += 1 NEW_LINE DEDENT for i in range(26): NEW_LINE INDENT if a[i] > k: NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def insertionSortRecursive(arr, n): NEW_LINE INDENT if n <= 1: return NEW_LINE insertionSortRecursive(arr, n - 1) NEW_LINE last = arr[n - 1] NEW_LINE j = n - 2 NEW_LINE while j >= 0 and arr[j] > last: NEW_LINE INDENT arr[j + 1] = arr[j] NEW_LINE j -= 1 NEW_LINE DEDENT arr[j + 1] = last NEW_LINE DEDENT
def areEqual(arr1, arr2, n, m): NEW_LINE INDENT if n != m: return False NEW_LINE arr1.sort() NEW_LINE arr2.sort() NEW_LINE for i in range(n): NEW_LINE INDENT if arr1[i] != arr2[i]: return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def getOddOccurrence(arr, arr_size): NEW_LINE INDENT for i in range(arr_size): NEW_LINE INDENT count = 0 NEW_LINE for j in range(arr_size): NEW_LINE INDENT if arr[i] == arr[j]: NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count % 2 != 0: NEW_LINE INDENT return arr[i] NEW_LINE DEDENT DEDENT return -1 NEW_LINE DEDENT
def checkIsAP(arr, n): NEW_LINE INDENT if n == 1: return True NEW_LINE arr.sort() NEW_LINE d = arr[1] - arr[0] NEW_LINE for i in range(2, n): NEW_LINE INDENT if arr[i] - arr[i - 1] != d: return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def minOps(arr, n, k): NEW_LINE INDENT max_val = max(arr) NEW_LINE res = 0 NEW_LINE for i in range(n): NEW_LINE INDENT if (max_val - arr[i]) % k != 0: NEW_LINE INDENT return -1 NEW_LINE DEDENT else: NEW_LINE INDENT res += (max_val - arr[i]) // k NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
