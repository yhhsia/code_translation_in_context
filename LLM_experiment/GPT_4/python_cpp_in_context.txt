double areaSquare(double side) { double area = side * side; return area; }
int intersection(int n) { return n * (n - 1); }
int fun(int n) { return n & (n - 1); }
int cassini(int n) { return (n & 1) ? -1 : 1; }
int hexagonalNum(int n) { return n * (2 * n - 1); }
int addOne(int x) { return -~x; }
double circumference(double r) { return (2 * 3.14159265358979323846 * r); }
double find_Area(double r) { return 2 * r * r; }
bool check(int n) { return 1162261467 % n == 0; }
void mergeTwoHalf(int A[], int n) { std::sort(A, A + n); }
bool isEven(int n) { return (n % 2 == 0); }
int largest(int arr[], int n) { int max = arr[0]; for(int i = 1; i < n; i++) if(arr[i] > max) max = arr[i]; return max; }
#include <cmath> int height(int N) { return std::ceil(std::log2(N + 1)) - 1; }
int numberOfSticks(int x) { return (3 * x * (x + 1)) / 2; }
double summingSeries(int n) { return n * n; }
int pentagonalNum(int n) { return (3 * n * n - n) / 2; }
bool isEven(int n) { return !(n & 1); }
int binomialCoeffSum(int n) { return (1 << n); }
int rangeGCD(int n, int m) { return (n == m) ? n : 1; }
int power(int n) { return n == 1 ? 2 : 2 * power(n - 1); }
int compute_average(int a, int b) { return (a + b) / 2; }
double Circumference(double a) { return 4 * a; }
int multiplyWith3Point5(int x) { return (x << 1) + x + (x >> 1); }
double slope(double x1, double y1, double x2, double y2) { return (y2 - y1) / (x2 - x1); }
unsigned int factorial(unsigned int n) { return (n == 1 || n == 0) ? 1 : n * factorial(n - 1); }
bool oppositeSigns(int x, int y) { return (x ^ y) < 0; }
unsigned int swapNibbles(unsigned int x) { return ((x & 0x0F) << 4 | (x & 0xF0) >> 4); }
int countNonEmptySubstr(string str) { int n = str.length(); return n * (n + 1) / 2; }
int getModulo(int n, int d) { return n & (d - 1); }
int nthTerm(int n) { return (n * n) + (n * n * n); }
bool isMultipleOf10(int n) { return (n % 15 == 0); }
unsigned int factorial(unsigned int n) { return (n == 1 || n == 0) ? 1 : n * factorial(n - 1); }
int count_of_ways(int n) { return (n + 1) * (n + 2) / 2; }
int gcd(int a, int b) { return a == 0 ? b : gcd(b % a, a); }
int rectCount(int n, int m) { return (m * n * (n + 1) * (m + 1)) / 4; }
double volumeOfEllipsoid(double r1, double r2, double r3) { return 1.33 * 3.14159265358979323846 * r1 * r2 * r3; }
int getRemainder(int num, int divisor) { return num % divisor; }
int findMaximumPieces(int n) { return int(1 + n * (n + 1) / 2); }
int evenbinomialCoeffSum(int n) { return 1 << (n - 1); }
int maximum; int _lis(const std::vector<int>& arr, int n); int lis(const std::vector<int>& arr) { int n = arr.size(); maximum = 1; _lis(arr, n); return maximum; }
double areaOctagon(double side) { return (2 * (1 + sqrt(2)) * side * side); }
#include <cmath> double surface_area_octahedron(double side) { return 2 * sqrt(3) * side * side; }
void sortit(int arr[], int n) { for(int i = 0; i < n; i++) arr[i] = i + 1; }
int findSum(int n) { return n * (n + 1) * (n + 2) * (3 * n + 1) / 24; }
double vol_of_octahedron(double side) { return (side * side * side) * (sqrt(2) / 3); }
int Resources(int process, int need) { int minResources = 0; minResources = process * (need - 1) + 1; return minResources; }
double procal(double n) { return (3.0 * n) / (4.0 * (n * n) - 1); }
int cost(const vector<int>& a, int n) { return (n - 1) * *min_element(a.begin(), a.end()); }
bool isPowerOfTwo(int x) { return (x && !(x & (x - 1))); }
unsigned int factorial(unsigned int n) { return (n == 1 || n == 0) ? 1 : n * factorial(n - 1); }
int findRepeating(int arr[], int n) { return sum(arr, arr + n) - (((n - 1) * n) / 2); }
std::string reverse(const std::string& str) { return std::string(str.rbegin(), str.rend()); }
int assignValue(int a, int b, int x) { int arr[] = {a, b}; return arr[x]; }
int countSetBits(int n) { int count = 0; while (n) { n &= (n - 1); count++; } return count; }
void bin(unsigned int n) { if (n > 1) { bin(n >> 1); } std::cout << (n & 1) << " "; }
double sumOfSeries(int n) { return 0.666 * (1 - 1 / pow(10, n)); }
int calculateSum(int n) { int sum = 0; sum = 1 << n; return (sum - 1); }
int countSetBits(int n) { return n == 0 ? 0 : (n & 1) + countSetBits(n >> 1); }
int countSetBits(int n) { return n == 0 ? 0 : 1 + countSetBits(n & (n - 1)); }
int kthSmallest(vector<int>& arr, int n, int k) { sort(arr.begin(), arr.end()); return arr[k - 1]; }
int maximum; int _lis(const vector<int>& arr, int n); int lis(const vector<int>& arr) { int n = arr.size(); maximum = 1; _lis(arr, n); return maximum; }
double getArea(double a) { double area = (3.14159265358979323846 * a * a) / 4; return area; }
std::string repeat(const std::string& s, int n) { std::string result = s; for (int i = 1; i < n; i++) result += s; return result; }
int yMod(int y, int x) { return y % (1 << x); }
int minSum(vector<int> A) { auto min_val = *min_element(A.begin(), A.end()); return min_val * (A.size() - 1); }
void reverse(const std::string& str, int index = 0) { if (index == str.size()) return; reverse(str, index + 1); std::cout << str[index] << ' '; }
int addOne(int x) { int m = 1; while (x & m) { x = x ^ m; m <<= 1; } x = x ^ m; return x; }
int search(int arr[], int n, int x) { for(int i = 0; i < n; i++) { if(arr[i] == x) return i; } return -1; }
double maxSquare(int b, int m) { return (b / m - 1) * (b / m) / 2; }
bool isNumber(const std::string& s) { for (int i = 0; i < s.length(); ++i) { if (!isdigit(s[i])) return false; } return true; }
void printArray(int a[], int n) { for(int i = 0; i < n; i++) std::cout << a[i] << " ▁ "; std::cout << std::endl; }
double findArea(double a) { return (sqrt(5 * (5 + 2 * (sqrt(5)))) * a * a) / 4; }
void printSubStr(const std::string& st, int low, int high) { std::cout << st.substr(low, high - low + 1); std::cout.flush(); }
int getAbs(int n) { int mask = n >> (sizeof(int) * CHAR_BIT - 1); return ((n + mask) ^ mask); }
int countStr(int n) { return 1 + (n * 2) + (n * ((n * n) - 1) / 2); }
int turnOffK(int n, int k) { if (k <= 0) return n; return n & ~(1 << (k - 1)); }
int fib(int n) { if (n <= 1) return n; return fib(n - 1) + fib(n - 2); }
int getOddOccurrence(vector<int>& arr) { int res = 0; for (auto& element : arr) res ^= element; return res; }
int CountSquares(int a, int b) { return (int)(floor(sqrt(b)) - ceil(sqrt(a)) + 1); }
int divisorSum(int n) { int sum = 0; for (int i = 1; i <= n; i++) sum += (n / i) * i; return sum; }
int maxTripletSum(int arr[], int n) { sort(arr, arr + n); return arr[n-1] + arr[n-2] + arr[n-3]; }
std::string evenlength(const std::string& n) { std::string res = n; for (int j = n.length() - 1; j >= 0; --j) res += n[j]; return res; }
int findSum(int N, int K) { int ans = 0; for(int i = 1; i <= N; i++) { ans += (i % K); } return ans; }
bool isPrime(int n) { if (n <= 1) return false; for (int i = 2; i < n; i++) { if (n % i == 0) return false; } return true; }
bool isPossible(const std::string& str, int n) { int l = str.length(); if (l >= n) return true; return false; }
void printFun(int test) { if (test < 1) return; else { std::cout << test << " ▁ "; printFun(test - 1); std::cout << test << " ▁ "; } }
int sequence(int n) { if (n == 1 || n == 2) return 1; else return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1)); }
unsigned int nextPowerOf2(unsigned int n) { unsigned int p = 1; if (n && !(n & (n - 1))) return n; while (p < n) p <<= 1; return p; }
int leonardo(int n) { if (n == 0 || n == 1) return 1; return leonardo(n - 1) + leonardo(n - 2) + 1; }
unsigned int nextPowerOf2(unsigned int n) { n--; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; n++; return n; }
double vol_of_dodecahedron(double side) { return (((15 + (7 * sqrt(5))) / 4) * pow(side, 3)); }
int PowerOFPINnfactorial(int n, int p) { int ans = 0, temp = p; while (temp <= n) { ans += n / temp; temp *= p; } return ans; }
int find(int n, int k) { return (n + 1 >= k) ? (k - 1) : (2 * n + 1 - k); }
bool isPowerOfFour(int n) { return (n != 0 && ((n & (n - 1)) == 0) && !(n & 0xAAAAAAAA)); }
int nswp(int n) { if (n == 0 || n == 1) return 1; return 2 * nswp(n - 1) + nswp(n - 2); }
int findTrailingZeros(int n) { int count = 0; for (int i = 5; n / i >= 1; i *= 5) count += n / i; return count; }
int getMissingNo(vector<int> A) { int n = A.size(); int total = (n + 1) * (n + 2) / 2; int sum_of_A = accumulate(A.begin(), A.end(), 0); return total - sum_of_A; }
int countPaths(int n, int m) { if (n == 0 || m == 0) return 1; return countPaths(n - 1, m) + countPaths(n, m - 1); }
int largestPower(int n, int p) { int x = 0; while (n) { n /= p; x += n; } return x; }
bool checkValidity(int a, int b, int c) { return !((a + b <= c) || (a + c <= b) || (b + c <= a)); }
void leftRotate(int arr[], int n, int k) { for(int i = k; i < k + n; i++) std::cout << arr[i % n] << " ▁ "; }
int findLastIndex(const std::string& str, char x) { int index = -1; for (int i = 0; i < str.size(); i++) { if (str[i] == x) { index = i; } } return index; }
int PowerOFPINnfactorial(int n, int p) { int ans = 0; int temp = p; while (temp <= n) { ans += n / temp; temp *= p; } return ans; }
int findLastIndex(const std::string& str, char x) { for (int i = str.size() - 1; i >= 0; --i) { if (str[i] == x) return i; } return -1; }
void printNos(int n) { if (n > 0) { printNos(n - 1); std::cout << n << " ▁ "; } }
void findLarger(std::vector<int>& arr, int n) { std::sort(arr.begin(), arr.end()); for(int i = n / 2; i < n; i++) { std::cout << arr[i] << " "; } }
void swap(int &xp, int &yp) { xp ^= yp; yp ^= xp; xp ^= yp; }
void printFactorialNums(int n) { int fact = 1, x = 2; while (fact <= n) { cout << fact << " ▁ "; fact *= x; x++; } }
int getMissingNo(int a[], int n) { int i, total = 1; for(i = 2; i <= n+1; i++) { total += i; total -= a[i-2]; } return total; }
unsigned int numberOfPaths(unsigned int m, unsigned int n) { return (m == 1 || n == 1) ? 1 : numberOfPaths(m - 1, n) + numberOfPaths(m, n - 1); }
int count(const std::string& s, char c) { int res = 0; for (int i = 0; i < s.length(); i++) { if (s[i] == c) res++; } return res; }
int maxvolume(int s) { int length = s / 3; s -= length; int breadth = s / 2; int height = s - breadth; return length * breadth * height; }
int horner(int poly[], int n, int x) { int result = poly[0]; for(int i = 1; i < n; i++) { result = result * x + poly[i]; } return result; }
int countDigits(int a, int b) { if (a == 0 || b == 0) return 1; return floor(log10(abs(a)) + log10(abs(b))) + 1; }
bool allCharactersSame(const std::string& s) { int n = s.length(); for(int i = 1; i < n; i++) { if(s[i] != s[0]) return false; } return true; }
bool isPower(int x, int y) { double res1 = log(y) / log(x); return res1 == floor(res1); }
int modInverse(int a, int m) { a = a % m; for (int x = 1; x < m; x++) { if ((a * x) % m == 1) { return x; } } return 1; }
int doublefactorial(int n) { int res = 1; for (int i = n; i > 0; i -= 2) res *= i; return res; }
void center(int x1, int x2, int y1, int y2) { std::cout << (x1 + x2) / 2 << " , " << (y1 + y2) / 2; }
double exponential(int n, double x) { double sum = 1.0; for (int i = n; i > 0; i--) { sum = 1 + x * sum / i; } std::cout << "e ^ x = " << sum << std::endl; }
int largest(int arr[], int n) { int max = arr[0]; for(int i = 1; i < n; i++) { if(arr[i] > max) max = arr[i]; } return max; }
unsigned int nextPowerOf2(unsigned int n) { unsigned int count = 0; if (n && !(n & (n - 1))) return n; while (n != 0) { n >>= 1; count++; } return 1 << count; }
int floorSqrt(int x) { if (x == 0 || x == 1) return x; int i = 1, result = 1; while (result <= x) { i++; result = i * i; } return i - 1; }
int search(const std::vector<int>& arr, int x) { for (int j = 0; j < arr.size(); j++) { if (x == arr[j]) return j; } return -1; }
bool isPower(int x, int y) { if (x == 1) return (y == 1); int pow = 1; while (pow < y) pow *= x; return (pow == y); }
int kthgroupsum(int k) { int cur = (k * (k - 1)) + 1, sum = 0; while (k) { sum += cur; cur += 2; k--; } return sum; }
int sumOfSeries(int n) { int sum = 0; for(int i = 1; i <= n; i++) { sum += (2 * i - 1) * (2 * i - 1); } return sum; }
bool divisibleBy20(const std::string& num) { int lastTwoDigits = std::stoi(num.substr(num.length() - 2)); return (lastTwoDigits % 20 == 0); }
double squareRoot(double n) { double x = n, y = 1, e = 0.000001; while (x - y > e) { x = (x + y) / 2; y = n / x; } return x; }
int findSum(int n) { int sm = 0; for (int i = 1; i <= n; i++) { for (int j = i; j <= n; j++) { sm += i * j; } } return sm; }
int playGame(int arr[], int n) { std::set<int> s; for(int i = 0; i < n; i++) { s.insert(arr[i]); } return s.size() % 2 == 0 ? 1 : 2; }
bool isDivisible(int n) { while (n >= 100) { int last_digit = n % 10; n /= 10; n += last_digit * 3; } return (n % 29 == 0); }
char first(const std::string& str) { for (int i = 0; i < str.length(); i++) { if (isupper(str[i])) return str[i]; } return '0'; }
int find_extra_element_index(std::vector<int> arrA, std::vector<int> arrB) { int extra_element = std::accumulate(arrA.begin(), arrA.end(), 0) - std::accumulate(arrB.begin(), arrB.end(), 0); return std::find(arrA.begin(), arrA.end(), extra_element) - arrA.begin(); }
int spiralDiaSum(int n) { if (n == 1) return 1; return (4 * n * n - 6 * n + 6 + spiralDiaSum(n - 2)); }
void decToBinary(int n) { for (int i = 31; i >= 0; i--) { int k = n >> i; if (k & 1) std::cout << "1" << " "; else std::cout << "0" << " "; } }
int search(int arr[], int n, int x) { for(int i = 0; i < n; i++) { if(arr[i] == x) { return i; } } return -1; }
int Right_most_setbit(int num) { int pos = 1; for (int i = 0; i < 32; i++) { if (!(num & (1 << i))) pos++; else break; } return pos; }
int smallest(int x, int y, int z) { int c = 0; while (x > 0 && y > 0 && z > 0) { x--; y--; z--; c++; } return c; }
int countOccurrences(int arr[], int n, int x) { int res = 0; for (int i = 0; i < n; i++) { if (x == arr[i]) res++; } return res; }
int getSum(int n) { int sum = 0; while (n != 0) { sum += n % 10; n /= 10; } return sum; }
unsigned int nextPowerOf2(unsigned int n) { unsigned int p = 1; if (n && !(n & (n - 1))) return n; while (p < n) p <<= 1; return p; }
unsigned int numberOfPaths(unsigned int m, unsigned int n) { unsigned int path = 1; for (unsigned int i = n; i < (m + n - 1); ++i) { path *= i; path /= (i - n + 1); } return path; }
unsigned int nextPowerOf2(unsigned int n) { n--; n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16; n++; return n; }
int singleNumber(vector<int>& nums) { return (3 * accumulate(nums.begin(), nums.end(), 0, [](int acc, int n) { return acc + n; })) - accumulate(nums.begin(), nums.end(), 0)) / 2; }
double compute(double a, double b) { double AM = (a + b) / 2; double GM = sqrt(a * b); double HM = (GM * GM) / AM; return HM; }
bool isPerfectSquare(int n) { int i = 1, the_sum = 0; while (the_sum < n) { the_sum += i; if (the_sum == n) return true; i += 2; } return false; }
int sumBetweenTwoKth(vector<int>& arr, int n, int k1, int k2) { sort(arr.begin(), arr.end()); int result = 0; for(int i = k1; i < k2 - 1; i++) result += arr[i]; return result; }
void kLargest(std::vector<int>& arr, int k) { std::sort(arr.begin(), arr.end(), std::greater<int>()); for (int i = 0; i < k; i++) std::cout << arr[i] << " ▁ "; }
int findMinZero(int p) { int first = 1, second = 1, number = 2, next = 1; while (next) { next = (first + second) % p; first = second; second = next; number++; } return number; }
unsigned int catalan(unsigned int n) { if (n <= 1) return 1; unsigned int res = 0; for (int i = 0; i < n; i++) res += catalan(i) * catalan(n - i - 1); return res; }
int findS(int s) { int _sum = 0, n = 1; while (_sum < s) { _sum += n * n; n++; } n--; if (_sum == s) return n; return -1; }
unsigned int evenFib(unsigned int n) { if (n < 1) return n; if (n == 1) return 2; return (4 * evenFib(n - 1)) + evenFib(n - 2); }
bool isTriangular(int num) { if (num < 0) return false; int sum = 0, n = 1; while (sum <= num) { sum += n; if (sum == num) return true; n++; } return false; }
bool check(const std::string& st) { int n = st.size(), digitSum = 0; for (int i = 0; i < n; ++i) digitSum += st[i] - '0'; return digitSum % 9 == 0; }
void transpose(int A[][N], int B[][N]) { for(int i = 0; i < N; i++) { for(int j = 0; j < N; j++) { B[i][j] = A[j][i]; } } }
int fib(int n) { static const int f[6] = {0, 1, 1, 2, 3, 5}; if (n < 6) return f[n]; int t = 5; int fn = 5; const double PHI = (1 + sqrt(5)) / 2; while (t < n) { fn = round(fn * PHI); t++; } return fn; }
bool isPowerOfTwo(int n) { if (n == 0) return false; while (n != 1) { if (n % 2 != 0) return false; n /= 2; } return true; }
int countDigits(int a, int b) { int count = 0, p = abs(a * b); if (p == 0) return 1; while (p > 0) { count++; p /= 10; } return count; }
int findExtra(int arr1[], int arr2[], int n) { for (int i = 0; i < n; i++) { if (arr1[i] != arr2[i]) return i; } return n; }
void reverseStr(std::string& str) { int i = 0, j = str.length() - 1; while (i < j) { std::swap(str[i++], str[j--]); } }
void rotate(int arr[], int n) { int x = arr[n-1]; for (int i = n-1; i > 0; i--) arr[i] = arr[i-1]; arr[0] = x; }
int findS(int s) { int _sum = 0, n = 1; while (_sum < s) { _sum += n * n * n; n++; } n--; if (_sum == s) return n; return -1; }
bool isPowerOfFour(int n) { if (n == 0) return false; while (n != 1) { if (n % 4 != 0) return false; n /= 4; } return true; }
int answer_query(const std::vector<int>& a, int n, int l, int r) { int count = 0; for (int i = l; i < r; ++i) { if (a[i] == a[i + 1]) count++; } return count; }
int findFrequency(vector<int>& arr, int n, int left, int right, int element) { int count = 0; for (int i = left - 1; i < right; i++) { if (arr[i] == element) count++; } return count; }
void query(const std::string& s, int i, int j) { int n = s.length(); i %= n; j %= n; std::cout << (s[i] == s[j] ? "Yes" : "No") << std::endl; }
int smallest(int x, int y, int z) { if (y % x != 0) return (y % z != 0) ? y : z; return (x % z != 0) ? x : z; }
bool check(const std::vector<int>& degree, int n) { int deg_sum = std::accumulate(degree.begin(), degree.end(), 0); return 2 * (n - 1) == deg_sum; }
bool isPalindrome(const std::string& str) { int l = 0, h = str.length() - 1; while (h > l) { if (str[l++] != str[h--]) return false; } return true; }
void printSquares(int n) { int square = 0, odd = 1; for (int x = 0; x < n; x++) { std::cout << square << " ▁ "; square += odd; odd += 2; } }
int minSum(int n) { int sum = 0; while (n > 0) { sum += (n % 10); n /= 10; } if (sum == 1) return 10; return sum; }
bool isOneFlip(const std::string& str) { int sum = 0; for (char c : str) sum += c - '0'; return sum == str.size() - 1 || sum == 1; }
bool squareRootExists(int n, int p) { n = n % p; for (int x = 2; x < p; x++) { if ((x * x) % p == n) return true; } return false; }
int count(int n, int x) { int cnt = 0; for(int i = 1; i <= n; i++) { if(i <= x && (x % i == 0) && (x / i <= n)) cnt++; } return cnt; }
int binomialCoeff(int n, int k) { if (k == 0 || k == n) return 1; return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k); }
void swapDiagonal(int matrix[][N], int N) { for(int i = 0; i < N; i++) { int temp = matrix[i][i]; matrix[i][i] = matrix[i][N-i-1]; matrix[i][N-i-1] = temp; } }
double arcLength(double diameter, double angle) { if (angle >= 360) { std::cout << "Angle cannot be formed" << std::endl; return 0; } else { double arc = (3.142857142857143 * diameter) * (angle / 360.0); return arc; } }
int breakSum(int n) { if (n == 0 || n == 1) return n; return max(breakSum(n / 2) + breakSum(n / 3) + breakSum(n / 4), n); }
bool isDivBy9(int n) { if (n == 0 || n == 9) return true; if (n < 9) return false; return isDivBy9((n >> 3) - (n & 7)); }
bool isDivisible(const std::string& str, int k) { int n = str.length(); int c = 0; for (int i = 0; i < k; i++) { if (str[n - i - 1] == '0') c++; } return (c == k); }
int findSum(int n) { n -= 1; int sum = 0; sum += (n * (n + 1)) / 2; sum += (n * (n + 1) * (2 * n + 1)) / 6; return sum; }
int findNth(int n) { int nthElement = 19 + (n - 1) * 9; int outliersCount = log10(nthElement) - 1; nthElement += 9 * outliersCount; return nthElement; }
unsigned int decimalToBinary(unsigned int N) { unsigned int B_Number = 0, cnt = 0, rem, c; while (N != 0) { rem = N % 2; c = 1; for (unsigned int i = 0; i < cnt; ++i) c *= 10; B_Number += rem * c; N /= 2; cnt++; } return B_Number; }
char first(const string& str, int i) { if (str[i] == '\0') return '0'; if (isupper(str[i])) return str[i]; return first(str, i + 1); }
std::string lexSmallest(std::vector<std::string>& a, int n) { std::sort(a.begin(), a.end(), std::greater<std::string>()); std::string answer = ""; for(int i = 0; i < n; i++) answer += a[i]; return answer; }
int countSubStr(const string& st, int n) { int m = 0; for (int i = 0; i < n; i++) { if (st[i] == '1') m++; } return m * (m - 1) / 2; }
int remainder(const std::string& st) { int ln = st.length(), rem = 0; for (int i = 0; i < ln; ++i) { int num = rem * 10 + (st[i] - '0'); rem = num % 11; } return rem; }
int findRotations(std::string str) { std::string tmp = str + str; int n = str.length(); for (int i = 1; i <= n; i++) { std::string substring = tmp.substr(i, n); if (str == substring) { return i; } } return n; }
void randomize(vector<int>& arr, int n) { for (int i = n - 1; i > 0; i--) { int j = rand() % (i + 1); swap(arr[i], arr[j]); } }
int gcd(int a, int b) { if (a < b) return gcd(b, a); if (b == 0) return a; return gcd(b, a % b); }
int countNonDecreasing(int n) { int N = 10, count = 1; for (int i = 1; i <= n; i++) { count = count * (N + i - 1); count = count / i; } return count; }
int countRect(int n) { int ans = 0; for (int length = 1; length <= sqrt(n); ++length) { int height = length; while (height * length <= n) { ans++; height++; } } return ans; }
bool canMakeAllSame(const std::string& str) { int zeros = 0, ones = 0; for (char ch : str) { if (ch == '0') zeros++; else ones++; } return zeros == 1 || ones == 1; }
int fib(int n, vector<int>& lookup) { if (n == 0 || n == 1) lookup[n] = n; if (lookup[n] == -1) lookup[n] = fib(n-1, lookup) + fib(n-2, lookup); return lookup[n]; }
int selectRandom(int x) { static int res = 0; static int count = 0; count++; if (count == 1) res = x; else { int i = rand() % count; if (i == count - 1) res = x; } return res; }
void transpose(vector<vector<int>>& A) { for(int i = 0; i < A.size(); ++i) { for(int j = i + 1; j < A.size(); ++j) { swap(A[i][j], A[j][i]); } } }
void printSquares(int n) { int square = 0, prev_x = 0; for(int x = 0; x < n; x++) { square += x + prev_x; std::cout << square << " ▁ "; prev_x = x; } }
int firstFactorialDivisibleNumber(int x) { int i = 1, fact = 1; for (i = 1; i < x; i++) { fact *= i; if (fact % x == 0) break; } return i; }
int getInvCount(int arr[], int n) { int inv_count = 0; for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) if (arr[i] > arr[j]) inv_count++; return inv_count; }
int countPairs(int arr[], int n) { int ans = 0; for(int i = 0; i < n; i++) { for(int j = i + 1; j < n; j++) { if(arr[i] == arr[j]) { ans++; } } } return ans; }
void recursiveReverse(std::string& str, int i = 0) { int n = str.size(); if (i == n / 2) return; std::swap(str[i], str[n - i - 1]); recursiveReverse(str, i + 1); }
int countInRange(int arr[], int n, int x, int y) { int count = 0; for(int i = 0; i < n; i++) { if(arr[i] >= x && arr[i] <= y) count++; } return count; }
bool isOverflow(long a, long b) { if (a == 0 || b == 0) return false; long result = a * b; if (result >= 9223372036854775807LL || result <= -9223372036854775807LL - 1) result = 0; if (a == (result / b)) { std::cout << result / b << std::endl; return false; } else return true; }
bool checkcircle(int r, int R, int r1, int x1, int y1) { int dis = sqrt(x1 * x1 + y1 * y1); return (dis - r1 >= R && dis + r1 <= r); }
int octalToDecimal(int n) { int num = n; int dec_value = 0; int base = 1; while (num > 0) { int last_digit = num % 10; num = num / 10; dec_value += last_digit * base; base = base * 8; } return dec_value; }
bool isSymmetric(int mat[][N], int N) { for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { if (mat[i][j] != mat[j][i]) { return false; } } } return true; }
void shuffle(int card[], int n) { int i, r, tmp; for(i = 0; i < n; i++) { r = i + (rand() % (52 - i)); tmp = card[i]; card[i] = card[r]; card[r] = tmp; } }
double minRevolutions(double r, double x1, double y1, double x2, double y2) { double d = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); return ceil(d / (2 * r)); }
int countCommon(vector<vector<int>>& mat, int n) { int res = 0; for (int i = 0; i < n; i++) { if (mat[i][i] == mat[i][n-i-1]) res++; } return res; }
bool isPrime(int n, int i = 2) { if (n <= 2) return (n == 2) ? true : false; if (n % i == 0) return false; if (i * i > n) return true; return isPrime(n, i + 1); }
int maxProd(int n) { if (n == 2 || n == 3) return (n - 1); int res = 1; while (n > 4) { n -= 3; res *= 3; } return (n * res); }
int minTime(int arr[], int n, int m) { int t = 0; while (true) { int items = 0; for (int i = 0; i < n; i++) { items += t / arr[i]; } if (items >= m) { return t; } t++; } }
bool isPossibleTriangle(vector<int>& arr, int N) { if (N < 3) return false; sort(arr.begin(), arr.end()); for (int i = 0; i < N - 2; i++) { if (arr[i] + arr[i + 1] > arr[i + 2]) return true; } return false; }
int middleOfThree(int a, int b, int c) { int x = a - b; int y = b - c; int z = a - c; if (x * y > 0) return b; else if (x * z > 0) return c; else return a; }
int findRepeating(int arr[], int n) { std::unordered_set<int> s; for(int i = 0; i < n; i++) { if(s.find(arr[i]) != s.end()) return arr[i]; s.insert(arr[i]); } return -1; }
double maxArea(double a, double b, double c, double d) { double semiperimeter = (a + b + c + d) / 2; return sqrt((semiperimeter - a) * (semiperimeter - b) * (semiperimeter - c) * (semiperimeter - d)); }
int findDigits(int n) { if (n < 0) return 0; if (n <= 1) return 1; double digits = 0; for (int i = 2; i <= n; i++) digits += log10(i); return floor(digits) + 1; }
bool isInorder(int arr[], int n) { if (n == 0 || n == 1) return true; for (int i = 1; i < n; i++) if (arr[i - 1] > arr[i]) return false; return true; }
bool isMajority(vector<int>& a) { unordered_map<int, int> mp; for (int num : a) { mp[num]++; } for (auto& p : mp) { if (p.second >= a.size() / 2) return true; } return false; }
int findStep(int n) { if (n == 0 || n == 1) return 1; else if (n == 2) return 2; else return findStep(n - 3) + findStep(n - 2) + findStep(n - 1); }
int findPosition(int k, int n) { int f1 = 0, f2 = 1, i = 2; while (true) { int f3 = f1 + f2; f1 = f2; f2 = f3; if (f2 % k == 0) return n * i; i++; } }
int minimum_cost(int a[], int n) { int mn = INT_MAX, sum = 0; for(int i = 0; i < n; i++) { mn = std::min(a[i], mn); sum += a[i]; } return mn * (sum - mn); }
int kthdigit(int a, int b, int k) { int p = pow(a, b); int count = 0; while (p > 0 && count < k) { int rem = p % 10; count++; if (count == k) return rem; p /= 10; } return -1; }
int numberOfWays(int x) { if (x == 0 || x == 1) return 1; else return numberOfWays(x - 1) + (x - 1) * numberOfWays(x - 2); }
int sumNodes(int l) { int leafNodeCount = pow(2, l - 1); int sumLastLevel = ((leafNodeCount * (leafNodeCount + 1)) / 2); int sum = sumLastLevel * l; return sum; }
int leonardo(int n) { std::vector<int> dp = {1, 1}; for(int i = 2; i <= n; ++i) dp.push_back(dp[i-1] + dp[i-2] + 1); return dp[n]; }
void add(int A[][N], int B[][N], int C[][N], int N) { for(int i = 0; i < N; i++) { for(int j = 0; j < N; j++) { C[i][j] = A[i][j] + B[i][j]; } } }
bool arraySortedOrNot(int arr[], int n) { if (n == 0 || n == 1) return true; for (int i = 1; i < n; i++) { if (arr[i-1] > arr[i]) return false; } return true; }
int findSum(int n) { int multiTerms = n * (n + 1) / 2; int sm = multiTerms; for (int i = 2; i <= n; i++) { multiTerms = multiTerms - (i - 1); sm += multiTerms * i; } return sm; }
bool isCornerPresent(const std::string& str, const std::string& corner) { int n = str.length(); int cl = corner.length(); if (n < cl) { return false; } return (str.substr(0, cl) == corner && str.substr(n - cl, cl) == corner); }
bool isDiagonalMatrix(int mat[N][N]) { for(int i = 0; i < N; i++) { for(int j = 0; j < N; j++) { if((i != j) && (mat[i][j] != 0)) return false; } } return true; }
int minimumflip(vector<vector<int>>& mat, int n) { int flip = 0; for (int i = 0; i < n; i++) { for (int j = 0; j < i; j++) { if (mat[i][j] != mat[j][i]) { flip++; } } } return flip; }
int findIndex(int n) { if (n <= 1) return n; int a = 0, b = 1, c = 1, res = 1; while (c < n) { c = a + b; res++; a = b; b = c; } return res; }
void constructArr(int arr[], int pair[], int n) { arr[0] = (pair[0] + pair[1] - pair[n-1]) / 2; for(int i = 1; i < n; i++) arr[i] = pair[i-1] - arr[0]; }
bool checkMarkov(const vector<vector<double>>& m) { for (int i = 0; i < m.size(); i++) { double sm = 0; for (int j = 0; j < m[i].size(); j++) { sm += m[i][j]; } if (sm != 1) return false; } return true; }
int findMod(int a, int b) { if (a < 0) a = -a; if (b < 0) b = -b; int mod = a; while (mod >= b) mod -= b; if (a < 0) return -mod; return mod; }
void recursiveReverse(std::string &str) { std::stack<char> stack; for(char c : str) stack.push(c); for(int i = 0; i < str.size(); i++) { str[i] = stack.top(); stack.pop(); } }
void multiply(int A[ ][ ], int B[ ][ ], int C[ ][ ], int N) { for(int i = 0; i < N; i++) { for(int j = 0; j < N; j++) { C[i][j] = A[i][j] - B[i][j]; } } }
int minValue(vector<int>& A, vector<int>& B, int n) { sort(A.begin(), A.end()); sort(B.begin(), B.end(), greater<int>()); int result = 0; for(int i = 0; i < n; i++) { result += A[i] * B[i]; } return result; }
std::string decToBin(unsigned int n) { std::string bin = ""; if (n == 0) return "0"; while (n > 0) { bin = (n & 1 ? '1' : '0') + bin; n >>= 1; } return bin; }
void rotateMatrix(int mat[N][N]) { for (int i = N-1; i >= 0; i--) { for (int j = N-1; j >= 0; j--) { std::cout << mat[i][j] << " "; } std::cout << std::endl; } }
int russianPeasant(int a, int b) { int res = 0; while (b > 0) { if (b & 1) res += a; a <<= 1; b >>= 1; } return res; }
void splitArr(int arr[], int n, int k) { for (int i = 0; i < k; i++) { int x = arr[0]; for (int j = 0; j < n - 1; j++) arr[j] = arr[j + 1]; arr[n - 1] = x; } }
int CountPairs(int n) { int k = n; int imin = 1; int ans = 0; while (imin <= n) { int imax = n / k; ans += k * (imax - imin + 1); imin = imax + 1; k = n / imin; } return ans; }
int lastPosition(int n, int m, int k) { if (m <= n - k + 1) return m + k - 1; m = m - (n - k + 1); if (m % n == 0) return n; else return m % n; }
int minimumSquare(int a, int b) { int result = 0, rem = 0; if (a < b) { int temp = a; a = b; b = temp; } while (b > 0) { result += a / b; rem = a % b; a = b; b = rem; } return result; }
void printFibonacciNumbers(int n) { int f1 = 0, f2 = 1; if (n < 1) return; for (int x = 0; x < n; x++) { std::cout << f2 << " ▁ "; int next = f1 + f2; f1 = f2; f2 = next; } }
std::string minLexRotation(const std::string& str_) { int n = str_.length(); std::vector<std::string> arr(n); for (int i = 0; i < n; ++i) arr[i] = str_.substr(i) + str_.substr(0, i); std::sort(arr.begin(), arr.end()); return arr[0]; }
int search(int arr[], int n, int x) { int i = 0; while (i <= n - 1) { if (arr[i] == x) return i; i += abs(arr[i] - x); } return -1; }
int findHeight(vector<int>& parent, int n) { int res = 0; for(int i = 0; i < n; i++) { int p = i; int current = 1; while(parent[p] != -1) { current++; p = parent[p]; } res = max(res, current); } return res; }
int maxPrefix(const std::string& s, const std::string& t) { int count = 0; for (int i = 0; i < t.length(); i++) { if (count == s.length()) { break; } if (t[i] == s[count]) { count++; } } return count; }
int findMaximum(int arr[], int low, int high) { int max = arr[low]; for (int i = low; i <= high; i++) { if (arr[i] > max) max = arr[i]; } return max; }
int findSum(const std::string& str1) { std::string temp = ""; int Sum = 0; for (char ch : str1) { if (isdigit(ch)) temp += ch; else { Sum += atoi(temp.c_str()); temp = "0"; } } return Sum + atoi(temp.c_str()); }
double mirrorImage(double a, double b, double c, double x1, double y1) { double temp = -2 * (a * x1 + b * y1 + c) / (a * a + b * b); double x = temp * a + x1; double y = temp * b + y1; return std::make_pair(x, y); }
int moduloMultiplication(int a, int b, int mod) { int res = 0; a = a % mod; while (b) { if (b & 1) { res = (res + a) % mod; } a = (2 * a) % mod; b >>= 1; } return res; }
int subset(int arr[], int n) { std::map<int, int> mp; for(int i = 0; i < 10; ++i) mp[i] = 0; for(int i = 0; i < n; ++i) mp[arr[i]]++; int res = 0; for(auto& [key, value] : mp) res = std::max(res, value); return res; }
int findMinDiff(vector<int>& arr, int n) { sort(arr.begin(), arr.end()); int diff = INT_MAX; for(int i = 0; i < n - 1; i++) { if (arr[i + 1] - arr[i] < diff) diff = arr[i + 1] - arr[i]; } return diff; }
int CountSquares(int a, int b) { int cnt = 0; for (int i = a; i <= b; i++) { for (int j = 1; j * j <= i; j++) { if (j * j == i) { cnt++; } } } return cnt; }
int count_of_ways(int n) { int count = 0; for (int i = 0; i <= n; i++) { for (int j = 0; j <= n; j++) { for (int k = 0; k <= n; k++) { if (i + j + k == n) { count++; } } } } return count; }
int countFriendsPairings(int n) { int a = 1, b = 2, c = 0; if (n <= 2) return n; for (int i = 3; i <= n; i++) { c = b + (i - 1) * a; a = b; b = c; } return c; }
unsigned int exponentiation(unsigned int bas, unsigned int exp) { unsigned int t = 1; while(exp > 0) { if(exp % 2 != 0) t = (t * bas) % N; bas = (bas * bas) % N; exp /= 2; } return t % N; }
int countSolutions(int n) { int res = 0, x = 0; while (x * x < n) { int y = 0; while (x * x + y * y < n) { res++; y++; } x++; } return res; }
#include <iostream> #include <numeric> using namespace std; void maximizecube(int l, int b, int h) {int side = gcd(l, gcd(b, h)); num *= b / side; num *= h / side; cout << side << " " << num << endl;}
int minXOR(int arr[], int n) { sort(arr, arr + n); int min_xor = 999999; for (int i = 0; i < n - 1; i++) { for (int j = i + 1; j < n; j++) { int val = arr[i] ^ arr[j]; if (val < min_xor) min_xor = val; } } return min_xor; }
int maxProduct(int arr[], int n) { if (n < 3) return -1; sort(arr, arr + n); return max(arr[0] * arr[1] * arr[n-1], arr[n-1] * arr[n-2] * arr[n-3]); }
bool isDivisibleBy7(int num) { if (num < 0) return isDivisibleBy7(-num); if (num == 0 || num == 7) return true; if (num < 10) return false; return isDivisibleBy7(num / 10 - 2 * (num % 10)); }
int eulerian(int n, int m) { if (m >= n || n == 0) return 0; if (m == 0) return 1; return ((n - m) * eulerian(n - 1, m - 1) + (m + 1) * eulerian(n - 1, m)); }
int recSearch(int arr[], int l, int r, int x) { if (r < l) return -1; if (arr[l] == x) return l; if (arr[r] == x) return r; return recSearch(arr, l + 1, r - 1, x); }
int numofsubset(vector<int> arr, int n) { sort(arr.begin(), arr.end()); int count = 1; for (int i = 0; i < n - 1; i++) { if (arr[i] + 1 != arr[i + 1]) count++; } return count; }
int binaryToDecimal(std::string n) { int num = stoi(n); int dec_value = 0; int base1 = 1; while(num > 0) { int last_digit = num % 10; num = num / 10; dec_value += last_digit * base1; base1 = base1 * 2; } return dec_value; }
int countSubstringWithEqualEnds(const std::string& s) { int result = 0, n = s.length(); for (int i = 0; i < n; ++i) { for (int j = i; j < n; ++j) { if (s[i] == s[j]) { result++; } } } return result; }
int binarySearch(int arr[], int l, int r, int x) { while (l <= r) { int mid = l + (r - l) / 2; if (arr[mid] == x) return mid; else if (arr[mid] < x) l = mid + 1; else r = mid - 1; } return -1; }
void decToBinary(int n) { int binaryNum[32]; int i = 0; while (n > 0) { binaryNum[i] = n % 2; n = n / 2; i++; } for (int j = i - 1; j >= 0; j--) std::cout << binaryNum[j] << " "; }
unsigned int mulmod(unsigned int a, unsigned int b, unsigned int mod) { unsigned int res = 0; a = a % mod; while (b > 0) { if (b % 2 == 1) res = (res + a) % mod; a = (a * 2) % mod; b /= 2; } return res % mod; }
int firstNonRepeating(int arr[], int n) { std::unordered_map<int, int> mp; for (int i = 0; i < n; i++) mp[arr[i]]++; for (int i = 0; i < n; i++) if (mp[arr[i]] == 1) return arr[i]; return -1; }
int middleOfThree(int a, int b, int c) { if ((a < b && b < c) || (c < b && b < a)) return b; if ((b < a && a < c) || (c < a && a < b)) return a; else return c; }
int multiply(int x, int y) { if (y == 0) return 0; if (y > 0) return x + multiply(x, y - 1); if (y < 0) return -multiply(x, -y); }
void to_upper(char* string) { for(int i = 0; string[i] != '\0'; i++) { if('a' <= string[i] && string[i] <= 'z') string[i] = string[i] - 'a' + 'A'; } }
int findMinSum(vector<int>& a, vector<int>& b, int n) { sort(a.begin(), a.end()); sort(b.begin(), b.end()); int sum = 0; for(int i = 0; i < n; i++) { sum += abs(a[i] - b[i]); } return sum; }
#include <unordered_map> bool checkCount(int arr[], int n, int k) { std::unordered_map<int, int> mp; for(int i = 0; i < n; ++i) { mp[arr[i]]++; } for(auto& p : mp) { if(p.second > 2 * k) { return false; } } return true; }
int nonFibonacci(int n) { int prevPrev = 1, prev = 2, curr = 3; while (n > 0) { prevPrev = prev; prev = curr; curr = prevPrev + prev; n = n - (curr - prev - 1); } n = n + (curr - prev - 1); return prev + n; }
int minXOR(vector<int>& arr) { sort(arr.begin(), arr.end()); int minXor = INT_MAX, val = 0; for(int i = 0; i < arr.size() - 1; i++) { val = arr[i] ^ arr[i + 1]; minXor = min(minXor, val); } return minXor; }
bool isPowerOfFour(int n) { int count = 0; if (n && !(n & (n - 1))) { while (n > 1) { n >>= 1; count++; } if (count % 2 == 0) return true; else return false; } else return false; }
int firstNonRepeating(int arr[], int n) { for (int i = 0; i < n; i++) { int j = 0; while (j < n) { if (i != j && arr[i] == arr[j]) break; j++; } if (j == n) return arr[i]; } return -1; }
int power(int x, int y, int p) { int res = 1; x = x % p; while (y > 0) { if (y & 1) res = (res * x) % p; y = y >> 1; x = (x * x) % p; } return res; }
bool isPossible(vector<int>& a, vector<int>& b, int n, int k) { sort(a.begin(), a.end(), greater<int>()); sort(b.begin(), b.end()); for(int i = 0; i < n; ++i) { if(a[i] + b[i] < k) return false; } return true; }
void printDistinct(int arr[], int n) { std::unordered_map<int, int> s; for (int i = 0; i < n; i++) { if (s.find(arr[i]) == s.end()) { s[arr[i]] = arr[i]; std::cout << arr[i] << " ▁ "; } } }
unsigned int countSeq(unsigned int n) { unsigned int nCr = 1, res = 1; for (unsigned int r = 1; r <= n; ++r) { nCr = (nCr * (n + 1 - r)) / r; res += nCr * nCr; } return res; }
int countNegative(int M[][100], int n, int m) { int count = 0; for(int i = 0; i < n; i++) { for(int j = 0; j < m; j++) { if(M[i][j] < 0) { count++; } else { break; } } } return count; }
bool isPrime(int p) { int checkNumber = (1 << p) - 1; int nextval = 4 % checkNumber; for (int i = 1; i < p - 1; i++) { nextval = (nextval * nextval - 2) % checkNumber; } return nextval == 0; }
double minPerimeter(int n) { double l = sqrt(n); int sq = l * l; if (sq == n) return l * 4; else { double row = n / l; double perimeter = 2 * (l + row); if (n % (int)l != 0) perimeter += 2; return perimeter; } }
int sequence(int n) { std::vector<int> f = {0, 1, 1}; for(int i = 3; i <= n; i++) { int r = f[f[i-1]] + f[i-f[i-1]]; f.push_back(r); } return f.back(); }
int countIntegralSolutions(int n) { int result = 0; for (int i = 0; i <= n; i++) { for (int j = 0; j <= n; j++) { for (int k = 0; k <= n; k++) { if (i + j + k == n) { result++; } } } } return result; }
int maxGameByWinner(int N) { vector<int> dp(N, 0); dp[0] = 1; dp[1] = 2; int i = 1; while (dp[i] <= N) { i++; dp[i] = dp[i-1] + dp[i-2]; } return (i - 1); }
int numberOfPaths(int p, int q) { std::vector<int> dp(q, 1); for (int i = 0; i < p - 1; i++) { for (int j = 1; j < q; j++) { dp[j] += dp[j - 1]; } } return dp[q - 1]; }
int minOperation(int arr[], int n) { std::unordered_map<int, int> Hash; for(int i = 0; i < n; i++) Hash[arr[i]]++; int max_count = 0; for(auto &p : Hash) if(max_count < p.second) max_count = p.second; return n - max_count; }
void bubbleSort(vector<int>& arr) { int n = arr.size(); for (int i = 0; i < n; i++) { for (int j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { swap(arr[j], arr[j + 1]); } } } }
void findCombinations(const std::string& str, int index, const std::string& out) { if (index == str.length()) { std::cout << out << std::endl; } for (int i = index; i < str.length(); i++) { findCombinations(str, i + 1, out + " ( " + str.substr(index, i - index + 1) + " ) "); } }
int countDivisibles(vector<int>& arr, int n) { int res = 0; for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { if (arr[i] % arr[j] == 0 || arr[j] % arr[i] == 0) { res++; } } } return res; }
int maxTasks(vector<int>& high, vector<int>& low, int n) { if (n <= 0) return 0; return max(high[n-1] + maxTasks(high, low, n-2), low[n-1] + maxTasks(high, low, n-1)); }
void printDistinct(int arr[], int n) { for (int i = 0; i < n; i++) { bool found = false; for (int j = 0; j < i; j++) { if (arr[i] == arr[j]) { found = true; break; } } if (!found) { std::cout << arr[i] << std::endl; } } }
void findElements(int arr[], int n) { for (int i = 0; i < n; i++) { int count = 0; for (int j = 0; j < n; j++) { if (arr[j] > arr[i]) { count++; } } if (count >= 2) { cout << arr[i] << " ▁ "; } } }
int nearestSmallerEqFib(int n) { if (n == 0 || n == 1) return n; int f1 = 0, f2 = 1, f3 = 1; while (f3 <= n) { f1 = f2; f2 = f3; f3 = f1 + f2; } return f2; }
int findMinDiff(int arr[], int n) { int diff = INT_MAX; for (int i = 0; i < n - 1; i++) { for (int j = i + 1; j < n; j++) { int currentDiff = abs(arr[i] - arr[j]); if (currentDiff < diff) { diff = currentDiff; } } } return diff; }
void subArray(int arr[], int n) { for (int i = 0; i < n; i++) { for (int j = i; j < n; j++) { for (int k = i; k <= j; k++) std::cout << arr[k] << " "; std::cout << "\n"; } } }
int distancesum(int x[], int y[], int n) { int sum = 0; for(int i = 0; i < n; i++) { for(int j = i + 1; j < n; j++) { sum += (abs(x[i] - x[j]) + abs(y[i] - y[j])); } } return sum; }
int CountWays(int n) { std::vector<int> table(n + 1, 0); table[0] = 1; for (int i = 1; i < n; i++) { for (int j = i; j <= n; j++) { table[j] += table[j - i]; } } return table[n]; }
int maxSubarrayXOR(int arr[], int n) { int ans = INT_MIN; for(int i = 0; i < n; i++) { int curr_xor = 0; for(int j = i; j < n; j++) { curr_xor = curr_xor ^ arr[j]; ans = max(ans, curr_xor); } } return ans; }
bool isIdentity(int mat[][100], int N) { for(int row = 0; row < N; ++row) { for(int col = 0; col < N; ++col) { if((row == col && mat[row][col] != 1) || (row != col && mat[row][col] != 0)) return false; } } return true; }
int insertSorted(int arr[], int n, int key, int capacity) { if (n >= capacity) return n; int i = n - 1; while (i >= 0 && arr[i] > key) { arr[i + 1] = arr[i]; i--; } arr[i + 1] = key; return (n + 1); }
void solve(std::vector<int> &arr, int n, int &result) { std::sort(arr.begin(), arr.end()); int a = 0, b = 0; for (int i = 0; i < n; ++i) { if (i % 2 != 0) a = a * 10 + arr[i]; else b = b * 10 + arr[i]; } result = a + b; }
int findSum(const vector<int>& A, const vector<int>& B, int n) { unordered_map<int, int> Hash; for (int i = 0; i < n; i++) { Hash[A[i]]++; Hash[B[i]]++; } int Sum = 0; for (auto& x : Hash) { if (x.second == 1) { Sum += x.first; } } return Sum; }
int maxLen(vector<int>& arr) { int max_len = 0; for (int i = 0; i < arr.size(); i++) { int curr_sum = 0; for (int j = i; j < arr.size(); j++) { curr_sum += arr[j]; if (curr_sum == 0) { max_len = max(max_len, j - i + 1); } } } return max_len; }
int minRadius(int k, const vector<int>& x, const vector<int>& y, int n) { vector<int> dis(n); for(int i = 0; i < n; i++) dis[i] = x[i] * x[i] + y[i] * y[i]; sort(dis.begin(), dis.end()); return dis[k - 1]; }
void generate(int ones, int zeroes, std::string str, int len1) { if (len1 == str.length()) { std::cout << str << " ▁ "; return; } generate(ones + 1, zeroes, str + "1", len1); if (ones > zeroes) { generate(ones, zeroes + 1, str + "0", len1); } }
int search(int arr[], int n, int x) { int i = 0; while (i < n) { if (arr[i] == x) { return i; } i += abs(arr[i] - x); } std::cout << "number is not present!" << std::endl; return -1; }
int search(int arr[], int n, int x, int k) { int i = 0; while (i < n) { if (arr[i] == x) return i; i += max(1, abs(arr[i] - x) / k); } std::cout << "number is not present!" << std::endl; return -1; }
int countPairsWithDiffK(int arr[], int n, int k) { int count = 0; for(int i = 0; i < n; i++) { for(int j = i + 1; j < n; j++) { if(abs(arr[i] - arr[j]) == k) count++; } } return count; }
int countNegative(int M[][100], int n, int m) { int count = 0, i = 0, j = m - 1; while (j >= 0 && i < n) { if (M[i][j] < 0) { count += (j + 1); i++; } else { j--; } } return count; }
int findMinX(int num[], int rem[], int k) { int x = 1; while (true) { int j = 0; while (j < k) { if (x % num[j] != rem[j]) break; j++; } if (j == k) return x; x++; } }
std::string removeDuplicates(std::string S) { int n = S.length(); if (n < 2) return S; int j = 0; for (int i = 0; i < n; i++) { if (S[j] != S[i]) { j++; S[j] = S[i]; } } return S.substr(0, j + 1); }
bool distributingBalls(int k, int n, const string &str) { const int MAX_CHAR = 26; int a[MAX_CHAR] = {0}; for (int i = 0; i < n; i++) { a[str[i] - 'a']++; } for (int i = 0; i < MAX_CHAR; i++) { if (a[i] > k) { return false; } } return true; }
void insertionSortRecursive(int arr[], int n) { if (n <= 1) return; insertionSortRecursive(arr, n-1); int last = arr[n-1], j = n-2; while (j >= 0 && arr[j] > last) { arr[j+1] = arr[j]; j--; } arr[j+1] = last; }
bool areEqual(vector<int>& arr1, vector<int>& arr2) { if (arr1.size() != arr2.size()) return false; sort(arr1.begin(), arr1.end()); sort(arr2.begin(), arr2.end()); for (int i = 0; i < arr1.size(); i++) if (arr1[i] != arr2[i]) return false; return true; }
int getOddOccurrence(int arr[], int arr_size) { for (int i = 0; i < arr_size; i++) { int count = 0; for (int j = 0; j < arr_size; j++) { if (arr[i] == arr[j]) { count++; } } if (count % 2 != 0) { return arr[i]; } } return -1; }
bool checkIsAP(vector<int>& arr, int n) { if (n == 1) return true; sort(arr.begin(), arr.end()); int d = arr[1] - arr[0]; for (int i = 2; i < n; i++) { if (arr[i] - arr[i - 1] != d) return false; } return true; }
int minOps(vector<int>& arr, int n, int k) { int max1 = *max_element(arr.begin(), arr.end()); int res = 0; for(int i = 0; i < n; i++) { if((max1 - arr[i]) % k != 0) return -1; else res += (max1 - arr[i]) / k; } return res; }
